{
    "docs": [
        {
            "location": "/", 
            "text": "资料\n\n\n\n\nC++ Primer 第5版\n\n\nC++参考手册", 
            "title": "Home"
        }, 
        {
            "location": "/#_1", 
            "text": "C++ Primer 第5版  C++参考手册", 
            "title": "资料"
        }, 
        {
            "location": "/ch01 开始/", 
            "text": "开始\n\n\n学习一门新的程序设计语言的最好方法就是练习编写程序。\n\n\n\n\n编写一个简单的C++程序\n\n\n每个C++程序都包含一个或多个函数（function），其中一个必须命名为\nmain\n。操作系统通过调用main来运行C++程序。\n\n\n下面是一个简单的main函数，它什么都不做，只是返回给操作系统一个值：\n\n\nint main()\n{\n    return 0;\n}\n\n\n\n\nmain函数的返回类型必须为int。int类型是一种\n内置类型\n（built-in type），即语言自身定义的类型。\n\n\n函数体是一个以左\n花括号\n（curly brace）开始，以右花括号结束的语句块（block of statements）。\n\n\nreturn语句结束函数的执行。main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。\n\n\n重要概念：类型\n\n\n一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。程序所处理的数据都保存在变量中，而每个变量都拥有自己的类型。\n\n\n编译、运行程序\n\n\n编写好程序后，我们就需要编译它，这依赖于操作系统和编译器。\n\n\n程序源文件命名约定\n\n\n程序文件通常被称为源文件（source file）。它以一个后缀为结尾，告诉系统这个文件是一个C++程序，比如.cpp。\n\n\n初识输入输出\n\n\nC++包含了一个全面的\n标准库\n（standard library）来提供IO机制（以及很多其他设施）。\n\n\niostream\n库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。\n\n\n标准输入输出对象\n\n\n标准库定义了4个IO对象。为了处理输入，使用名为cin的istream类型的对象。这个对象被称为\n标准输入\n（standard input）。对于输出，使用名为cout的ostream类型的对象。这个对象被称为\n标准输出\n（standard output）。另外还有其他两个ostream对象，名为cerr和clog，cerr通常用来输出警告和错误消息，因此被称为\n标准错误\n（standard error）。clog用来输出程序运行时的一般性消息。\n\n\n系统通常将程序所运行的窗口与这些对象关联起来。因此，当读取cin，数据将从程序正在运行的窗口读入，当向cout写入数据时，将会写到同一个窗口。\n\n\n\n\nmy note：clog关联到标准错误，默认情况下，写到clog的数据是被缓冲的。写到cerr的数据是不缓冲的。\n\n\n\n\n一个使用IO库的程序\n\n\n#include \niostream\n\nint main()\n{\n        std::cout \n \nEnter two numbers:\n \n std::endl;\n        int v1 = 0, v2 = 0;\n        std::cin \n v1 \n v2;\n        std::cout \n \nThe sum of \n \n v1 \n \n and \n \n v2 \n \n is \n\n                          \n v1 + v2 \n std::endl;\n        return 0;\n}\n\n\n\n\n#include \niostream\n告诉编译器我们想要使用iostream库。尖括号中的名字指出了一个\n头文件\n（header）。每个使用标准库设施的程序都必须包含相关的头文件。#include指令和头文件的名字必须写在同一行中。#include指令一般出现在所有函数之外，源文件的开始位置。\n\n\n向流写入数据\n\n\nstd::cout \n \nEnter two numbers\n \n std::endl;\n\n\n\n\n这条语句执行了一个\n表达式\n（expression）。在C++中，一个表达式产生一个计算结果，它由一个或多个运算对象和（通常是）一个运算符组成。这条语句中的表达式使用了\n输出运算符\n（\n）。\n\n\n运算符接受两个运算对象：左侧必须是一个ostream对象；右侧是要打印的值。此运算符将给定的值写到给定的ostream对象中。计算结果是左侧的ostream对象。\n\n\n\"Enter two numbers\"是一个\n字符串字面值常量\n（string literal），它是用一对双引号包围的字符序列。\n\n\nendl是一个被称为\n操纵符\n（manipulator）的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。\n\n\n\n\nmy note: 一个表达式接一个分号就是一条语句。\n\n\n\n\n使用标准库中的名字\n\n\n前缀std::指出名字cout和endl是定义在名为\nstd\n的\n命名空间\n（namespace）中的。\n\n\n命名空间可以帮助我们避免不经意的名字定义冲突。标准库定义的所有名字都在命名空间std中。\n\n\n从流读取数据\n\n\n首先定义两个名为v1和v2的\n变量\n（variable）来保存输入：\n\n\nint v1 = 0, v2 = 0;\n\n\n\n\n这两个变量被定义为int类型，并\n初始化\n（initialize）为0。初始化一个变量，就是在变量创建的同时为它赋予一个值。\n\n\nstd::cin \n v1 \n v2;\n\n\n\n\n这条语句读入输入数据。\n输入运算符\n（\n）接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。输入运算符返回其左侧运算对象作为计算结果。\n\n\n注释简介\n\n\n注释（comments）通常用于概述算法，确定变量的用途，或者解释晦涩难懂的代码段。编译器会忽略掉注释，因此注释对程序的行为和性能不会有任何影响。\n\n\nC++中注释的种类\n\n\nC++中有两种注释：单行注释和界定符注释。\n\n\n注释界定符不能嵌套\n\n\n界定符对形式的注释是以\n/*\n开始，以\n*/\n结束的。因此，一个注释不能嵌套在另一个注释之内。\n\n\n如果在调试期间要注释掉包含界定符对形式注释的代码，最好的方式是用单行注释方式注释掉代码段的每一行。\n\n\n// /*\n//  * comments\n//  */\n\n\n\n\n控制流\n\n\n语句一般是顺序执行的，语句块的第一条语句首先执行，然后是第二条，以此类推。但程序设计语言提供了多种不同的控制语句，允许我们写出更为复杂的执行路径。\n\n\nwhile语句\n\n\nwhile语句反复执行一段代码，直到给定条件为假为止。\n\n\nwhile语句的形式为：\n\n\nwhile (condition)\n    statement\n\n\n\n\nwhile语句的执行过程是交替地检测condition条件和执行关联的语句statement，直至condition为假时停止。所谓\n条件\n就是一个产生真或假的结果的表达式。\n\n\nstatement可以是语句块，也叫循环体。所谓语句块（block），就是用花括号包围的语句序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块。\n\n\nfor语句\n\n\n每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：一个初始化语句（init-statement）、一个循环条件（condition）以及一个表达式（expression）。\n\n\n比如：\n\n\nfor (int val = 1; val \n= 10; ++val)\n    sum += val;\n\n\n\n\nfor循环的总体执行流程：\n\n\n0. 创建变量val，将其初始化为1，它仅在循环内部存在。\n\n\n0. 检测val是否小于等于10。如果检测成功，执行循环体。若失败，退出循环。\n\n\n0. 将val的值增加1。\n\n\n0. 重复第二个步骤。\n\n\n读取数量不定的输入数据\n\n\n使用这样的方法连续读入数据，直到遇到文件尾（Linux下，输入CTRL+D）：\n\n\nwhile (std::cin \n value)\n    statement\n\n\n\n\n输入运算符返回其左侧对象，因此，此循环条件检测的是std::cin。\n\n\n当使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时，istream对象的状态会变为无效。\n\n\nif语句\n\n\nif也对一个条件求值，书本里有一个完整的例子。\n\n\n语法大致如此：\n\n\nif (condition) {\n    statements\n} else {\n    statements\n}\n\n\n\n\n类简介\n\n\n在C++中，通过定义一个\n类\n（class）来定义自己的数据结构。一个类定义了一个类型，以及与其关联的一组操作。\n\n\n类似使用标准库设施，我们也需要使用头文件来自己的类。习惯上，头文件根据类名来命名，使用.h作为头文件的后缀。标准库的头文件通常不带后缀。\n\n\n初识成员函数\n\n\n什么是成员函数？\n\n\n有这样的检测条件：\n\n\nitem1.isbn() == item2.isbn()\n\n\n\n\n调用名为isbn的成员函数（member function）。成员函数是定义为类的一部分的函数。\n\n\n使用\n点运算符（.）\n来表达我们需要“名为item1的对象的isbn成员”。点运算符只能用于类类型的对象。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。\n\n\n我们使用\n调用运算符（()）\n来调用一个函数，它是一对圆括号，里面放实参列表（可能为空）。", 
            "title": "ch01 开始"
        }, 
        {
            "location": "/ch01 开始/#_1", 
            "text": "学习一门新的程序设计语言的最好方法就是练习编写程序。", 
            "title": "开始"
        }, 
        {
            "location": "/ch01 开始/#c", 
            "text": "每个C++程序都包含一个或多个函数（function），其中一个必须命名为 main 。操作系统通过调用main来运行C++程序。  下面是一个简单的main函数，它什么都不做，只是返回给操作系统一个值：  int main()\n{\n    return 0;\n}  main函数的返回类型必须为int。int类型是一种 内置类型 （built-in type），即语言自身定义的类型。  函数体是一个以左 花括号 （curly brace）开始，以右花括号结束的语句块（block of statements）。  return语句结束函数的执行。main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。  重要概念：类型  一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。程序所处理的数据都保存在变量中，而每个变量都拥有自己的类型。", 
            "title": "编写一个简单的C++程序"
        }, 
        {
            "location": "/ch01 开始/#_2", 
            "text": "编写好程序后，我们就需要编译它，这依赖于操作系统和编译器。  程序源文件命名约定  程序文件通常被称为源文件（source file）。它以一个后缀为结尾，告诉系统这个文件是一个C++程序，比如.cpp。", 
            "title": "编译、运行程序"
        }, 
        {
            "location": "/ch01 开始/#_3", 
            "text": "C++包含了一个全面的 标准库 （standard library）来提供IO机制（以及很多其他设施）。  iostream 库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。  标准输入输出对象  标准库定义了4个IO对象。为了处理输入，使用名为cin的istream类型的对象。这个对象被称为 标准输入 （standard input）。对于输出，使用名为cout的ostream类型的对象。这个对象被称为 标准输出 （standard output）。另外还有其他两个ostream对象，名为cerr和clog，cerr通常用来输出警告和错误消息，因此被称为 标准错误 （standard error）。clog用来输出程序运行时的一般性消息。  系统通常将程序所运行的窗口与这些对象关联起来。因此，当读取cin，数据将从程序正在运行的窗口读入，当向cout写入数据时，将会写到同一个窗口。   my note：clog关联到标准错误，默认情况下，写到clog的数据是被缓冲的。写到cerr的数据是不缓冲的。   一个使用IO库的程序  #include  iostream \nint main()\n{\n        std::cout    Enter two numbers:    std::endl;\n        int v1 = 0, v2 = 0;\n        std::cin   v1   v2;\n        std::cout    The sum of     v1     and     v2     is  \n                            v1 + v2   std::endl;\n        return 0;\n}  #include  iostream 告诉编译器我们想要使用iostream库。尖括号中的名字指出了一个 头文件 （header）。每个使用标准库设施的程序都必须包含相关的头文件。#include指令和头文件的名字必须写在同一行中。#include指令一般出现在所有函数之外，源文件的开始位置。  向流写入数据  std::cout    Enter two numbers    std::endl;  这条语句执行了一个 表达式 （expression）。在C++中，一个表达式产生一个计算结果，它由一个或多个运算对象和（通常是）一个运算符组成。这条语句中的表达式使用了 输出运算符 （ ）。  运算符接受两个运算对象：左侧必须是一个ostream对象；右侧是要打印的值。此运算符将给定的值写到给定的ostream对象中。计算结果是左侧的ostream对象。  \"Enter two numbers\"是一个 字符串字面值常量 （string literal），它是用一对双引号包围的字符序列。  endl是一个被称为 操纵符 （manipulator）的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。   my note: 一个表达式接一个分号就是一条语句。   使用标准库中的名字  前缀std::指出名字cout和endl是定义在名为 std 的 命名空间 （namespace）中的。  命名空间可以帮助我们避免不经意的名字定义冲突。标准库定义的所有名字都在命名空间std中。  从流读取数据  首先定义两个名为v1和v2的 变量 （variable）来保存输入：  int v1 = 0, v2 = 0;  这两个变量被定义为int类型，并 初始化 （initialize）为0。初始化一个变量，就是在变量创建的同时为它赋予一个值。  std::cin   v1   v2;  这条语句读入输入数据。 输入运算符 （ ）接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。输入运算符返回其左侧运算对象作为计算结果。", 
            "title": "初识输入输出"
        }, 
        {
            "location": "/ch01 开始/#_4", 
            "text": "注释（comments）通常用于概述算法，确定变量的用途，或者解释晦涩难懂的代码段。编译器会忽略掉注释，因此注释对程序的行为和性能不会有任何影响。  C++中注释的种类  C++中有两种注释：单行注释和界定符注释。  注释界定符不能嵌套  界定符对形式的注释是以 /* 开始，以 */ 结束的。因此，一个注释不能嵌套在另一个注释之内。  如果在调试期间要注释掉包含界定符对形式注释的代码，最好的方式是用单行注释方式注释掉代码段的每一行。  // /*\n//  * comments\n//  */", 
            "title": "注释简介"
        }, 
        {
            "location": "/ch01 开始/#_5", 
            "text": "语句一般是顺序执行的，语句块的第一条语句首先执行，然后是第二条，以此类推。但程序设计语言提供了多种不同的控制语句，允许我们写出更为复杂的执行路径。", 
            "title": "控制流"
        }, 
        {
            "location": "/ch01 开始/#while", 
            "text": "while语句反复执行一段代码，直到给定条件为假为止。  while语句的形式为：  while (condition)\n    statement  while语句的执行过程是交替地检测condition条件和执行关联的语句statement，直至condition为假时停止。所谓 条件 就是一个产生真或假的结果的表达式。  statement可以是语句块，也叫循环体。所谓语句块（block），就是用花括号包围的语句序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块。", 
            "title": "while语句"
        }, 
        {
            "location": "/ch01 开始/#for", 
            "text": "每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：一个初始化语句（init-statement）、一个循环条件（condition）以及一个表达式（expression）。  比如：  for (int val = 1; val  = 10; ++val)\n    sum += val;  for循环的总体执行流程：  0. 创建变量val，将其初始化为1，它仅在循环内部存在。  0. 检测val是否小于等于10。如果检测成功，执行循环体。若失败，退出循环。  0. 将val的值增加1。  0. 重复第二个步骤。", 
            "title": "for语句"
        }, 
        {
            "location": "/ch01 开始/#_6", 
            "text": "使用这样的方法连续读入数据，直到遇到文件尾（Linux下，输入CTRL+D）：  while (std::cin   value)\n    statement  输入运算符返回其左侧对象，因此，此循环条件检测的是std::cin。  当使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时，istream对象的状态会变为无效。", 
            "title": "读取数量不定的输入数据"
        }, 
        {
            "location": "/ch01 开始/#if", 
            "text": "if也对一个条件求值，书本里有一个完整的例子。  语法大致如此：  if (condition) {\n    statements\n} else {\n    statements\n}", 
            "title": "if语句"
        }, 
        {
            "location": "/ch01 开始/#_7", 
            "text": "在C++中，通过定义一个 类 （class）来定义自己的数据结构。一个类定义了一个类型，以及与其关联的一组操作。  类似使用标准库设施，我们也需要使用头文件来自己的类。习惯上，头文件根据类名来命名，使用.h作为头文件的后缀。标准库的头文件通常不带后缀。", 
            "title": "类简介"
        }, 
        {
            "location": "/ch01 开始/#_8", 
            "text": "什么是成员函数？  有这样的检测条件：  item1.isbn() == item2.isbn()  调用名为isbn的成员函数（member function）。成员函数是定义为类的一部分的函数。  使用 点运算符（.） 来表达我们需要“名为item1的对象的isbn成员”。点运算符只能用于类类型的对象。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。  我们使用 调用运算符（()） 来调用一个函数，它是一对圆括号，里面放实参列表（可能为空）。", 
            "title": "初识成员函数"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/", 
            "text": "变量和基本类型1\n\n\n\n\n基本内置类型\n\n\nC++定义了一套包括\n算术类型\n（arithmetic type）和\n空类型\n（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，如可作为函数的返回值。\n\n\n算术类型\n\n\n算术类型分为整型和浮点型。\n\n\n算术类型的尺寸（所占比特数）在不同机器上有所差别。C++标准规定了尺寸的最小值，编译器允许赋予这些类型更大的尺寸。某一类型所占的比特数不同，它所能表示的数据范围也不一样。\n\n\n算术类型尺寸表格见书本p30。\n\n\n布尔类型（bool）的取值是true或者false。\n\n\n浮点型可表示单精度、双精度和扩展精度值。一般来说，类型float和double分别有7和16个有效位，float以1个字（32比特）来表示，double以2个字（64比特）来表示。\n\n\n带符号类型和无符号类型\n\n\n除去布尔类型和扩展的字符型之外，其它整型可以划分为\n带符号的\n（signed）和\n无符号的\n（unsigned）两种。带符号类型可以表示正数、负数或0，无符号类型仅能表示大于等于0的值。\n\n\n与其他整型不同，字符型被分成了三种：char、signed char和unsigned char。类型char会表现为上述形式中的一种，具体是哪种由编译器决定。\n\n\n\n\nmy_note: 在GCC上测试，char是有符号的。\n\n\n\n\n选择类型的一些经验准则：\n\n\n- 当明确知晓数值不可能为负时，选用无符号类型。\n\n\n- 使用int执行整数运算，如果数值超过了int的表示范围，选用long long。\n\n\n- 在算术表达式中不要使用char或bool。因为char在不同机器上的表现方式不一样。\n\n\n- 执行浮点数运算选用double。因为double精度更高，且运算代价和float没有相差无几。\n\n\n类型转换\n\n\n对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型\n转换\n（convert）为另一种相关类型。\n\n\n当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。\n\n\n类型所能表示的值的范围决定了转换的过程：\n\n\n- 当把非bool的算术值赋给bool类型时，初始值为0则结果为false，否则结果为true。\n\n\n- 当把bool值赋给非bool类型时，初始值为false则结果为0，初始值为true则结果为1。\n\n\n- 当把一个浮点数赋给整数类型时，结果值将仅保留浮点数中小数点之前的部分。\n\n\n- 当把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度有可能损失。\n\n\n- 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。\n\n\n- 当我们赋给带符号类型一个超出它表示范围的值时，结果是\n未定义的\n（undefined）。此时，程序可能继续工作、可能崩溃、也可能生成垃圾数据。\n\n\n含有无符号类型的表达式\n\n\n提示：切勿混用带符号类型和无符号类型。如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。\n\n\n字面值常量\n\n\n一个形如42的值被称作字面值常量（literal），这样的值一望便知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。\n\n\n整型和浮点型字面值\n\n\n我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。例如，我们能用下面的任意一种形式来表示数值20：\n\n\n20 /* 十进制 */\n    \n024 /* 八进制 */\n    \n0x14 /* 十六进制 */\n\n\n十进制字面值的类型是int、long和long long中尺寸最小的那个。八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中尺寸最小者。\n\n\n浮点型字面值表现为一个小数或以科学计数法表示的指数，其指数部分用E或e标识：\n\n\n3.14159 3.14159E0    0.    0e0    .001\n\n\n默认的，浮点型字面值是一个double。\n\n\n\n\nmy note: GCC下，像20这样的十进制整数字面值，类型是int\n\n\n\n\n字符和字符串字面值\n\n\n由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串字面值。\n\n\n'a'    // 字符字面值\n\"a\"    // 字符串字面值\n\n\n字符串字面值的类型实际上是由常量字符构成的数组（array）。编译器在每个字符串的结尾处添加一个空字符（'\\0'），因此，字符串字面值的实际长度要比它的内容多1。\n\n\n转义序列\n\n\n有两类字符程序员不能直接使用：一类是\n不可打印\n（nonprintable）字符，如退格或其他控制字符；另一类是有特殊含义的字符，如引号、问号、反斜线。这些情况下需要用到\n转义序列\n（escape sequence），转义序列以反斜线作为开始。\n\n\n转义序列见书本p36。\n\n\n指定字面值的类型\n\n\n通过添加一些前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。\n\n\n这些前缀和后缀见书本p37。\n\n\n布尔字面值和指针字面值\n\n\ntrue和false是布尔类型的字面值。\n\n\n变量\n\n\n变量提供一个具名、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。\n\n\n变量定义\n\n\n变量定义的基本形式是：首先是\n类型说明符\n（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分割，最后以分号结束。列表中每个变量名的类型由类型说明符指定，定义时还可以为一个或多个变量赋初值：\n\n\nint sum = 0, value = 0;\n\n\n\n\n术语：何为对象？\n\n\n通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。\n\n\n初始值\n\n\n当对象在创建时获得了一个特定的值，我们说这个对象被\n初始化\n（initialized）了。\n\n\n【WARNING】：初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象当前值擦除，而以一个新值替代。\n\n\n列表初始化\n\n\n要想定义一个名为units_sold的int变量并初始化为0，以下4条语句都可以做到这一点：\n\n\nint units_sold = 0;\nint units_sold = {0};\nint units_sold(0);\nint units_sold{0};\n\n\n\n\n作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用。这种初始化的形式被称为\n列表初始化\n（list initialization）。\n\n\n当用于内置类型的变量时，这种初始化形式有一个重要特点，如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。\n\n\n\n\nmy note: 在我的GCC 4.8.5下面，这种情况会报warning。\n\n\n\n\n默认初始化\n\n\n如果定义变量时没有指定初值，则变量被\n默认初始化\n（default initialized）。\n\n\n如果是内置类型的变量未被显示初始化，它的值由定义的位置决定。定义于函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将\n不被初始化\n（uninitialized）。一个未被初始化的内置类型变量的值是未定义的。\n\n\n每个类各自决定其初始化对象的方式。\n\n\n【TIP】建议初始化每一个内置类型的变量。\n\n\n变量声明和定义的关系\n\n\n为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。\n\n\n为了支持分离式编译，C++语言将声明和定义区分开来。\n声明\n（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而\n定义\n负责创建与名字关联的实体。\n\n\n如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示初始化变量：\n\n\nextern int i;    // 声明i而非定义i\nint j;           // 声明并定义j\n\n\n\n\n任何包含了显式初始化的声明即成为定义。\n\n\n【NOTE】变量能且只能被定义一次，但是可以被多次声明。\n\n\n标识符\n\n\nC++的标识符（identifier）由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制，但是对大小写敏感。\n\n\nC++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。见书本p43。\n\n\n同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。\n\n\n名字的作用域\n\n\n不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、类型等。\n\n\n作用域\n（scope）是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分隔。\n\n\n同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。\n\n\n名字main定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有\n全局作用域\n（global scope）。一旦声明后，全局作用域内的名字在整个程序的范围内都可使用。\n\n\n\n\nmy note: 在花括号内定义的变量拥有块作用域。for语句内定义的名字，只能在for语句之内访问。\n\n\n\n\n嵌套的作用域\n\n\n作用域能彼此包含，被包含的作用域称为\n内层作用域\n（inner scope），包含着别的作用域的作用域称为\n外层作用域\n（outer scope）。\n\n\n作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字。\n\n\n复合类型\n\n\n复合类型（compound type）是指基于其他类型定义的类型。\n\n\n引用\n\n\n引用\n（reference）为对象起了另外一个名字。通过将声明符写成\nd的形式来定义引用类型，其中d是声明的变量名：\n\n\nint ival = 1024;\nint \nrefVal = ival;    // refVal指向ival（是ival的另一个名字）\n\n\n\n\n定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。\n\n\n【NOTE】引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。\n\n\n引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。\n\n\n指针\n\n\n指针\n（pointer）是“指向”另外一种类型的复合类型。指针本身就是一个对象，允许对指针赋值和拷贝。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。\n\n\n定义指针类型的方法将声明符写成*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量的前面都必须有符号*。\n\n\nint *p1, *p2;    // p1和p2都是指向int型对象的指针\n\n\n\n\n获取对象的地址\n\n\n指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符\n）：\n\n\nint ival = 42;\nint *p = \nival; // p存放变量ival的地址，或者说p是指向变量ival的指针\n\n\n\n\n因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。\n\n\n通常，所有指针的类型都要和它所指的对象严格匹配。\n\n\ndouble dval;\ndouble *pd = \ndval;    // 正确，初始值是double型对象的地址\n\nint *pi = pd;          // 错误，指针pi的类型和pd的类型不匹配\n\n\n\n\n指针值\n\n\n指针的值（即地址）应属下列4种状态之一：\n\n\n0. 指向一个对象。\n\n\n0. 指向紧邻对象所占用空间的下一个位置。\n\n\n0. 空指针，意味着指针没有指向任何对象。\n\n\n0. 无效指针，也就是上述情况之外的其他值。\n\n\n利用指针访问对象\n\n\n如果指针指向了一个对象，则允许使用\n解引用符\n（操作符*）来访问对象：\n\n\nint ival = 42;\nint *p = \nival;\ncout \n *p;    // 由符号*得到指针p所指的对象，输出42\n\n\n\n\n【NOTE】解引用操作仅适用于那些确实指向了某个对象的有效指针。\n\n\n空指针\n\n\n空指针\n（null pointer）不指向任何对象。以下列出几个生成空指针的方法：\n\n\nint *p1 = nullptr;    // 等价于 int *p1 = 0\nint *p2 = 0;\n// 需要首先#include \ncstdlib\n\nint *p3 = NULL;\n\n\n\n\nvoid*指针\n\n\nvoid*是一种特殊的指针类型，可用于存放任意对象的地址。\n\n\n利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void*所指的对象。\n\n\n理解复合类型的声明\n\n\n变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同：\n\n\n// i是一个int型的数，p是一个指向int型的指针，r是一个int型的引用\nint i = 1024, *p = \ni, \nr = i;\n\n\n\n\n【WARNING】很多程序员容易迷惑于基本数据类型和类型修饰符之间的关系，其实后者不过是声明符的一部分罢了。\n\n\n【TIP】面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。\n\n\nconst限定符\n\n\n有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字\nconst\n对变量的类型加以限定：\n\n\nconst int bufSize = 512;\n\n\n\n\n这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。\n\n\n因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。\n\n\n默认情况下，const对象仅在文件内有效\n\n\n当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：\n\n\nconst int bufSize = 512;\n\n\n\n\n编译器将在编译过程中把用到该变量的地方都替换成对应的值。\n\n\n为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。\n\n\n【NOTE】如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。\n\n\nconst的引用\n\n\n把引用绑定到const对象上，称之为对\n常量的引用\n（reference to const）。\n\n\nconst int a = 1024;\nconst int \nr = a;\n\n\n\n\n对常量的引用不能修改它所绑定的对象的值。\n\n\n初始化和对const的引用\n\n\n引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。\n\n\nint i = 42;\nconst int \nr1 = i;    // 允许将const int\n绑定到一个普通int对象上\nconst int \nr2 = 42;   // 正确：r1是一个常量引用\nconst int \nr3 = r1 * 2; // 正确：r3是一个常量引用\nint \nr4 = r1 * 2;     // 错误：r4是一个普通的非常量引用\n\n\n\n\n对const的引用可能引用一个并非const的对象\n\n\n必须认识到，常量引用仅对引用可参与的操作做出了限定，对引用的对象本身是不是一个常量未作限定。\n\n\n指针和const\n\n\n指向常量的指针\n（pointer to const）不能改变其所指对象的值。想要存放常量对象的地址，只能使用指向常量的指针：\n\n\nconst double pi = 3.14;\nconst double *p = \npi;\n\n\n\n\n指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：\n\n\ndouble dval = 3.14;\ncptr = \ndval;    // 正确，但是不能通过cptr改变dval的值\n\n\n\n\nconst指针\n\n\n指针是一个对象，可以把它定义成const的，叫\n常量指针\n（const pointer）。把*放在const关键字之前用以说明指针是一个常量：\n\n\nint n = 0;\nint *const p = \nn;\n\n\n\n\n顶层const\n\n\n顶层const（top-level const）表示指针本身是一个常量。\n\n\n底层const(low-level const)表示指针所指对象是一个常量。\n\n\n更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。\n\n\nint i = 0;\nint *const p1 = \ni;    // 不能改变p1的值，p1是一个顶层const\nconst int ci = 42；    // 不能改变ci的值，ci是一个顶层const\nconst int *p2 = \nci;   // 允许改变p2的值，p2是一个底层const\nconst int *const p3 = p2; // 靠右的const是顶层const，靠左的是底层const\nconst int \nr = ci;     // 用于声明引用的const都是底层const\n\n\n\n\nconstexpr和常量表达式\n\n\n常量表达式\n（const expression）是指值不会改变，且在编译过程中就能得到计算结果的表达式。\n\n\n这些都是常量表达式：\n\n\n- 字面值\n\n\n- 用常量表达式初始化的const对象\n\n\nconstexpr变量\n\n\n用const定义的变量并不一定是常量表达式，因此要换一种方法定义常量表达式。\n\n\nC++11标准提供了constexpr关键字，让编译器验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：\n\n\nconstexpr int mf = 20;    // 20是常量表达式\nconstexpr int limit = mf + 1;    // mf + 1是常量表达式\nconstexpr int sz = size();    // 只有当size是一个constexpr函数时，才是一条正确的声明语句\n\n\n\n\n字面值类型\n\n\n在编译时就能得到计算，类型比较简单，值也显而易见的类型，叫\n字面值类型\n（literal type）。\n\n\n算术类型，引用，指针都属于字面值类型。\n\n\n尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。\n\n\n指针和constexpr\n\n\n如果在constexpr声明中定义了一个指针，那么它只对指针有效，与指针所指的对象无关：\n\n\nconst int *p = nullptr;      // p是一个指向常量的指针\nconstexpr int *p2 = nullptr; // p2是一个常量指针\n\n\n\n\n与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：\n\n\nint j = 0;\nconstexpr int i = 42;\n// i和j都必须定义在函数体外\nconstexpr const int *p = \ni;    // p是常量指针，指向整型常量i\nconstexpr int *p1 = \nj;         // p1是常量指针，指向整数j", 
            "title": "变量和基本类型1"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#1", 
            "text": "", 
            "title": "变量和基本类型1"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_1", 
            "text": "C++定义了一套包括 算术类型 （arithmetic type）和 空类型 （void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，如可作为函数的返回值。", 
            "title": "基本内置类型"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_2", 
            "text": "算术类型分为整型和浮点型。  算术类型的尺寸（所占比特数）在不同机器上有所差别。C++标准规定了尺寸的最小值，编译器允许赋予这些类型更大的尺寸。某一类型所占的比特数不同，它所能表示的数据范围也不一样。  算术类型尺寸表格见书本p30。  布尔类型（bool）的取值是true或者false。  浮点型可表示单精度、双精度和扩展精度值。一般来说，类型float和double分别有7和16个有效位，float以1个字（32比特）来表示，double以2个字（64比特）来表示。  带符号类型和无符号类型  除去布尔类型和扩展的字符型之外，其它整型可以划分为 带符号的 （signed）和 无符号的 （unsigned）两种。带符号类型可以表示正数、负数或0，无符号类型仅能表示大于等于0的值。  与其他整型不同，字符型被分成了三种：char、signed char和unsigned char。类型char会表现为上述形式中的一种，具体是哪种由编译器决定。   my_note: 在GCC上测试，char是有符号的。   选择类型的一些经验准则：  - 当明确知晓数值不可能为负时，选用无符号类型。  - 使用int执行整数运算，如果数值超过了int的表示范围，选用long long。  - 在算术表达式中不要使用char或bool。因为char在不同机器上的表现方式不一样。  - 执行浮点数运算选用double。因为double精度更高，且运算代价和float没有相差无几。", 
            "title": "算术类型"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_3", 
            "text": "对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型 转换 （convert）为另一种相关类型。  当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。  类型所能表示的值的范围决定了转换的过程：  - 当把非bool的算术值赋给bool类型时，初始值为0则结果为false，否则结果为true。  - 当把bool值赋给非bool类型时，初始值为false则结果为0，初始值为true则结果为1。  - 当把一个浮点数赋给整数类型时，结果值将仅保留浮点数中小数点之前的部分。  - 当把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度有可能损失。  - 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。  - 当我们赋给带符号类型一个超出它表示范围的值时，结果是 未定义的 （undefined）。此时，程序可能继续工作、可能崩溃、也可能生成垃圾数据。  含有无符号类型的表达式  提示：切勿混用带符号类型和无符号类型。如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。", 
            "title": "类型转换"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_4", 
            "text": "一个形如42的值被称作字面值常量（literal），这样的值一望便知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。  整型和浮点型字面值  我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。例如，我们能用下面的任意一种形式来表示数值20：  20 /* 十进制 */      024 /* 八进制 */      0x14 /* 十六进制 */  十进制字面值的类型是int、long和long long中尺寸最小的那个。八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中尺寸最小者。  浮点型字面值表现为一个小数或以科学计数法表示的指数，其指数部分用E或e标识：  3.14159 3.14159E0    0.    0e0    .001  默认的，浮点型字面值是一个double。   my note: GCC下，像20这样的十进制整数字面值，类型是int   字符和字符串字面值  由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串字面值。  'a'    // 字符字面值\n\"a\"    // 字符串字面值  字符串字面值的类型实际上是由常量字符构成的数组（array）。编译器在每个字符串的结尾处添加一个空字符（'\\0'），因此，字符串字面值的实际长度要比它的内容多1。  转义序列  有两类字符程序员不能直接使用：一类是 不可打印 （nonprintable）字符，如退格或其他控制字符；另一类是有特殊含义的字符，如引号、问号、反斜线。这些情况下需要用到 转义序列 （escape sequence），转义序列以反斜线作为开始。  转义序列见书本p36。  指定字面值的类型  通过添加一些前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。  这些前缀和后缀见书本p37。  布尔字面值和指针字面值  true和false是布尔类型的字面值。", 
            "title": "字面值常量"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_5", 
            "text": "变量提供一个具名、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。", 
            "title": "变量"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_6", 
            "text": "变量定义的基本形式是：首先是 类型说明符 （type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分割，最后以分号结束。列表中每个变量名的类型由类型说明符指定，定义时还可以为一个或多个变量赋初值：  int sum = 0, value = 0;  术语：何为对象？  通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。  初始值  当对象在创建时获得了一个特定的值，我们说这个对象被 初始化 （initialized）了。  【WARNING】：初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象当前值擦除，而以一个新值替代。  列表初始化  要想定义一个名为units_sold的int变量并初始化为0，以下4条语句都可以做到这一点：  int units_sold = 0;\nint units_sold = {0};\nint units_sold(0);\nint units_sold{0};  作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用。这种初始化的形式被称为 列表初始化 （list initialization）。  当用于内置类型的变量时，这种初始化形式有一个重要特点，如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。   my note: 在我的GCC 4.8.5下面，这种情况会报warning。   默认初始化  如果定义变量时没有指定初值，则变量被 默认初始化 （default initialized）。  如果是内置类型的变量未被显示初始化，它的值由定义的位置决定。定义于函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将 不被初始化 （uninitialized）。一个未被初始化的内置类型变量的值是未定义的。  每个类各自决定其初始化对象的方式。  【TIP】建议初始化每一个内置类型的变量。", 
            "title": "变量定义"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_7", 
            "text": "为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。  为了支持分离式编译，C++语言将声明和定义区分开来。 声明 （declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而 定义 负责创建与名字关联的实体。  如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示初始化变量：  extern int i;    // 声明i而非定义i\nint j;           // 声明并定义j  任何包含了显式初始化的声明即成为定义。  【NOTE】变量能且只能被定义一次，但是可以被多次声明。", 
            "title": "变量声明和定义的关系"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_8", 
            "text": "C++的标识符（identifier）由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制，但是对大小写敏感。  C++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。见书本p43。  同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。", 
            "title": "标识符"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_9", 
            "text": "不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、类型等。  作用域 （scope）是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分隔。  同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。  名字main定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有 全局作用域 （global scope）。一旦声明后，全局作用域内的名字在整个程序的范围内都可使用。   my note: 在花括号内定义的变量拥有块作用域。for语句内定义的名字，只能在for语句之内访问。   嵌套的作用域  作用域能彼此包含，被包含的作用域称为 内层作用域 （inner scope），包含着别的作用域的作用域称为 外层作用域 （outer scope）。  作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字。", 
            "title": "名字的作用域"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_10", 
            "text": "复合类型（compound type）是指基于其他类型定义的类型。", 
            "title": "复合类型"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_11", 
            "text": "引用 （reference）为对象起了另外一个名字。通过将声明符写成 d的形式来定义引用类型，其中d是声明的变量名：  int ival = 1024;\nint  refVal = ival;    // refVal指向ival（是ival的另一个名字）  定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。  【NOTE】引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。  引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。", 
            "title": "引用"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_12", 
            "text": "指针 （pointer）是“指向”另外一种类型的复合类型。指针本身就是一个对象，允许对指针赋值和拷贝。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。  定义指针类型的方法将声明符写成*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量的前面都必须有符号*。  int *p1, *p2;    // p1和p2都是指向int型对象的指针  获取对象的地址  指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符 ）：  int ival = 42;\nint *p =  ival; // p存放变量ival的地址，或者说p是指向变量ival的指针  因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。  通常，所有指针的类型都要和它所指的对象严格匹配。  double dval;\ndouble *pd =  dval;    // 正确，初始值是double型对象的地址\n\nint *pi = pd;          // 错误，指针pi的类型和pd的类型不匹配  指针值  指针的值（即地址）应属下列4种状态之一：  0. 指向一个对象。  0. 指向紧邻对象所占用空间的下一个位置。  0. 空指针，意味着指针没有指向任何对象。  0. 无效指针，也就是上述情况之外的其他值。  利用指针访问对象  如果指针指向了一个对象，则允许使用 解引用符 （操作符*）来访问对象：  int ival = 42;\nint *p =  ival;\ncout   *p;    // 由符号*得到指针p所指的对象，输出42  【NOTE】解引用操作仅适用于那些确实指向了某个对象的有效指针。  空指针  空指针 （null pointer）不指向任何对象。以下列出几个生成空指针的方法：  int *p1 = nullptr;    // 等价于 int *p1 = 0\nint *p2 = 0;\n// 需要首先#include  cstdlib \nint *p3 = NULL;  void*指针  void*是一种特殊的指针类型，可用于存放任意对象的地址。  利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void*所指的对象。", 
            "title": "指针"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#_13", 
            "text": "变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同：  // i是一个int型的数，p是一个指向int型的指针，r是一个int型的引用\nint i = 1024, *p =  i,  r = i;  【WARNING】很多程序员容易迷惑于基本数据类型和类型修饰符之间的关系，其实后者不过是声明符的一部分罢了。  【TIP】面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。", 
            "title": "理解复合类型的声明"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#const", 
            "text": "有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字 const 对变量的类型加以限定：  const int bufSize = 512;  这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。  因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。  默认情况下，const对象仅在文件内有效  当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：  const int bufSize = 512;  编译器将在编译过程中把用到该变量的地方都替换成对应的值。  为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。  【NOTE】如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。", 
            "title": "const限定符"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#const_1", 
            "text": "把引用绑定到const对象上，称之为对 常量的引用 （reference to const）。  const int a = 1024;\nconst int  r = a;  对常量的引用不能修改它所绑定的对象的值。  初始化和对const的引用  引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。  int i = 42;\nconst int  r1 = i;    // 允许将const int 绑定到一个普通int对象上\nconst int  r2 = 42;   // 正确：r1是一个常量引用\nconst int  r3 = r1 * 2; // 正确：r3是一个常量引用\nint  r4 = r1 * 2;     // 错误：r4是一个普通的非常量引用  对const的引用可能引用一个并非const的对象  必须认识到，常量引用仅对引用可参与的操作做出了限定，对引用的对象本身是不是一个常量未作限定。", 
            "title": "const的引用"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#const_2", 
            "text": "指向常量的指针 （pointer to const）不能改变其所指对象的值。想要存放常量对象的地址，只能使用指向常量的指针：  const double pi = 3.14;\nconst double *p =  pi;  指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：  double dval = 3.14;\ncptr =  dval;    // 正确，但是不能通过cptr改变dval的值  const指针  指针是一个对象，可以把它定义成const的，叫 常量指针 （const pointer）。把*放在const关键字之前用以说明指针是一个常量：  int n = 0;\nint *const p =  n;", 
            "title": "指针和const"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#const_3", 
            "text": "顶层const（top-level const）表示指针本身是一个常量。  底层const(low-level const)表示指针所指对象是一个常量。  更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。  int i = 0;\nint *const p1 =  i;    // 不能改变p1的值，p1是一个顶层const\nconst int ci = 42；    // 不能改变ci的值，ci是一个顶层const\nconst int *p2 =  ci;   // 允许改变p2的值，p2是一个底层const\nconst int *const p3 = p2; // 靠右的const是顶层const，靠左的是底层const\nconst int  r = ci;     // 用于声明引用的const都是底层const", 
            "title": "顶层const"
        }, 
        {
            "location": "/ch02 变量和基本类型_1/#constexpr", 
            "text": "常量表达式 （const expression）是指值不会改变，且在编译过程中就能得到计算结果的表达式。  这些都是常量表达式：  - 字面值  - 用常量表达式初始化的const对象  constexpr变量  用const定义的变量并不一定是常量表达式，因此要换一种方法定义常量表达式。  C++11标准提供了constexpr关键字，让编译器验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：  constexpr int mf = 20;    // 20是常量表达式\nconstexpr int limit = mf + 1;    // mf + 1是常量表达式\nconstexpr int sz = size();    // 只有当size是一个constexpr函数时，才是一条正确的声明语句  字面值类型  在编译时就能得到计算，类型比较简单，值也显而易见的类型，叫 字面值类型 （literal type）。  算术类型，引用，指针都属于字面值类型。  尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。  指针和constexpr  如果在constexpr声明中定义了一个指针，那么它只对指针有效，与指针所指的对象无关：  const int *p = nullptr;      // p是一个指向常量的指针\nconstexpr int *p2 = nullptr; // p2是一个常量指针  与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：  int j = 0;\nconstexpr int i = 42;\n// i和j都必须定义在函数体外\nconstexpr const int *p =  i;    // p是常量指针，指向整型常量i\nconstexpr int *p1 =  j;         // p1是常量指针，指向整数j", 
            "title": "constexpr和常量表达式"
        }, 
        {
            "location": "/ch02 变量和基本类型_2/", 
            "text": "变量和基本类型2\n\n\n\n\n处理类型\n\n\n随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂性体现在两个方面。一是一些类难于“拼写”。二是有时候根本搞不清到底需要什么类型，需要从程序的上下文中寻求帮助。\n\n\n类型别名\n\n\n类型别名\n（type alias）是一个名字，它是某种类型的同义词。使用类型别名可以让复杂的名字变得简单，有助于程序员清楚地知道使用该类型的真实目的。\n\n\n传统的定义类型别名的方法是使用typedef:\n\n\ntypedef double wages;    // wages是double的同义词\n\n\n\n\n新标准规定了一种新的方法，使用\n别名声明\n（alias declaration）来定义类型的别名：\n\n\nusing SI = Sales_item;    // SI是Sales_item的别名\n\n\n\n\n这种方法使用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。\n\n\nauto类型说明符\n\n\nC++11新标准引入了auto类型说明符，用它让编译器替我们去分析表达式所属的类型。\n\n\n显然，auto定义的变量必须有初始值：\n\n\n// 由val1和val2相加的结果可以推断出item的类型\nauto item = val1 + val2;\n\n\n\n\n使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：\n\n\nauto i = 0, *p = \ni; // 正确，i是整数，p是整型指针\nauto sz = 0, pi = 3.14; // 错误，sz和pi的类型不一致\n\n\n\n\n复合类型、常量和auto\n\n\n编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。\n\n\n首先，当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：\n\n\nint i = 0, \nr = i;\nauto a = r; // a是一个int\n\n\n\n\n其次，auto一般会忽略掉顶层const，同时底层const则会保留下来：\n\n\nconst int ci = i, \ncr = ci;\nauto b = ci; // b是一个int，ci的顶层const被忽略\nauto c = cr; // c是一个int，cr是ci的别名，其顶层const被忽略\nauto d = \ni; // d是一个int*\nauto e = \nci; // e是一个const int*，对常量对象取地址是一种底层const\n\n\n\n\n如果希望推断出来的auto类型是一个顶层const，需要明确指出:\n\n\nconst auto f = ci; // ci推演成int，f是const int\n\n\n\n\n还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：\n\n\nauto \nq = ci; // q是一个整型常量引用，绑定到ci\nauto \nh = 42; // 错误：不能为非常量引用绑定到字面值\nconst auto \nj = 42; // 正确，可以为常量引用绑定字面值\n\n\n\n\ndecltype类型指示符\n\n\nC++新标准引入了第二种类型说明符\ndecltype\n，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：\n\n\ndecltype(f()) sum = x; // sum的类型就是函数f的返回类型\n\n\n\n\n编译器并不实际调用f，而是使用当调用发生时f的返回值的类型作为sum的类型。\n\n\n如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：\n\n\nconst int ci = 0, \ncj = ci;\ndecltype(ci) x = 0; // x的类型是const int\ndecltype(cj) y = x; // y的类型是const int\n, y绑定到x\n\n\n\n\ndecltype和引用\n\n\n如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如果表达式向decltype返回一个引用类型，一般来说，意味着该表达式的结果对象能作为一条赋值语句的左值：\n\n\n// decltype的结果可以是引用类型\nint i = 42, *p = \ni, \nr = i;\ndecltype(r + 0) b; // 正确，加法的结果是int，因此b是一个int\ndecltype(*p) c; // 错误，c是int\n，必须初始化\n\n\n\n\n如果表达式的内容是解引用操作，则decltype将得到引用类型。\n\n\n有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，编译器就会把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：\n\n\n// decltype的表达式如果是加上了括号的变量，结果是引用\ndecltype((i)) d; // 错误，d是int\n，必须初始化\ndecltype(i) e; // 正确，e是一个int。\n\n\n\n\n【WARNING】切记，decltype((variable))的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。\n\n\n自定义数据结构\n\n\n从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。\n\n\nC++语言允许用户以类的形式自定义数据类型，而库类型string、istream、ostream等也都是以类的形式定义的，就像第1章的Sales_item类型一样。\n\n\n定义Sales_data类型\n\n\nSales_data初步定义如下：\n\n\nstruct Sales_data {\n    std::string bookNo;\n    unsigned units_sold = 0;\n    double revenue = 0.0;\n};\n\n\n\n\n我们的类以关键字struct开始，紧跟着类名和类体（其中类体部分可为空）。类体由花括号包围形成了一个新的作用域。\n\n\n类体右侧的表示结束的花括号后必须写一个分号。\n\n\n类数据成员\n\n\n类体定义类的成员，我们的类只有数据成员（data member）。类的数据成员定义了类的对象的具体内容，每个对象都有自己的一份数据成员拷贝。\n\n\nC++11新标准规定，可以为数据成员提供一个\n类内初始值\n（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。\n\n\n编写自己的头文件\n\n\n为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。\n\n\n头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。\n\n\n预处理器概述\n\n\n确保头文件多次包含仍能安全工作的常用技术是\n预处理器\n（preprocessor）。\n\n\nC++程序使用\n头文件保护符\n（header guard）来避免头文件重复包含。\n\n\n#ifndef SALES_DATA_H\n#define SALES_DATA_H\n\nstruct Sales_data {\n    std::string bookNo;\n    unsigned units_sold = 0;\n    double revenue = 0.0;\n};\n\n#endif", 
            "title": "变量和基本类型2"
        }, 
        {
            "location": "/ch02 变量和基本类型_2/#2", 
            "text": "", 
            "title": "变量和基本类型2"
        }, 
        {
            "location": "/ch02 变量和基本类型_2/#_1", 
            "text": "随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂性体现在两个方面。一是一些类难于“拼写”。二是有时候根本搞不清到底需要什么类型，需要从程序的上下文中寻求帮助。", 
            "title": "处理类型"
        }, 
        {
            "location": "/ch02 变量和基本类型_2/#_2", 
            "text": "类型别名 （type alias）是一个名字，它是某种类型的同义词。使用类型别名可以让复杂的名字变得简单，有助于程序员清楚地知道使用该类型的真实目的。  传统的定义类型别名的方法是使用typedef:  typedef double wages;    // wages是double的同义词  新标准规定了一种新的方法，使用 别名声明 （alias declaration）来定义类型的别名：  using SI = Sales_item;    // SI是Sales_item的别名  这种方法使用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。", 
            "title": "类型别名"
        }, 
        {
            "location": "/ch02 变量和基本类型_2/#auto", 
            "text": "C++11新标准引入了auto类型说明符，用它让编译器替我们去分析表达式所属的类型。  显然，auto定义的变量必须有初始值：  // 由val1和val2相加的结果可以推断出item的类型\nauto item = val1 + val2;  使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：  auto i = 0, *p =  i; // 正确，i是整数，p是整型指针\nauto sz = 0, pi = 3.14; // 错误，sz和pi的类型不一致  复合类型、常量和auto  编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。  首先，当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：  int i = 0,  r = i;\nauto a = r; // a是一个int  其次，auto一般会忽略掉顶层const，同时底层const则会保留下来：  const int ci = i,  cr = ci;\nauto b = ci; // b是一个int，ci的顶层const被忽略\nauto c = cr; // c是一个int，cr是ci的别名，其顶层const被忽略\nauto d =  i; // d是一个int*\nauto e =  ci; // e是一个const int*，对常量对象取地址是一种底层const  如果希望推断出来的auto类型是一个顶层const，需要明确指出:  const auto f = ci; // ci推演成int，f是const int  还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：  auto  q = ci; // q是一个整型常量引用，绑定到ci\nauto  h = 42; // 错误：不能为非常量引用绑定到字面值\nconst auto  j = 42; // 正确，可以为常量引用绑定字面值", 
            "title": "auto类型说明符"
        }, 
        {
            "location": "/ch02 变量和基本类型_2/#decltype", 
            "text": "C++新标准引入了第二种类型说明符 decltype ，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：  decltype(f()) sum = x; // sum的类型就是函数f的返回类型  编译器并不实际调用f，而是使用当调用发生时f的返回值的类型作为sum的类型。  如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：  const int ci = 0,  cj = ci;\ndecltype(ci) x = 0; // x的类型是const int\ndecltype(cj) y = x; // y的类型是const int , y绑定到x  decltype和引用  如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如果表达式向decltype返回一个引用类型，一般来说，意味着该表达式的结果对象能作为一条赋值语句的左值：  // decltype的结果可以是引用类型\nint i = 42, *p =  i,  r = i;\ndecltype(r + 0) b; // 正确，加法的结果是int，因此b是一个int\ndecltype(*p) c; // 错误，c是int ，必须初始化  如果表达式的内容是解引用操作，则decltype将得到引用类型。  有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，编译器就会把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：  // decltype的表达式如果是加上了括号的变量，结果是引用\ndecltype((i)) d; // 错误，d是int ，必须初始化\ndecltype(i) e; // 正确，e是一个int。  【WARNING】切记，decltype((variable))的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。", 
            "title": "decltype类型指示符"
        }, 
        {
            "location": "/ch02 变量和基本类型_2/#_3", 
            "text": "从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。  C++语言允许用户以类的形式自定义数据类型，而库类型string、istream、ostream等也都是以类的形式定义的，就像第1章的Sales_item类型一样。", 
            "title": "自定义数据结构"
        }, 
        {
            "location": "/ch02 变量和基本类型_2/#sales_data", 
            "text": "Sales_data初步定义如下：  struct Sales_data {\n    std::string bookNo;\n    unsigned units_sold = 0;\n    double revenue = 0.0;\n};  我们的类以关键字struct开始，紧跟着类名和类体（其中类体部分可为空）。类体由花括号包围形成了一个新的作用域。  类体右侧的表示结束的花括号后必须写一个分号。  类数据成员  类体定义类的成员，我们的类只有数据成员（data member）。类的数据成员定义了类的对象的具体内容，每个对象都有自己的一份数据成员拷贝。  C++11新标准规定，可以为数据成员提供一个 类内初始值 （in-class initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。", 
            "title": "定义Sales_data类型"
        }, 
        {
            "location": "/ch02 变量和基本类型_2/#_4", 
            "text": "为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。  头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。  预处理器概述  确保头文件多次包含仍能安全工作的常用技术是 预处理器 （preprocessor）。  C++程序使用 头文件保护符 （header guard）来避免头文件重复包含。  #ifndef SALES_DATA_H\n#define SALES_DATA_H\n\nstruct Sales_data {\n    std::string bookNo;\n    unsigned units_sold = 0;\n    double revenue = 0.0;\n};\n\n#endif", 
            "title": "编写自己的头文件"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/", 
            "text": "字符串、向量和数组\n\n\n\n\n命名空间的using声明\n\n\n有如下形式：\n\n\nusing namespace::name;\n\n\n\n\n使用完using声明（using declaration）后，就可以省略掉名字前的前缀了（如std::）。\n\n\n#include \niostream\n\n\nusing std::cin;\n\nint main()\n{\n    int i;\n    cin \n i;\n    cout \n i;    // 错误，没有对应的using声明，必须使用完整的名字\n    return 0;\n}\n\n\n\n\n头文件不应包含using声明\n\n\n这是因为头文件会被其它文件引用，从而使其它文件也使用了using声明，有可能造成命名冲突。\n\n\n标准库类型string\n\n\nstring表示可变长的字符序列。使用string类型需要包含string头文件。\n\n\n定义和初始化string对象\n\n\n如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别。\n\n\n初始化string对象的方式：\n\n\nstring s1;           // 默认初始化，s1是一个空串\nstring s2(s1);       // s2是s1的副本\nstring s2 = s1;      // 等价于s2(s1)\nstring s3(\nvalue\n);  // s3是字面值\nvalue\n的副本，不包括最后的空字符\nstring s3 = \nvalue\n; // 等价于s3(\nvalue\n)\nstring s4(n, 'c');   // 初始化为由n个字符c组成的串\n\n\n\n\n直接初始化和拷贝初始化\n\n\n如果使用等号（=）初始化一个变量，实际上执行的是\n拷贝初始化（copy initialization）\n，编译器把等号右侧的对象初始值拷贝到新创建的对象中去。如果不适用等号，则执行的是\n直接初始化\n（direct initialization）。\n\n\nstring s5 = \nhiya\n;  // 拷贝初始化\nstring s6(\nhiya\n);   // 直接初始化\nstring s7(10, 'c');  // 直接初始化\n\n\n\n\nstring对象上的操作\n\n\n如：\n\n\n- \nos \n s\n, 将s写入输出流os当中，返回os\n\n\n- \nis \n s\n，从输入流中读取字符串赋值给s，字符串以空白分隔，返回is\n\n\n- \ngetline(is, s)\n，从输入流中读取一行赋值给s，返回is\n\n\n- \ns.empty()\n，如果s为空，返回true\n\n\n- \ns.size()\n，返回s中的字符数，与s.length()等价\n\n\n- \ns[n]\n，返回s中第n个字符的引用\n\n\n- \ns1 + s2\n，返回s1和s2连接后的结果\n\n\n- \ns1 = s2\n，用s2的副本代替s1\n\n\n- \ns1 == s2\n，\ns1 != s2\n，如果s1和s2完全一样，则相等\n\n\n- \n, \n=, \n, \n=，顺序比较字符大小，完全一致再比较长度\n\n\ngetline函数会读取换行符，但不会把它存入字符串中。getline返回输入流。\n\n\nstring::size_type类型\n\n\nsize函数返回的是一个string::size_type类型的值。这是一个无符号的整数。\n\n\nstring类和大多数标准库类型都定义了几种配套类型，它们体现的是标准库与机器无关的特性。\n\n\n字面值和string对象相加\n\n\n标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。\n\n\nstring s1 = s1 + \nhi\n;\nstring s2 = s1 + ',';\n\n\n\n\n处理string对象中的字符\n\n\n字符处理函数的头文件是cctype，它和C的ctype.c一样，只不过前者是C++的命名规范。在书本p82有cctype头文件中的函数说明。\n\n\n处理每个字符？使用基于范围的for语句\n\n\n如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：\n范围for\n（range for）语句。这种语句遍历序列中的每个元素并对序列中的每个值执行某种操作，其语法格式是：\n\n\nfor (declaration : expression)\n    statement\n\n\n\n\n其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。\n\n\n如：\n\n\nfor (auto c : str)\n    // do something\n\n\n\n\n这里c是str中字符的副本，若要改变str中的字符，需要用引用：\n\n\nfor (auto \nc : str)\n    // do something\n\n\n\n\n使用下标运算符\n\n\n[ ]\n符号叫做下标运算符，范围是[0, s.size())，越界的结果是UB（undefined behavior，未定义行为）。\n\n\n标准库类型vector\n\n\nvector是对象的集合，也叫容器（container）。集合中的每个对象都有一个索引，索引用于访问对象。\n\n\nvector是一个类模板。模板是为编译器提供的一份生成类或函数的说明。\n\n\nvector是模板而非类型，由vector生成的类型必须包含元素的类型，如：\n\n\nvector\nint\n v;\n\n\n\n\nvector中存放的是对象，而引用不是对象，故不能存储引用。\n\n\n定义和初始化vector对象\n\n\nvector模板控制着初始化向量的方法。\n\n\n定义vector对象的方法有：\n\n\n- \nvector\nT\n v1\n，默认初始化，v1是一个空的vector\n\n\n- \nvector\nT\n v2(v1)\n，v2中包含v1所有元素的副本\n\n\n- \nvector\nT\n v2 = v1\n，等价于v2(v1)\n\n\n- \nvector\nT\n v3(n, val)\n，v3包含了n个重复的元素，每个元素的值都是val\n\n\n- \nvector\nT\n v4(n)\n，v4包含了n个执行了值初始化的对象\n\n\n- \nvector\nT\n v5{a,b,c...}\n，v5里包含了用a,b,c...初始化的元素\n\n\n- \nvector\nT\n v5 = {a,b,c...}\n，等价于\nvector\nT\n v5{a,b,c...}\n\n\n值初始化\n\n\n值初始化（value initialize），是指如果是内置类型，则初始值为0；如果是类类型，执行类默认初始化。\n\n\nvector\nT\n(n)\n中，所有元素将执行值初始化。\n\n\n向vector中添加元素\n\n\npush_back函数把一个元素压入vector对象的尾端。\n\n\nvector的对象能高效地增长，因此更常见的情况是：创建一个空vector，然后在运行时再利用vector的成员函数push_back向其中添加元素。\n\n\n一定不能在遍历vector的时候改变vector对象的大小。\n\n\n【关键概念：vector对象能高效增长】\n\n\nC++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小就没有什么必要了，只有一种例外，即当所有元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。\n\n\n其它vector操作\n\n\n如（很多和string类似）：\n\n\n- \nv.empty()\n，如果v不含有任何元素，返回true\n\n\n- \nv.size()\n，返回v中的元素个数\n\n\n- \nv[n]\n，返回v中第n个位置上元素的引用\n\n\n- \nv1 = v2\n，v2中的元素将拷贝替换v1的\n\n\n- \nv1 = {a,b,c...}\n，列表中的元素将拷贝替换v1中的\n\n\n- \nv1 == v2\n, \nv1 != v2\n，元素数量相同，对应位置的元素也相等，则相等\n\n\n- \n,\n=,\n,\n=，比首个相异元素的大小，如都一样，比长度，即字典顺序\n\n\nsize返回的类型由vector定义的size_type类型。\n\n\nvector\nint\n::size_type    // 正确\nvector::size_type         // 错误\n\n\n\n\n只有当元素的值可比较时，vector对象才能被比较。\n\n\n只能对确已存在的元素执行下标操作。\n\n\n迭代器介绍\n\n\n使用迭代器（iterator）是一种通用的访问容器中元素的方法。\n\n\n迭代器有有效和无效之分。有效的迭代器指向某个元素，或指向尾元素的下一个位置，其它情况都属于无效。\n\n\n使用迭代器\n\n\n有迭代器的类型同时拥有返回迭代器的成员。\n\n\n标准库容器都拥有名为begin和end的成员（函数）。其中begin成员负责返回指向第一个元素的迭代器。\n\n\nend成员负责返回指向容器“尾元素的下一个位置”的迭代器。叫\n尾后迭代器（off-the-end iterator）\n。\n\n\n如果容器为空，begin和end都返回尾后迭代器。即：\nv.begin() == v.end()\n\n\n如：\n\n\nauto b = v.begin();\nauto e = v.end();\n\n\n\n\n迭代器运算符\n\n\n标准容器迭代器的运算符：\n\n\n- \n*iter\n，返回迭代器所指对象的引用（解引用）\n\n\n- \niter-\nmem\n，解引用iter，并获取其成员mem，等价于\n(*iter).mem\n\n\n- \n++iter\n，令iter指示容器中的下一个元素\n\n\n- \n--iter\n，令iter指示容器中的上一个元素\n\n\n- \niter1 == iter2\n，如果两个迭代器指示的是同一个元素，或者它们都是尾后迭代器，则相等，反之不相等\n\n\n迭代器指示一个元素时，才可对其解引用。对尾后迭代器或者无效迭代器解引用的结果是UB。\n\n\n迭代器类型\n\n\n标准库类型使用iterator和const_iterator来表示迭代器类型。\n\n\n如：\n\n\nvector\nint\n::iterator it1;\nvector\nint\n::const_iterator it2;\n\n\n\n\nit1能读写元素，而it2只能读。\n\n\n认定某个类型是迭代器类型当且仅当它支持一套操作，这套操作使得我们能访问容器的元素，或者从某个元素移动到另外一个元素。\n\n\nbegin和end运算符\n\n\nbegin和end返回的具体类型由对象是否是常量决定。如果对象是常量，返回const_iterator，否则返回iterator。\n\n\n为了专门得到const_iterator类型的迭代器，C++11中可以使用cbegin和cend：\n\n\nauto it = v.cbegin();\n\n\n\n\n箭头运算符\n\n\n即\n-\n，它把解引用和成员访问两个操作结合在一起。即：\n\n\n(*iter).mem\n等价于\niter-\nmem\n。\n\n\n某些对vector对象的操作会使迭代器失效\n\n\n任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。\n\n\n迭代器运算\n\n\n递增运算令迭代器每次移动一个元素，所有的标准库容器的迭代器都支持递增运算，也支持==和!=运算。\n\n\nstring和vector的迭代器提供了额外的运算符，有：\n\n\n- \niter + n\n，新迭代器向前移动若干个元素，它指向容器的一个元素，或是尾后迭代器\n\n\n- \niter - n\n，新迭代器向后移动若干个元素，它指向容器的一个元素，或是尾后迭代器\n\n\n- \niter1 - iter2\n，得到迭代器之间的距离，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置\n\n\n- \n,\n=,\n,\n=\n，比较迭代器所处的位置，前面的小于后面的，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置  \n\n\n迭代器的算数运算\n\n\n迭代器相减的结果的类型是difference_type，表示右侧的迭代器要移动多少个位置才能到达左侧的。\n\n\ndifference_type是一个带符号的整数，string和vector都定义了这个类型。\n\n\n数组\n\n\n数组是存放相同类型的对象的容器，这些对象是匿名的。\n\n\n数组的大小确定不变。\n\n\n数组是一种内置类型。\n\n\n定义和初始化内置数组\n\n\n数组是一种复合类型，其声明形如\na[N]\n。N叫维度，说明了数组中元素的个数，必须大于0，且必须是一个常量表达式，即其值在编译期间已知。\n\n\n默认情况下，数组的元素执行默认初始化，这意味着在函数块内定义的执行默认初始化的含内置类型元素的数组，其元素的值未定义。\n\n\n定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。数组的元素应为对象，所以不存在存储引用的数组。\n\n\n显式初始化数组元素\n\n\n即列表初始化，此时可以忽略数组的维度，维度由编译器推断出来。\n\n\n如：\n\n\nint a1[10] = {0}; // 剩下的元素执行值初始化，即为0\nint a2[] = {1, 2, 3};\n\n\n\n\n字符数组的特殊性\n\n\n可以用字符串字面值对此类数组进行初始化。如：\n\n\nchar s[] = \nhello\n;\n\n\n\n\n这样初始化的数组包含结尾的空字符。\n\n\n不允许拷贝和赋值\n\n\n这样的操作是非法的：\n\n\nint a1[] = {1, 2, 3};\nint a2[] = a1; // 非法\n\n\n\n\n理解复杂的数组声明\n\n\n定义一个指针数组：\n\n\nint* a[10] = {};\n\n\n\n\n定义一个指向数组的指针：\n\n\nint (*ptr)[10] = \na;\n\n\n\n\n定义一个绑定到数组的引用：\n\n\nint (\na_ref)[10] = a;\n\n\n\n\n默认情况下，类型修饰符从右向左依次绑定。不过理解数组的复杂声明时，应该由内向外理解。即从数组的名字开始按照由内向外的顺序阅读。\n\n\n访问数组元素\n\n\n使用数组下标的时候，通常将其定义为size_t类型，这是一种机器相关的无符号类型。定义在cstddef头文件中，是C标准库stddef.h头文件的C++版本。\n\n\n可以使用范围for语句来遍历数组。\n\n\nfor (auto i : arr)\n    cout \n i \n \n \n;\ncout \n endl;\n\n\n\n\n检查下标的值\n\n\n与string和vector一样，数组的下标是否在合理范围之内由程序员负责检查。\n\n\n【WARNING】大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。\n\n\n指针和数组\n\n\n在很多用到数组名字的地方，编译器都会自动地将其替换为一个\n指向数组首元素的指针\n。\n\n\ndecltype\n\n\n下面得到一个数组类型：\n\n\nint a1[10] = {};\ndecltype(a1) a2;\n\n\n\n\nauto\n\n\n下面得到一个整型指针：\n\n\nint a1[10] = {};\nauto a2(a1);\n\n\n\n\n指针也是迭代器\n\n\nstring和vector的迭代器支持的运算，指针都支持。\n\n\n使用递增运算符既可以让指向数组元素的指针向前移动到下一个位置上。\n\n\n这样可以获取数组尾元素的下一个位置的指针：\n\n\nint *end = \na[N];\n\n\n\n\n不过C++11提供了begin和end函数，可以获取数组首元素的指针和尾后指针：\n\n\nint a[10] = {};\nint *beg_p = begin(a);\nint *end_p = end(a);\n\n\n\n\n这俩函数定义在头文件iterator.h中。\n\n\n尾后指针不能解引用和递增操作。\n\n\n和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。\n\n\n下标和指针\n\n\n对数组执行下标运算其实是对指向数组元素的指针执行下标运算：\n\n\nint i = ia[2];    // ia转换成指向数组首元素的指针\n                  // ia[2]得到(ia + 2)所指的元素\nint *p = ia;      // p指向ia的首元素\ni = *(p + 2);     // 等价于i = ia[2]\n\n\n\n\n只要指针指向的是数组中的元素，都可以执行下标运算。\n\n\n内置的下标运算符可以处理负值，这和标准库类型的下标不一样（必须是无符号的）。\n\n\nC风格字符串\n\n\nC风格的字符串即是字符串字面量，也是一种字符数组，并以空字符结尾（null terminated）。\n\n\np109列举了C语言标准库提供的一组函数，可以操作C风格字符串，他们定义在cstring头文件中。\n\n\nc_str函数\n\n\nstring可使用c_str函数返回其C风格的字符串，如：\n\n\nstring s(\nhello\n);\nconst char *c_s = s.c_str();\n\n\n\n\n无法保证返回的C风格字符串一直有效，因此通常在返回后再把它拷贝到另一个地方。\n\n\n使用数组初始化vector对象\n\n\n如：\n\n\nint a[] = {1, 2, 3};\nvector\nint\n vec(begin(a), end(a));\n\n\n\n\n多维数组\n\n\n多维数组，实际上是数组的数组。\n\n\n如：\nint a[3][4]\n，可由内而外理解，a是一个含有3个元素的数组，每个元素又是一个含有4个元素的数组。\n\n\n对于二维数组，常把第一个维度看作行，第二个维度看作列。\n\n\n多维数组的初始化\n\n\n如：\n\n\nint a[3][4] = {\n    {0, 1, 2, 3},\n    {4, 5, 6, 7},\n    {8, 9, 10, 11}\n};\n\n\n\n\n列表初始化中未列出的元素执行值初始化。\n\n\n多维数组的下标引用\n\n\n如果表达式含有的下标运算符数量和维度一样多，该表达式的结果将是给定类型的元素；否则表达式的结果是内层数组。\n\n\nint a[3][4] = {};\nint (\nrow)[4] = a[2]; // row绑定到a的第二个数组上\n\n\n\n\n使用范围for语句处理多维数组\n\n\n如果是外层循环，控制变量将得到数组类型。\n\n\n除了最内层的循环外，其他所有循环控制变量都应该是引用类型（因为若不是引用，编译器会认为外层控制变量是指针类型，而无法遍历一个指针）。\n\n\n指针和多维数组\n\n\n当程序使用多维数组名字时，也会自动将其转换成指向数组首元素的指针。\n\n\n多维数组的首元素是一个内层数组，故使用多维数组名将得到一个指向内层数组的指针。\n\n\n即：\n\n\nint a[2][3] = {};\nint (*p)[3] = a;\n\n\n\n\n还可以使用auto或者begin来得到指向内层数组的指针。\n\n\n类型别名简化多维数组的指针\n\n\n可以这样定义一个数组类型：\n\n\nusing int_arr = int[4]; // C++11\ntypedef int int_arr[4];", 
            "title": "ch03 字符串、向量和数组"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#_1", 
            "text": "", 
            "title": "字符串、向量和数组"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#using", 
            "text": "有如下形式：  using namespace::name;  使用完using声明（using declaration）后，就可以省略掉名字前的前缀了（如std::）。  #include  iostream \n\nusing std::cin;\n\nint main()\n{\n    int i;\n    cin   i;\n    cout   i;    // 错误，没有对应的using声明，必须使用完整的名字\n    return 0;\n}  头文件不应包含using声明  这是因为头文件会被其它文件引用，从而使其它文件也使用了using声明，有可能造成命名冲突。", 
            "title": "命名空间的using声明"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#string", 
            "text": "string表示可变长的字符序列。使用string类型需要包含string头文件。", 
            "title": "标准库类型string"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#string_1", 
            "text": "如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别。  初始化string对象的方式：  string s1;           // 默认初始化，s1是一个空串\nstring s2(s1);       // s2是s1的副本\nstring s2 = s1;      // 等价于s2(s1)\nstring s3( value );  // s3是字面值 value 的副本，不包括最后的空字符\nstring s3 =  value ; // 等价于s3( value )\nstring s4(n, 'c');   // 初始化为由n个字符c组成的串  直接初始化和拷贝初始化  如果使用等号（=）初始化一个变量，实际上执行的是 拷贝初始化（copy initialization） ，编译器把等号右侧的对象初始值拷贝到新创建的对象中去。如果不适用等号，则执行的是 直接初始化 （direct initialization）。  string s5 =  hiya ;  // 拷贝初始化\nstring s6( hiya );   // 直接初始化\nstring s7(10, 'c');  // 直接初始化", 
            "title": "定义和初始化string对象"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#string_2", 
            "text": "如：  -  os   s , 将s写入输出流os当中，返回os  -  is   s ，从输入流中读取字符串赋值给s，字符串以空白分隔，返回is  -  getline(is, s) ，从输入流中读取一行赋值给s，返回is  -  s.empty() ，如果s为空，返回true  -  s.size() ，返回s中的字符数，与s.length()等价  -  s[n] ，返回s中第n个字符的引用  -  s1 + s2 ，返回s1和s2连接后的结果  -  s1 = s2 ，用s2的副本代替s1  -  s1 == s2 ， s1 != s2 ，如果s1和s2完全一样，则相等  -  ,  =,  ,  =，顺序比较字符大小，完全一致再比较长度  getline函数会读取换行符，但不会把它存入字符串中。getline返回输入流。  string::size_type类型  size函数返回的是一个string::size_type类型的值。这是一个无符号的整数。  string类和大多数标准库类型都定义了几种配套类型，它们体现的是标准库与机器无关的特性。  字面值和string对象相加  标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。  string s1 = s1 +  hi ;\nstring s2 = s1 + ',';", 
            "title": "string对象上的操作"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#string_3", 
            "text": "字符处理函数的头文件是cctype，它和C的ctype.c一样，只不过前者是C++的命名规范。在书本p82有cctype头文件中的函数说明。  处理每个字符？使用基于范围的for语句  如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句： 范围for （range for）语句。这种语句遍历序列中的每个元素并对序列中的每个值执行某种操作，其语法格式是：  for (declaration : expression)\n    statement  其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。  如：  for (auto c : str)\n    // do something  这里c是str中字符的副本，若要改变str中的字符，需要用引用：  for (auto  c : str)\n    // do something  使用下标运算符  [ ] 符号叫做下标运算符，范围是[0, s.size())，越界的结果是UB（undefined behavior，未定义行为）。", 
            "title": "处理string对象中的字符"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#vector", 
            "text": "vector是对象的集合，也叫容器（container）。集合中的每个对象都有一个索引，索引用于访问对象。  vector是一个类模板。模板是为编译器提供的一份生成类或函数的说明。  vector是模板而非类型，由vector生成的类型必须包含元素的类型，如：  vector int  v;  vector中存放的是对象，而引用不是对象，故不能存储引用。", 
            "title": "标准库类型vector"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#vector_1", 
            "text": "vector模板控制着初始化向量的方法。  定义vector对象的方法有：  -  vector T  v1 ，默认初始化，v1是一个空的vector  -  vector T  v2(v1) ，v2中包含v1所有元素的副本  -  vector T  v2 = v1 ，等价于v2(v1)  -  vector T  v3(n, val) ，v3包含了n个重复的元素，每个元素的值都是val  -  vector T  v4(n) ，v4包含了n个执行了值初始化的对象  -  vector T  v5{a,b,c...} ，v5里包含了用a,b,c...初始化的元素  -  vector T  v5 = {a,b,c...} ，等价于 vector T  v5{a,b,c...}  值初始化  值初始化（value initialize），是指如果是内置类型，则初始值为0；如果是类类型，执行类默认初始化。  vector T (n) 中，所有元素将执行值初始化。", 
            "title": "定义和初始化vector对象"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#vector_2", 
            "text": "push_back函数把一个元素压入vector对象的尾端。  vector的对象能高效地增长，因此更常见的情况是：创建一个空vector，然后在运行时再利用vector的成员函数push_back向其中添加元素。  一定不能在遍历vector的时候改变vector对象的大小。  【关键概念：vector对象能高效增长】  C++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小就没有什么必要了，只有一种例外，即当所有元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。", 
            "title": "向vector中添加元素"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#vector_3", 
            "text": "如（很多和string类似）：  -  v.empty() ，如果v不含有任何元素，返回true  -  v.size() ，返回v中的元素个数  -  v[n] ，返回v中第n个位置上元素的引用  -  v1 = v2 ，v2中的元素将拷贝替换v1的  -  v1 = {a,b,c...} ，列表中的元素将拷贝替换v1中的  -  v1 == v2 ,  v1 != v2 ，元素数量相同，对应位置的元素也相等，则相等  -  , =, , =，比首个相异元素的大小，如都一样，比长度，即字典顺序  size返回的类型由vector定义的size_type类型。  vector int ::size_type    // 正确\nvector::size_type         // 错误  只有当元素的值可比较时，vector对象才能被比较。  只能对确已存在的元素执行下标操作。", 
            "title": "其它vector操作"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#_2", 
            "text": "使用迭代器（iterator）是一种通用的访问容器中元素的方法。  迭代器有有效和无效之分。有效的迭代器指向某个元素，或指向尾元素的下一个位置，其它情况都属于无效。", 
            "title": "迭代器介绍"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#_3", 
            "text": "有迭代器的类型同时拥有返回迭代器的成员。  标准库容器都拥有名为begin和end的成员（函数）。其中begin成员负责返回指向第一个元素的迭代器。  end成员负责返回指向容器“尾元素的下一个位置”的迭代器。叫 尾后迭代器（off-the-end iterator） 。  如果容器为空，begin和end都返回尾后迭代器。即： v.begin() == v.end()  如：  auto b = v.begin();\nauto e = v.end();  迭代器运算符  标准容器迭代器的运算符：  -  *iter ，返回迭代器所指对象的引用（解引用）  -  iter- mem ，解引用iter，并获取其成员mem，等价于 (*iter).mem  -  ++iter ，令iter指示容器中的下一个元素  -  --iter ，令iter指示容器中的上一个元素  -  iter1 == iter2 ，如果两个迭代器指示的是同一个元素，或者它们都是尾后迭代器，则相等，反之不相等  迭代器指示一个元素时，才可对其解引用。对尾后迭代器或者无效迭代器解引用的结果是UB。  迭代器类型  标准库类型使用iterator和const_iterator来表示迭代器类型。  如：  vector int ::iterator it1;\nvector int ::const_iterator it2;  it1能读写元素，而it2只能读。  认定某个类型是迭代器类型当且仅当它支持一套操作，这套操作使得我们能访问容器的元素，或者从某个元素移动到另外一个元素。  begin和end运算符  begin和end返回的具体类型由对象是否是常量决定。如果对象是常量，返回const_iterator，否则返回iterator。  为了专门得到const_iterator类型的迭代器，C++11中可以使用cbegin和cend：  auto it = v.cbegin();  箭头运算符  即 - ，它把解引用和成员访问两个操作结合在一起。即：  (*iter).mem 等价于 iter- mem 。  某些对vector对象的操作会使迭代器失效  任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。", 
            "title": "使用迭代器"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#_4", 
            "text": "递增运算令迭代器每次移动一个元素，所有的标准库容器的迭代器都支持递增运算，也支持==和!=运算。  string和vector的迭代器提供了额外的运算符，有：  -  iter + n ，新迭代器向前移动若干个元素，它指向容器的一个元素，或是尾后迭代器  -  iter - n ，新迭代器向后移动若干个元素，它指向容器的一个元素，或是尾后迭代器  -  iter1 - iter2 ，得到迭代器之间的距离，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置  -  , =, , = ，比较迭代器所处的位置，前面的小于后面的，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置    迭代器的算数运算  迭代器相减的结果的类型是difference_type，表示右侧的迭代器要移动多少个位置才能到达左侧的。  difference_type是一个带符号的整数，string和vector都定义了这个类型。", 
            "title": "迭代器运算"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#_5", 
            "text": "数组是存放相同类型的对象的容器，这些对象是匿名的。  数组的大小确定不变。  数组是一种内置类型。", 
            "title": "数组"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#_6", 
            "text": "数组是一种复合类型，其声明形如 a[N] 。N叫维度，说明了数组中元素的个数，必须大于0，且必须是一个常量表达式，即其值在编译期间已知。  默认情况下，数组的元素执行默认初始化，这意味着在函数块内定义的执行默认初始化的含内置类型元素的数组，其元素的值未定义。  定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。数组的元素应为对象，所以不存在存储引用的数组。  显式初始化数组元素  即列表初始化，此时可以忽略数组的维度，维度由编译器推断出来。  如：  int a1[10] = {0}; // 剩下的元素执行值初始化，即为0\nint a2[] = {1, 2, 3};  字符数组的特殊性  可以用字符串字面值对此类数组进行初始化。如：  char s[] =  hello ;  这样初始化的数组包含结尾的空字符。  不允许拷贝和赋值  这样的操作是非法的：  int a1[] = {1, 2, 3};\nint a2[] = a1; // 非法  理解复杂的数组声明  定义一个指针数组：  int* a[10] = {};  定义一个指向数组的指针：  int (*ptr)[10] =  a;  定义一个绑定到数组的引用：  int ( a_ref)[10] = a;  默认情况下，类型修饰符从右向左依次绑定。不过理解数组的复杂声明时，应该由内向外理解。即从数组的名字开始按照由内向外的顺序阅读。", 
            "title": "定义和初始化内置数组"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#_7", 
            "text": "使用数组下标的时候，通常将其定义为size_t类型，这是一种机器相关的无符号类型。定义在cstddef头文件中，是C标准库stddef.h头文件的C++版本。  可以使用范围for语句来遍历数组。  for (auto i : arr)\n    cout   i      ;\ncout   endl;  检查下标的值  与string和vector一样，数组的下标是否在合理范围之内由程序员负责检查。  【WARNING】大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。", 
            "title": "访问数组元素"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#_8", 
            "text": "在很多用到数组名字的地方，编译器都会自动地将其替换为一个 指向数组首元素的指针 。  decltype  下面得到一个数组类型：  int a1[10] = {};\ndecltype(a1) a2;  auto  下面得到一个整型指针：  int a1[10] = {};\nauto a2(a1);  指针也是迭代器  string和vector的迭代器支持的运算，指针都支持。  使用递增运算符既可以让指向数组元素的指针向前移动到下一个位置上。  这样可以获取数组尾元素的下一个位置的指针：  int *end =  a[N];  不过C++11提供了begin和end函数，可以获取数组首元素的指针和尾后指针：  int a[10] = {};\nint *beg_p = begin(a);\nint *end_p = end(a);  这俩函数定义在头文件iterator.h中。  尾后指针不能解引用和递增操作。  和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。  下标和指针  对数组执行下标运算其实是对指向数组元素的指针执行下标运算：  int i = ia[2];    // ia转换成指向数组首元素的指针\n                  // ia[2]得到(ia + 2)所指的元素\nint *p = ia;      // p指向ia的首元素\ni = *(p + 2);     // 等价于i = ia[2]  只要指针指向的是数组中的元素，都可以执行下标运算。  内置的下标运算符可以处理负值，这和标准库类型的下标不一样（必须是无符号的）。", 
            "title": "指针和数组"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#c", 
            "text": "C风格的字符串即是字符串字面量，也是一种字符数组，并以空字符结尾（null terminated）。  p109列举了C语言标准库提供的一组函数，可以操作C风格字符串，他们定义在cstring头文件中。  c_str函数  string可使用c_str函数返回其C风格的字符串，如：  string s( hello );\nconst char *c_s = s.c_str();  无法保证返回的C风格字符串一直有效，因此通常在返回后再把它拷贝到另一个地方。  使用数组初始化vector对象  如：  int a[] = {1, 2, 3};\nvector int  vec(begin(a), end(a));", 
            "title": "C风格字符串"
        }, 
        {
            "location": "/ch03 字符串、向量和数组/#_9", 
            "text": "多维数组，实际上是数组的数组。  如： int a[3][4] ，可由内而外理解，a是一个含有3个元素的数组，每个元素又是一个含有4个元素的数组。  对于二维数组，常把第一个维度看作行，第二个维度看作列。  多维数组的初始化  如：  int a[3][4] = {\n    {0, 1, 2, 3},\n    {4, 5, 6, 7},\n    {8, 9, 10, 11}\n};  列表初始化中未列出的元素执行值初始化。  多维数组的下标引用  如果表达式含有的下标运算符数量和维度一样多，该表达式的结果将是给定类型的元素；否则表达式的结果是内层数组。  int a[3][4] = {};\nint ( row)[4] = a[2]; // row绑定到a的第二个数组上  使用范围for语句处理多维数组  如果是外层循环，控制变量将得到数组类型。  除了最内层的循环外，其他所有循环控制变量都应该是引用类型（因为若不是引用，编译器会认为外层控制变量是指针类型，而无法遍历一个指针）。  指针和多维数组  当程序使用多维数组名字时，也会自动将其转换成指向数组首元素的指针。  多维数组的首元素是一个内层数组，故使用多维数组名将得到一个指向内层数组的指针。  即：  int a[2][3] = {};\nint (*p)[3] = a;  还可以使用auto或者begin来得到指向内层数组的指针。  类型别名简化多维数组的指针  可以这样定义一个数组类型：  using int_arr = int[4]; // C++11\ntypedef int int_arr[4];", 
            "title": "多维数组"
        }, 
        {
            "location": "/ch04 表达式/", 
            "text": "表达式\n\n\n\n\n表达式由一个或多个\n运算对象\n（operand）组成，对表达式求值将得到一个\n结果\n（result）。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个\n运算符\n（operator）和一个或多个运算对象组合起来可以生成较复杂的表达式。\n\n\n基础\n\n\n以下几个基础概念涉及大多数表达式。\n\n\n基本概念\n\n\nC++定义了一元运算符（unary operator）和二元运算符（binary operator）。作用于一个运算对象的运算符是一元运算符；作用于两个运算对象的运算符是二元运算符。函数调用是一种特殊的运算符，它对运算对象的数量没有限制。\n\n\n重载运算符\n\n\nC++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自行定义其含义，称之为\n重载运算符\n（overloaded operator）。\n\n\n我们使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。\n\n\n左值和右值\n\n\nC++的表达式要不然是\n右值\n（rvalue），要不然就是\n左值\n（lvalue）。左值可以位于赋值语句的左侧，右值则不能。当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（内存中的位置）。\n\n\n求值结果的临时值是一种右值。\n\n\nFoo \nrevVal(); // 函数调用返回一个左值\nFoo retVal();  // 函数调用返回一个右值\n\n\n\n\n优先级与结合律\n\n\n复合表达式\n（compound expression）是指含有两个或多个运算符的表达式。求复合表达式的值需要首先将运算符和运算对象合理地组合在一起，优先级和结合律决定了运算对象组合的方式。\n\n\n一般来说，高优先级运算符的运算对象要比低优先级运算符的运算对象更为紧密地组织在一起。如果优先级相同，则其组合规则由结合律确定。\n\n\n表达式中的括号无视上述规则，程序员可以使用括号将表达式的某个局部括起来使得其得到优先运算。\n\n\np147页罗列出了全部的运算符和其优先级、结合律的信息。\n\n\n求值顺序\n\n\n优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确求值的顺序。如：\n\n\nint i = f1() * f2();\n\n\n\n\nf1和f2一定在乘法之前被调用，但是谁先调用无从得知。\n\n\n对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。比如下面的表达式是未定义的：\n\n\nint i = 0;\ncout \n i \n \n \n \n ++i \n endl;\n\n\n\n\n编译器可能先求++i的值，再求i的值，所以结果无法预知。\n\n\n有4种运算符明确规定了运算对象的求值顺序：逻辑与（\n）、逻辑或（||）、条件运算符（?:）和逗号运算符（,）。\n\n\n求值顺序、优先级、结合律\n\n\n以下两条经验准则对书写复合表达式有益：\n\n\n0. 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。\n\n\n0. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。\n\n\n第二条有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，\n*++iter\n，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时，求值的顺序不会成为问题。\n\n\n\n\nmy note：上面这句话还是挺绕口的，反正这种类似写法的运算不会成为问题。\n\n\n\n\n算术运算符\n\n\n算术运算符中，一元运算符的优先级最高，然后是乘法和除法，优先级最低的是加法和减法。p124页列出的算术运算符满足左结合律，意味着当优先级相同时，按照从左向右的顺序进行组合。\n\n\n算术运算符的运算对象和求值结果都是右值。在表达式求值之前，小整数类型的运算对象被提升成较大的整数类型，所有运算对象最终会转换成同一类型。\n\n\n【提示：溢出和其他算术运算异常】算术表达式有可能产生未定义的结果。一部分原因是数学性质本身：例如除数是0的情况；另外一部分则源于计算机的特点：例如溢出，当计算结果超出该类型所能表示的范围时就会产生溢出。\n\n\n整数相除的结果还是整数，也就是说，如果商含有小数部分，直接抛弃。\n\n\n运算符%俗称“取余”或“取模”运算符，负责计算两个整数相除所得的余数。参与取余运算的运算对象必须是整数类型。\n\n\n关于正负号的运算，除了-m导致溢出的特殊情况，其他时候，(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)。\n\n\n逻辑和关系运算符\n\n\n关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则表示真。这两种运算符的运算对象和求值结果都是右值。\n\n\n\n\nmy note: 本节的概念比较简单，故而不做更多笔记。更多细节可查阅书本p127。\n\n\n\n\n赋值运算符\n\n\n赋值运算符的左侧运算对象必须是一个可修改的左值。赋值运算的结果是它左侧的运算对象，并且是一个左值。如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。\n\n\nC++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象：\n\n\nint k = 0;\nk = {3.14};    // 错误，窄化转换\n\n\n\n\n如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，且该值即使转换的话其所占空间也不应该大于目标类型的空间。\n\n\n对于类类型来说，赋值运算的细节由类本身决定。\n\n\n无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量并将其赋给左侧运算对象。\n\n\n赋值运算满足右结合律。\n\n\n\n\nmy note: 还有一些概念比较简单，见书本p130。\n\n\n\n\n递增和递减运算符\n\n\n递增和递减运算符有两种形式：前置版本和后置版本。前置版本首先将运算对象加1（or减1），然后将改变后的对象作为求值结果。后置版本也会将对象加1（or减1），但是求值结果是运算对象改变之前那个值的副本。\n\n\n这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。\n\n\n【建议：除非必须，否则不用后置版本】这是因为后置版本将原始值存储下来以便于返回，而前置版本避免了这个工作。尤其是对于迭代器类型，这种额外的工作消耗巨大。\n\n\n在一条语句中混用解引用和递增运算符\n\n\n可以使用后置的递增运算符来控制循环输出一个vector对象内容：\n\n\nauto pbeg = v.begin();\nwhile (pbeg != v.end)\n    cout \n *pbeg++;\n\n\n\n\n后置递增运算符的优先级高于解引用运算符，因此*pbeg++等价于*(pbeg++)。这是一种被广泛使用的、有效的写法。\n\n\n成员访问运算符\n\n\n点运算符和箭头运算符都可以用于访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr-\nmem等价于(*ptr).mem。\n\n\n因为解引用运算符的优先级低于点运算符，所以要向上面那样加上括号。\n\n\n箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值。\n\n\n\n\nmy note: 上面左值右值的讨论不是很能理清，但若是结合实际情况，应该不会很难懂。\n\n\n\n\n条件运算符\n\n\n条件运算符（?:）允许我们把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：\n\n\ncond ? expr1:expr2\n\n\n条件运算符的执行过程是：首先求cond的值，如果为真则对expr求值并返回该值，否则对expr2求值并返回该值。举例：\n\n\nstring finalgrade = (grade \n 60) ? \nfail\n : \npass\n;\n\n\n\n\n当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则是右值。\n\n\n位运算符\n\n\n位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。\n\n\n\n\n一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算如何处理运算对象的“符号位”依赖于机器。\n\n\n【WARNING】强烈建议将位运算符用于处理无符号类型。\n\n\n\n\nmy note: 一个提升例子就是，如果对char做位运算，它会先被提升为int。\n\n\n\n\n移位运算符\n\n\n和\n运算符的内置含义是对其运算对象执行基于二进制位的移动操作。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位数被舍弃掉了。\n\n\n左移运算符\n在右侧插入值为0的二进制位。右移运算符\n的行为依赖于左侧运算对象的类型：如果是无符号的，在左侧插入值为0的二进制位；如果是带符号的，在左侧插入符号位的副本或值为0的二进制位，如何选择视具体环境而定。\n\n\nsizeof运算符\n\n\nsizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。它有两种形式：\n\n\n- sizeof(type)\n- sizeof expr\n\n\n\n\nmy note: 常量表达式意味着在编译期间就能得到计算。\n\n\n\n\n第二种形式中，sizeof返回的是表达式结果类型的大小。\n\n\nsizeof运算符的结果部分地依赖于其作用的类型：\n\n\n- 对char或者类型为char的表达式执行sizeof运算，结果得1。\n\n\n- 对引用类型执行sizeof运算得到被引用对象所占空间大小。\n\n\n- 对指针执行sizeof运算得到指针本身所占空间的大小。\n\n\n- 对解引用指针执行sizeof运算得到指针指向对象所占空间的大小，指针不需要有效。\n\n\n- 对数组执行sizeof运算得到整个数组所占空间大小。\n\n\n- 对string对象或vector执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。\n\n\n逗号运算符\n\n\n逗号运算符\n（comma operator）含有两个运算对象，按照从左向右的顺序依次求值。\n\n\n它首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么结果也是左值。\n\n\n类型转换\n\n\n考虑下面这条表达式，它的目的是将ival初始化为6：\n\n\nint ival = 3.541 + 3;\n\n\n\n\nC++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一后再求值。上述转换是自动进行的，它们被称作\n隐式转换\n（implicit conversion）。\n\n\n很多时候，如果表达式中既有整数类型的运算对象也有浮点数类型的运算对象，整型会转换成浮点型。\n\n\n何时发生隐式转换\n\n\n在下面这些情况下，编译器会自动地转换运算对象的类型：\n\n\n- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。\n\n\n- 在条件中，非布尔值转换成布尔类型。\n\n\n- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。\n\n\n- 如果算术运算或关系运算对象有多种类型，需要转换成同一种类型。\n\n\n算术转换\n\n\n算术转换\n（arithmetic conversion）的含义是把一种算术类型转换成另外一种算术类型。\n\n\n整数提升\n（integral promotion）负责把小整数转换成较大的整数类型。\n\n\n\n\nmy note: 这里的概念很细，感觉没有必要一一记录，因为书中已经有了明晰的介绍，可参阅p142。\n\n\n\n\n其他隐式转换\n\n\n数组转换成指针：\n在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。\n\n\n指针的转换：\n常量整数值0或者字面值nullptr能转换成任意指针类型；指向对象的指针可以转换成void*指针。\n\n\n转换成布尔类型：\n如果指针或算术类型的值为0，转换的结果是false，否则是true。\n\n\n转换成常量：\n允许将指向非常量类型的指针转换成底层const版本的指针，对于引用也是一样。\n\n\nint i;\nconst int *p = \ni;    // 非常量的地址转换成const的地址\n\n\n\n\n类类型定义的转换：\n类类型能定义由编译器自动执行的转换。\n\n\nstring s = \na value\n;    // 字符串字面量转换成string类型\nwhile (cin \n a);        // while的条件部分把cin转换成布尔值\n\n\n\n\n显式转换\n\n\n命名的强制类型转换\n\n\n一个命名的强制类型转换有如下形式：\n\n\ncast-name\n(expression);\n\n\n其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast, dynamic_cast, const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时识别，直到19章（p730）才会讲解。\n\n\nstatic_cast\n\n\n任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。\n\n\n// 进行强制类型转换以便执行浮点数除法\ndouble slope = static_cast\ndouble\n(j) / i;\n\n\n\n\n当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换表示，我们知道并且不在乎潜在的精度损失。\n\n\nstatic_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_casst找回存在于void*的指针中的值：\n\n\nvoid *p = \nd;    // 正确，任何非常量对象的地址都能存入void*\n\n// 正确，将void*转换回初始的指针类型\ndouble *dp = static_cast\ndouble*\n(p);\n\n\n\n\n必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。\n\n\nconst_cast\n\n\nconst_cast只能改变运算对象的底层const：\n\n\nconst char *pc;\nchar *p = const_cast\nchar*\n(pc);    // 正确，但是通过p写值是未定义的行为\n\n\n\n\n如果对象本身是一个非常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，执行写操作就会产生未定义的后果。\n\n\nconst_cast常常用于有函数重载的上下文中，这将在第6章介绍（p208）。\n\n\nreinterpret_cast\n\n\nreinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。比如：\n\n\nint *ip;\nchar *pc = reinterpret_cast\nchar*\n(ip);\n\n\n\n\n我们必须牢记pc所指的真实对象是一个int而非字符。\n\n\n\n\nmy note: reinterpret_cast非常危险，书中建议尽量避免使用。因为它本质上依赖于机器。且没有介绍应用场景。另外，书中也建议尽量避免其他的强制类型转换，强制类型转换应当在其合适的应用场景中使用。\n\n\n\n\n旧式的强制类型转换\n\n\n在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：\n\n\ntype(expr);   // 函数形式的强制类型转换\n(type)expr;   // C语言风格的强制类型转换\n\n\n\n\n根据所涉及的类型不同，旧式的强制类型转换分别具有const_cast, static_cast或reinterpret_cast相似的行为。\n\n\n【WARNING】与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。", 
            "title": "ch04 表达式"
        }, 
        {
            "location": "/ch04 表达式/#_1", 
            "text": "表达式由一个或多个 运算对象 （operand）组成，对表达式求值将得到一个 结果 （result）。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个 运算符 （operator）和一个或多个运算对象组合起来可以生成较复杂的表达式。", 
            "title": "表达式"
        }, 
        {
            "location": "/ch04 表达式/#_2", 
            "text": "以下几个基础概念涉及大多数表达式。", 
            "title": "基础"
        }, 
        {
            "location": "/ch04 表达式/#_3", 
            "text": "C++定义了一元运算符（unary operator）和二元运算符（binary operator）。作用于一个运算对象的运算符是一元运算符；作用于两个运算对象的运算符是二元运算符。函数调用是一种特殊的运算符，它对运算对象的数量没有限制。  重载运算符  C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自行定义其含义，称之为 重载运算符 （overloaded operator）。  我们使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。  左值和右值  C++的表达式要不然是 右值 （rvalue），要不然就是 左值 （lvalue）。左值可以位于赋值语句的左侧，右值则不能。当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（内存中的位置）。  求值结果的临时值是一种右值。  Foo  revVal(); // 函数调用返回一个左值\nFoo retVal();  // 函数调用返回一个右值", 
            "title": "基本概念"
        }, 
        {
            "location": "/ch04 表达式/#_4", 
            "text": "复合表达式 （compound expression）是指含有两个或多个运算符的表达式。求复合表达式的值需要首先将运算符和运算对象合理地组合在一起，优先级和结合律决定了运算对象组合的方式。  一般来说，高优先级运算符的运算对象要比低优先级运算符的运算对象更为紧密地组织在一起。如果优先级相同，则其组合规则由结合律确定。  表达式中的括号无视上述规则，程序员可以使用括号将表达式的某个局部括起来使得其得到优先运算。  p147页罗列出了全部的运算符和其优先级、结合律的信息。", 
            "title": "优先级与结合律"
        }, 
        {
            "location": "/ch04 表达式/#_5", 
            "text": "优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确求值的顺序。如：  int i = f1() * f2();  f1和f2一定在乘法之前被调用，但是谁先调用无从得知。  对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。比如下面的表达式是未定义的：  int i = 0;\ncout   i         ++i   endl;  编译器可能先求++i的值，再求i的值，所以结果无法预知。  有4种运算符明确规定了运算对象的求值顺序：逻辑与（ ）、逻辑或（||）、条件运算符（?:）和逗号运算符（,）。  求值顺序、优先级、结合律  以下两条经验准则对书写复合表达式有益：  0. 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。  0. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。  第二条有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如， *++iter ，递增运算符改变iter的值，iter（已经改变）的值又是解引用运算符的运算对象。此时，求值的顺序不会成为问题。   my note：上面这句话还是挺绕口的，反正这种类似写法的运算不会成为问题。", 
            "title": "求值顺序"
        }, 
        {
            "location": "/ch04 表达式/#_6", 
            "text": "算术运算符中，一元运算符的优先级最高，然后是乘法和除法，优先级最低的是加法和减法。p124页列出的算术运算符满足左结合律，意味着当优先级相同时，按照从左向右的顺序进行组合。  算术运算符的运算对象和求值结果都是右值。在表达式求值之前，小整数类型的运算对象被提升成较大的整数类型，所有运算对象最终会转换成同一类型。  【提示：溢出和其他算术运算异常】算术表达式有可能产生未定义的结果。一部分原因是数学性质本身：例如除数是0的情况；另外一部分则源于计算机的特点：例如溢出，当计算结果超出该类型所能表示的范围时就会产生溢出。  整数相除的结果还是整数，也就是说，如果商含有小数部分，直接抛弃。  运算符%俗称“取余”或“取模”运算符，负责计算两个整数相除所得的余数。参与取余运算的运算对象必须是整数类型。  关于正负号的运算，除了-m导致溢出的特殊情况，其他时候，(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)。", 
            "title": "算术运算符"
        }, 
        {
            "location": "/ch04 表达式/#_7", 
            "text": "关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则表示真。这两种运算符的运算对象和求值结果都是右值。   my note: 本节的概念比较简单，故而不做更多笔记。更多细节可查阅书本p127。", 
            "title": "逻辑和关系运算符"
        }, 
        {
            "location": "/ch04 表达式/#_8", 
            "text": "赋值运算符的左侧运算对象必须是一个可修改的左值。赋值运算的结果是它左侧的运算对象，并且是一个左值。如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。  C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象：  int k = 0;\nk = {3.14};    // 错误，窄化转换  如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，且该值即使转换的话其所占空间也不应该大于目标类型的空间。  对于类类型来说，赋值运算的细节由类本身决定。  无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量并将其赋给左侧运算对象。  赋值运算满足右结合律。   my note: 还有一些概念比较简单，见书本p130。", 
            "title": "赋值运算符"
        }, 
        {
            "location": "/ch04 表达式/#_9", 
            "text": "递增和递减运算符有两种形式：前置版本和后置版本。前置版本首先将运算对象加1（or减1），然后将改变后的对象作为求值结果。后置版本也会将对象加1（or减1），但是求值结果是运算对象改变之前那个值的副本。  这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。  【建议：除非必须，否则不用后置版本】这是因为后置版本将原始值存储下来以便于返回，而前置版本避免了这个工作。尤其是对于迭代器类型，这种额外的工作消耗巨大。  在一条语句中混用解引用和递增运算符  可以使用后置的递增运算符来控制循环输出一个vector对象内容：  auto pbeg = v.begin();\nwhile (pbeg != v.end)\n    cout   *pbeg++;  后置递增运算符的优先级高于解引用运算符，因此*pbeg++等价于*(pbeg++)。这是一种被广泛使用的、有效的写法。", 
            "title": "递增和递减运算符"
        }, 
        {
            "location": "/ch04 表达式/#_10", 
            "text": "点运算符和箭头运算符都可以用于访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr- mem等价于(*ptr).mem。  因为解引用运算符的优先级低于点运算符，所以要向上面那样加上括号。  箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值。   my note: 上面左值右值的讨论不是很能理清，但若是结合实际情况，应该不会很难懂。", 
            "title": "成员访问运算符"
        }, 
        {
            "location": "/ch04 表达式/#_11", 
            "text": "条件运算符（?:）允许我们把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：  cond ? expr1:expr2  条件运算符的执行过程是：首先求cond的值，如果为真则对expr求值并返回该值，否则对expr2求值并返回该值。举例：  string finalgrade = (grade   60) ?  fail  :  pass ;  当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则是右值。", 
            "title": "条件运算符"
        }, 
        {
            "location": "/ch04 表达式/#_12", 
            "text": "位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。   一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算如何处理运算对象的“符号位”依赖于机器。  【WARNING】强烈建议将位运算符用于处理无符号类型。   my note: 一个提升例子就是，如果对char做位运算，它会先被提升为int。   移位运算符  和 运算符的内置含义是对其运算对象执行基于二进制位的移动操作。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位数被舍弃掉了。  左移运算符 在右侧插入值为0的二进制位。右移运算符 的行为依赖于左侧运算对象的类型：如果是无符号的，在左侧插入值为0的二进制位；如果是带符号的，在左侧插入符号位的副本或值为0的二进制位，如何选择视具体环境而定。", 
            "title": "位运算符"
        }, 
        {
            "location": "/ch04 表达式/#sizeof", 
            "text": "sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。它有两种形式：  - sizeof(type)\n- sizeof expr   my note: 常量表达式意味着在编译期间就能得到计算。   第二种形式中，sizeof返回的是表达式结果类型的大小。  sizeof运算符的结果部分地依赖于其作用的类型：  - 对char或者类型为char的表达式执行sizeof运算，结果得1。  - 对引用类型执行sizeof运算得到被引用对象所占空间大小。  - 对指针执行sizeof运算得到指针本身所占空间的大小。  - 对解引用指针执行sizeof运算得到指针指向对象所占空间的大小，指针不需要有效。  - 对数组执行sizeof运算得到整个数组所占空间大小。  - 对string对象或vector执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。", 
            "title": "sizeof运算符"
        }, 
        {
            "location": "/ch04 表达式/#_13", 
            "text": "逗号运算符 （comma operator）含有两个运算对象，按照从左向右的顺序依次求值。  它首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么结果也是左值。", 
            "title": "逗号运算符"
        }, 
        {
            "location": "/ch04 表达式/#_14", 
            "text": "考虑下面这条表达式，它的目的是将ival初始化为6：  int ival = 3.541 + 3;  C++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一后再求值。上述转换是自动进行的，它们被称作 隐式转换 （implicit conversion）。  很多时候，如果表达式中既有整数类型的运算对象也有浮点数类型的运算对象，整型会转换成浮点型。  何时发生隐式转换  在下面这些情况下，编译器会自动地转换运算对象的类型：  - 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。  - 在条件中，非布尔值转换成布尔类型。  - 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。  - 如果算术运算或关系运算对象有多种类型，需要转换成同一种类型。", 
            "title": "类型转换"
        }, 
        {
            "location": "/ch04 表达式/#_15", 
            "text": "算术转换 （arithmetic conversion）的含义是把一种算术类型转换成另外一种算术类型。  整数提升 （integral promotion）负责把小整数转换成较大的整数类型。   my note: 这里的概念很细，感觉没有必要一一记录，因为书中已经有了明晰的介绍，可参阅p142。", 
            "title": "算术转换"
        }, 
        {
            "location": "/ch04 表达式/#_16", 
            "text": "数组转换成指针： 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。  指针的转换： 常量整数值0或者字面值nullptr能转换成任意指针类型；指向对象的指针可以转换成void*指针。  转换成布尔类型： 如果指针或算术类型的值为0，转换的结果是false，否则是true。  转换成常量： 允许将指向非常量类型的指针转换成底层const版本的指针，对于引用也是一样。  int i;\nconst int *p =  i;    // 非常量的地址转换成const的地址  类类型定义的转换： 类类型能定义由编译器自动执行的转换。  string s =  a value ;    // 字符串字面量转换成string类型\nwhile (cin   a);        // while的条件部分把cin转换成布尔值", 
            "title": "其他隐式转换"
        }, 
        {
            "location": "/ch04 表达式/#_17", 
            "text": "命名的强制类型转换  一个命名的强制类型转换有如下形式：  cast-name (expression);  其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast, dynamic_cast, const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时识别，直到19章（p730）才会讲解。  static_cast  任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。  // 进行强制类型转换以便执行浮点数除法\ndouble slope = static_cast double (j) / i;  当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换表示，我们知道并且不在乎潜在的精度损失。  static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_casst找回存在于void*的指针中的值：  void *p =  d;    // 正确，任何非常量对象的地址都能存入void*\n\n// 正确，将void*转换回初始的指针类型\ndouble *dp = static_cast double* (p);  必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。  const_cast  const_cast只能改变运算对象的底层const：  const char *pc;\nchar *p = const_cast char* (pc);    // 正确，但是通过p写值是未定义的行为  如果对象本身是一个非常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，执行写操作就会产生未定义的后果。  const_cast常常用于有函数重载的上下文中，这将在第6章介绍（p208）。  reinterpret_cast  reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。比如：  int *ip;\nchar *pc = reinterpret_cast char* (ip);  我们必须牢记pc所指的真实对象是一个int而非字符。   my note: reinterpret_cast非常危险，书中建议尽量避免使用。因为它本质上依赖于机器。且没有介绍应用场景。另外，书中也建议尽量避免其他的强制类型转换，强制类型转换应当在其合适的应用场景中使用。   旧式的强制类型转换  在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：  type(expr);   // 函数形式的强制类型转换\n(type)expr;   // C语言风格的强制类型转换  根据所涉及的类型不同，旧式的强制类型转换分别具有const_cast, static_cast或reinterpret_cast相似的行为。  【WARNING】与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。", 
            "title": "显式转换"
        }, 
        {
            "location": "/ch05 语句/", 
            "text": "语句\n\n\n\n\n简单语句\n\n\nC++语言中的大多数语句都以分号结束，一个表达式，比如ival+5，末尾加上分号就变成了\n表达式语句\n(expression statement)，表达式语句的作用是执行表达式并丢弃掉求值结果：\n\n\nival + 5;    // 无意义的表达式语句\ncout \n ival;// 有意义的表达式语句\n\n\n\n\n空语句\n\n\n最简单的语句是\n空语句\n（null statement），它只有一个分号：\n\n\n; // 空语句\n\n\n\n\n如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。\n\n\n复合语句（块）\n\n\n复合语句（compound statement）是指用花括号括起来的语句和声明的序列，复合语句也被称作\n块\n（block）。一个块就是一个作用域。\n\n\n如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。\n\n\n所谓空块，是指内部没有任何语句的一对花括号。空块的作用等价于空语句：\n\n\nwhile (cin \n s \n s != sought)\n{}  // 空块\n\n\n\n\n语句作用域\n\n\n可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：\n\n\nwhile (int i = get_num()) // 每次迭代时创建并初始化\n    cout \n i \n endl;\ni = 0;    // 错误，在循环外部无法访问\n\n\n\n\n\n\nmy note: 如上述例子的写法，似乎没有什么实际意义。\n\n\n\n\n条件语句\n\n\nC++语言提供了两种按条件执行的语句。一种是if语句，它根据条件决定控制流；另一种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。\n\n\nif语句\n\n\nif语句的作用是：判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句。\n\n\n\n\nmy note: 这里讲解的语法自己已经很熟悉了，故不做更多笔记。\n\n\n\n\nswitch语句\n\n\nswitch语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。\n\n\n\n\nmy note\n\n\nswitch语句我已经很熟悉了，故不做更多笔记。\n\n\n在switch内部定义变量，一个好的办法是：在case分支下，通过使用块把变量定义在块内，从而确保后面所有case标签都在变量的作用域之外。具体的原因见p163。\n\n\ncase true:\n    {\n        // 正确：声明语句位于语句块内部\n        string file_name = get_file_name();\n    }\n    break;\n\n\n\n\n\n\nmy note: 要记住的是，C++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。基于此，在case分支后面定义并初始化一个变量很可能是不合法的，因为此分支可能被跳过，而另一个分支却访问了此变量。\n\n\n\n\n\n\n迭代语句\n\n\n迭代语句通常称之为循环，它重复执行操作直到满足某个条件才停下来。while和for语句在执行循环体之前检查条件，do while语句先执行循环体，然后再检查条件。\n\n\nwhile语句\n\n\n语法格式是：\n\n\nwhile (condition)\n    statement\n\n\n只要condition的求值结果为真就一直执行statement。如果condition第一次求值就是false，statement一次都不执行。\n\n\nwhile的条件部分可以是一个表达式或者是一个带初始化的变量声明。\n\n\n使用while循环\n\n\n当不确定到底要迭代多少次时，使用while循环比较合适。还有一种情况也应该使用while循环，这就是我们想在循环结束后访问循环控制变量。\n\n\n传统的for语句\n\n\nfor语句的语法形式是\n\n\nfor (init-statement: condition; expression)\n    statement\n\n\n\n\nmy note: 传统for语句我已经比较熟悉了，故不做更多笔记。\n\n\n\n\n范围for语句\n\n\nC++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。\n范围for语句\n（range for statement）的语法形式是：\n\n\nfor (declaration : expression)\n    statement\n\n\nexpression必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。\n\n\ndeclaration定义一个变量，序列中的每个元素都能转换成该变量的类型。\n\n\n每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行statement。\n\n\n在范围for语句中，预存了end()的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了。因此不能通过范围for语句增加vector对象的元素。\n\n\ndo while语句\n\n\ndo while语句和while语句非常相似，唯一的区别是，do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少会执行一次循环。do while语句的语法形式如下：\n\n\ndo\n    statement\nwhile (condition);\n\n\n\n\ncondition使用的变量必须定义在循环体之外。\n\n\n\n\nmy note: 如果在condition中定义变量，是没有意义的，因为statement无法访问它，它在do while循环的外面也无法访问。\n\n\n\n\n跳转语句\n\n\n跳转语句中断当前的执行过程。C++语言提供了4种跳转语句：break, continue, goto和return。本章介绍前三种，return在第六章介绍（p199页）。\n\n\nbreak语句\n\n\nbreak语句负责终止离它最近的while, do while, for或switch语句，并从这些语句之后的第一条语句开始执行。\n\n\ncontinue语句\n\n\ncontinue语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for, while和do while循环的内部。\n\n\ngoto语句\n\n\ngoto语句（goto statement）的作用是从goto语句无条件跳转到同一函数内的另一条语句。\n\n\n\n\nmy note: 书上建议不要使用goto语句。我认为它应该有其合适的应用场景，只不过对于初学者并不需要。\n\n\n\n\ngoto语句的语法形式是：\n\n\ngoto lable:\n\n\n\n\nlabel是用于标识一条语句的标示符。\n带标签的语句\n（labeled statement）是一种特殊的语句，在它之前有一个标示符以及一个冒号：\n\n\nend: return; // 带标签的语句，可以作为goto的目标\n\n\n\n\n标签标示符独立于变量或其他标示符的名字，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。\n\n\n和switch语句类似，goto语句也不能将程序的控制权从变量的作用域之外转移到作用域之内。\n\n\n// ...\ngoto end:\n    int ix = 10; // 错误，goto语句绕过了一个带初始化的变量定义\n\nend:\n    // 错误，goto绕过了ix的声明\n    ix = 12;\n\n\n\n\n跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它：\n\n\n// 向后跳过一个带初始化的变量定义是合法的\nbegin:\n    int sz = get_size();\n    if (sz \n= 0)\n        goto begin;\n\n\n\n\ntry语句块和异常处理\n\n\n异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。\n\n\n当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时，检测出问题的部分应该发出某种信号以表明程序遇到了故障，无法继续下去了，而信号的发出方无须知道故障将在何处得到解决。\n\n\n如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。\n\n\n异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言中，异常处理包括：\n\n\n- \nthrow 表达式（throw expression）\n，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw\n引发（raise）\n了异常。\n\n\n- \ntry语句块（try block）\n，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个\ncatch子句（catch clause）\n结束。try语句块中代码抛出的异常通常会被某个catch子句处理。\n\n\n- 一套\n异常类（exception class）\n，用于在throw表达式和相关的catch子句之间传递异常的具体信息。\n\n\n\n\nmy note: 编写异常安全的代码非常困难，关于异常安全的概念见书本p175。另外，本书中会介绍一些比较常规的提升异常安全性的技术，但不会详细介绍编写异常处理的代码。\n\n\n\n\nthrow表达式\n\n\n抛出异常的一个例子是：\n\n\nthrow runtime_error(\nData must refer to same ISBN\n);\n\n\n\n\n该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。\n\n\n\n\nmy note: 书本上有例子的详细解读，见p173。\n\n\n\n\ntry语句块\n\n\ntry语句块的通用语法形式是：\n\n\ntry {\n    program-statements\n} catch (exception-declaration) {\n    handler-statements\n} // ...\n\n\n\n\n当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。\n\n\ntry语句块内声明的变量在catch子句内无法访问。\n\n\n一个简要的例子（摘自书本）：\n\n\nwhile (cin \n item1 \n item2) {\n    try {\n        // ... 可能抛出一个异常的代码\n    } catch (runtime_error err) {\n        cout \n err.what() \n \n\\nTry Again? Enter y or n\n \n endl;\n        char c;\n        cin \n c;\n        if (!cin || c == 'n')\n            break; // 跳出while循环\n    }\n}\n\n\n\n\n\n\nmy note: 见书本更详细的解读。\n\n\n\n\n函数在寻找处理代码的过程中退出\n\n\n当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，直到找到适当类型的catch子句为止。\n\n\n如果最终还是没能找到，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。\n\n\n标准异常\n\n\nC++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以用在用户编写的程序中。这些异常类见书本p176。\n\n\n异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的异常说明。\n\n\n如果异常类型有一个字符串初始值，则what返回该字符串，否则返回的内容由编译器决定。", 
            "title": "ch05 语句"
        }, 
        {
            "location": "/ch05 语句/#_1", 
            "text": "", 
            "title": "语句"
        }, 
        {
            "location": "/ch05 语句/#_2", 
            "text": "C++语言中的大多数语句都以分号结束，一个表达式，比如ival+5，末尾加上分号就变成了 表达式语句 (expression statement)，表达式语句的作用是执行表达式并丢弃掉求值结果：  ival + 5;    // 无意义的表达式语句\ncout   ival;// 有意义的表达式语句  空语句  最简单的语句是 空语句 （null statement），它只有一个分号：  ; // 空语句  如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。  复合语句（块）  复合语句（compound statement）是指用花括号括起来的语句和声明的序列，复合语句也被称作 块 （block）。一个块就是一个作用域。  如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。  所谓空块，是指内部没有任何语句的一对花括号。空块的作用等价于空语句：  while (cin   s   s != sought)\n{}  // 空块", 
            "title": "简单语句"
        }, 
        {
            "location": "/ch05 语句/#_3", 
            "text": "可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：  while (int i = get_num()) // 每次迭代时创建并初始化\n    cout   i   endl;\ni = 0;    // 错误，在循环外部无法访问   my note: 如上述例子的写法，似乎没有什么实际意义。", 
            "title": "语句作用域"
        }, 
        {
            "location": "/ch05 语句/#_4", 
            "text": "C++语言提供了两种按条件执行的语句。一种是if语句，它根据条件决定控制流；另一种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。", 
            "title": "条件语句"
        }, 
        {
            "location": "/ch05 语句/#if", 
            "text": "if语句的作用是：判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句。   my note: 这里讲解的语法自己已经很熟悉了，故不做更多笔记。", 
            "title": "if语句"
        }, 
        {
            "location": "/ch05 语句/#switch", 
            "text": "switch语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。   my note  switch语句我已经很熟悉了，故不做更多笔记。  在switch内部定义变量，一个好的办法是：在case分支下，通过使用块把变量定义在块内，从而确保后面所有case标签都在变量的作用域之外。具体的原因见p163。  case true:\n    {\n        // 正确：声明语句位于语句块内部\n        string file_name = get_file_name();\n    }\n    break;   my note: 要记住的是，C++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。基于此，在case分支后面定义并初始化一个变量很可能是不合法的，因为此分支可能被跳过，而另一个分支却访问了此变量。", 
            "title": "switch语句"
        }, 
        {
            "location": "/ch05 语句/#_5", 
            "text": "迭代语句通常称之为循环，它重复执行操作直到满足某个条件才停下来。while和for语句在执行循环体之前检查条件，do while语句先执行循环体，然后再检查条件。", 
            "title": "迭代语句"
        }, 
        {
            "location": "/ch05 语句/#while", 
            "text": "语法格式是：  while (condition)\n    statement  只要condition的求值结果为真就一直执行statement。如果condition第一次求值就是false，statement一次都不执行。  while的条件部分可以是一个表达式或者是一个带初始化的变量声明。  使用while循环  当不确定到底要迭代多少次时，使用while循环比较合适。还有一种情况也应该使用while循环，这就是我们想在循环结束后访问循环控制变量。", 
            "title": "while语句"
        }, 
        {
            "location": "/ch05 语句/#for", 
            "text": "for语句的语法形式是  for (init-statement: condition; expression)\n    statement   my note: 传统for语句我已经比较熟悉了，故不做更多笔记。", 
            "title": "传统的for语句"
        }, 
        {
            "location": "/ch05 语句/#for_1", 
            "text": "C++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。 范围for语句 （range for statement）的语法形式是：  for (declaration : expression)\n    statement  expression必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。  declaration定义一个变量，序列中的每个元素都能转换成该变量的类型。  每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行statement。  在范围for语句中，预存了end()的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了。因此不能通过范围for语句增加vector对象的元素。", 
            "title": "范围for语句"
        }, 
        {
            "location": "/ch05 语句/#do-while", 
            "text": "do while语句和while语句非常相似，唯一的区别是，do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少会执行一次循环。do while语句的语法形式如下：  do\n    statement\nwhile (condition);  condition使用的变量必须定义在循环体之外。   my note: 如果在condition中定义变量，是没有意义的，因为statement无法访问它，它在do while循环的外面也无法访问。", 
            "title": "do while语句"
        }, 
        {
            "location": "/ch05 语句/#_6", 
            "text": "跳转语句中断当前的执行过程。C++语言提供了4种跳转语句：break, continue, goto和return。本章介绍前三种，return在第六章介绍（p199页）。", 
            "title": "跳转语句"
        }, 
        {
            "location": "/ch05 语句/#break", 
            "text": "break语句负责终止离它最近的while, do while, for或switch语句，并从这些语句之后的第一条语句开始执行。", 
            "title": "break语句"
        }, 
        {
            "location": "/ch05 语句/#continue", 
            "text": "continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for, while和do while循环的内部。", 
            "title": "continue语句"
        }, 
        {
            "location": "/ch05 语句/#goto", 
            "text": "goto语句（goto statement）的作用是从goto语句无条件跳转到同一函数内的另一条语句。   my note: 书上建议不要使用goto语句。我认为它应该有其合适的应用场景，只不过对于初学者并不需要。   goto语句的语法形式是：  goto lable:  label是用于标识一条语句的标示符。 带标签的语句 （labeled statement）是一种特殊的语句，在它之前有一个标示符以及一个冒号：  end: return; // 带标签的语句，可以作为goto的目标  标签标示符独立于变量或其他标示符的名字，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。  和switch语句类似，goto语句也不能将程序的控制权从变量的作用域之外转移到作用域之内。  // ...\ngoto end:\n    int ix = 10; // 错误，goto语句绕过了一个带初始化的变量定义\n\nend:\n    // 错误，goto绕过了ix的声明\n    ix = 12;  跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它：  // 向后跳过一个带初始化的变量定义是合法的\nbegin:\n    int sz = get_size();\n    if (sz  = 0)\n        goto begin;", 
            "title": "goto语句"
        }, 
        {
            "location": "/ch05 语句/#try", 
            "text": "异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。  当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时，检测出问题的部分应该发出某种信号以表明程序遇到了故障，无法继续下去了，而信号的发出方无须知道故障将在何处得到解决。  如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。  异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言中，异常处理包括：  -  throw 表达式（throw expression） ，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw 引发（raise） 了异常。  -  try语句块（try block） ，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个 catch子句（catch clause） 结束。try语句块中代码抛出的异常通常会被某个catch子句处理。  - 一套 异常类（exception class） ，用于在throw表达式和相关的catch子句之间传递异常的具体信息。   my note: 编写异常安全的代码非常困难，关于异常安全的概念见书本p175。另外，本书中会介绍一些比较常规的提升异常安全性的技术，但不会详细介绍编写异常处理的代码。", 
            "title": "try语句块和异常处理"
        }, 
        {
            "location": "/ch05 语句/#throw", 
            "text": "抛出异常的一个例子是：  throw runtime_error( Data must refer to same ISBN );  该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。   my note: 书本上有例子的详细解读，见p173。", 
            "title": "throw表达式"
        }, 
        {
            "location": "/ch05 语句/#try_1", 
            "text": "try语句块的通用语法形式是：  try {\n    program-statements\n} catch (exception-declaration) {\n    handler-statements\n} // ...  当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。  try语句块内声明的变量在catch子句内无法访问。  一个简要的例子（摘自书本）：  while (cin   item1   item2) {\n    try {\n        // ... 可能抛出一个异常的代码\n    } catch (runtime_error err) {\n        cout   err.what()    \\nTry Again? Enter y or n    endl;\n        char c;\n        cin   c;\n        if (!cin || c == 'n')\n            break; // 跳出while循环\n    }\n}   my note: 见书本更详细的解读。   函数在寻找处理代码的过程中退出  当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，直到找到适当类型的catch子句为止。  如果最终还是没能找到，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。", 
            "title": "try语句块"
        }, 
        {
            "location": "/ch05 语句/#_7", 
            "text": "C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以用在用户编写的程序中。这些异常类见书本p176。  异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的异常说明。  如果异常类型有一个字符串初始值，则what返回该字符串，否则返回的内容由编译器决定。", 
            "title": "标准异常"
        }, 
        {
            "location": "/ch06 函数_1/", 
            "text": "函数1\n\n\n函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。\n\n\n\n\n函数基础\n\n\n一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。\n\n\n我们通过\n调用运算符（call operator）\n来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。\n\n\n函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，\n主调函数\n（calling function）的执行暂时被中断，\n被调函数\n（called function）开始执行。\n\n\n当遇到一条return语句时函数结束执行过程。函数的返回值用于初始化调用表达式的结果。\n\n\n局部对象\n\n\n在C++语言中，名字有作用域，对象有\n生命周期（lifetime）\n，理解这两个概念非常重要：\n\n\n- 名字的作用域是程序文本的一部分，名字在其中可见。\n- 对象的生命周期是程序执行过程中该对象存在的一段时间。\n\n\n形参和函数体内部定义的变量统称为\n局部变量（local variable）\n。它们仅在函数的作用域内可见。\n\n\n在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。\n\n\n自动对象\n\n\n对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为\n自动对象（automatic object）\n。\n\n\n形参是一种自动对象。函数开始时为形参申请存储空间，函数一旦终止，形参就被销毁。\n\n\n对于局部变量对应的自动对象来说，如果变量定义本身含有初始值，就用这个初始值进行初始化；否则执行默认初始化（内置类型产生未定义的值）。\n\n\n局部静态对象\n\n\n局部静态对象（local static object）\n在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。\n\n\n一个例子（其解释见书本p185）：\n\n\n// 统计函数被调用了多少次\nsize_t count_calls()\n{\n    static size_t ctr = 0; // 调用结束后，这个值仍然有效\n    return ++ctr;\n}\n\n\n\n\n函数返回类型\n\n\n大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何类型。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。\n\n\n函数声明\n\n\n函数的名字必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。\n\n\n函数的声明和定义唯一的区别是声明无须函数体，用一个分号替代即可。\n\n\n函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作\n函数原型（function prototype）\n。\n\n\n在头文件中进行函数声明\n\n\n我们建议函数在头文件中声明，在源文件中定义。\n\n\n这是因为如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明即可。\n\n\n定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。\n\n\n分离式编译\n\n\nC++语言支持所谓的\n分离式编译（separate compilation）\n。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。\n\n\n\n\nmy note: 这部分内容我比较熟悉了，详细解释见书本p186。\n\n\n\n\n参数传递\n\n\n【NOTE】形参初始化的机理与变量初始化一样。\n\n\n如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。\n\n\n当形参是引用类型时，我们说它对应的实参被\n引用传递\n（passed by reference）或者函数被\n传引用调用\n（called by reference）。\n\n\n当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被\n值传递\n（passed by value）或函数被\n传值调用\n（called by value）。\n\n\n传值参数\n\n\n当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。\n\n\n指针形参\n\n\n当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。\n\n\n【BEST PRACTICES】熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参代替指针。\n\n\n传引用参数\n\n\n对于引用的操作实际上是作用于引用所引的对象上，引用形参也是如此。通过使用引用形参，允许函数改变一个或多个实参的值。\n\n\n使用引用避免拷贝\n\n\n拷贝大的类类型对象或者容器对象比较低效。甚至有的类型根本就不支持拷贝操作。此时应该使用引用形参访问该类型的对象。\n\n\n如果函数无须改变引用形参的值，最好将其声明为常量引用。\n\n\n使用引用形参返回额外信息\n\n\n一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。那就是通过引用形参并修改它（也就是修改了其引用的对象），从而作为结果传出。\n\n\nconst形参和实参\n\n\n当形参是const时，必须注意关于顶层const的讨论（p57）。\n\n\n当用实参初始化形参时会忽略形参的顶层const。即当形参有顶层const时，传递给它常量对象或者非常量对象都是可以的。\n\n\n忽略形参的顶层const可能产生意想不到的结果：\n\n\nvoid fcn(const int i) {}\nvoid fcn(int i) {}    // 错误：重复定义\n\n\n\n\n在C++中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表有明显的区别。因为顶层const被忽略了，所以在上面的代码中传入两个fcn函数的参数可以完全一样（从而编译器不知道该调用哪一个）。\n\n\n指针或引用形参与const\n\n\n我们可以使用非常量初始化一个底层const，但是反过来不行（不能用一个常量初始化一个非底层const）；同时一个普通的引用必须用同类型的对象初始化。\n\n\n尽量使用常量引用\n\n\n把函数不会改变的形参定义成（普通的）引用是一种常见错误，这么做给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型（比如无法传入一个常量对象了）。\n\n\n比如下面这个例子将导致编译错误（p192）：\n\n\n// 不良设计，第一个形参的类型应该是const string\n\nstring::size_type find_char(string \ns, char c, string::size_type \noccurs);\n//...\nfind_char(\nHello World\n, 'o', ctr); // 无法编译通过\n\n\n\n\n数组形参\n\n\n当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。\n\n\n尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：\n\n\n// 每个函数都有一个const int*类型的形参\nvoid print(const int*);\nvoid print(const int[]);    // 可以看出来，函数的意图是作用于一个数组\nvoid print(const int[10]);  // 这里的维度表示我们期望数组含有多少元素，实际不一定\n\n\n\n\n【WARNING】和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。\n\n\n因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用技术。\n\n\n1. 使用标记指定数组长度，如C风格字符串。\n\n\n2. 使用标准库规范，如传递首元素和尾后元素的指针，来表示一个范围。\n\n\n3. 显示传递一个表示数组大小的形参。\n\n\n\n\nmy note: 以上技术详细解读见书本p194。\n\n\n\n\n数组形参和const\n\n\n当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。\n\n\n数组引用形参\n\n\nC++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上。\n\n\n// 正确，形参是数组的引用，维度是类型的一部分\nvoid print(int (\narr)[10])\n{\n    for (auto elem : arr)\n        cout \n elem \n endl;\n}\n\n\n\n\n但这一用法也限制了print函数的可用性，我们只能将函数作用于大小为10的数组。\n\n\n传递多维数组\n\n\n和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，也就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：\n\n\n// matrix指向数组的首元素，该数组的元素是由10个整数构成的数组\nvoid print(int (*matrix)[10], int rowSize) { /* ... */ }\n\n\n\n\n也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度：\n\n\n// 等价定义\nvoid print(int matrix[][10], int rowSize) { /* ... */ }\n\n\n\n\nmatrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。\n\n\nmain: 处理命令行选项\n\n\n有时候我们需要给main函数传递实参。一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如：\n\n\nprog -d -o ofile data0\n\n\n\n\n这些命令行选项通过两个（可选的）形参传递给main函数。\n\n\nint main(int argc, char *argv[]) { ... }\n\n\n\n\n第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个参数argc表示数组中字符串的数量。\n\n\n当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。\n\n\n以上面的为例，argc应该等于5，argv应该包含如下的C风格字符串：\n\n\nargv[0] = \nprog\n;    // 或者argv[0]也可以指向一个空字符串\nargv[1] = \n-d\n;\nargv[2] = \n-o\n;\nargv[3] = \nofile\n;\nargv[4] = \ndata0\n;\nargv[5] = 0;\n\n\n\n\n【WARNING】当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入。\n\n\n含有可变形参的函数\n\n\n为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：\n\n\n- 如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；\n\n\n- 如果实参的类型不同，我们可以编写一种可变参数模板，其细节将在16.4节介绍（p618）。\n\n\nC++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只用于与C函数交互的接口程序。\n\n\ninitializer_list形参\n\n\ninitializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中，提供如下操作：\n\n\n\n\ninitializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。\n\n\n省略符形参\n\n\n省略符形参是为了便于C++程序访问某些特殊的C代码而设置的。\n\n\n【WARNING】省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。\n\n\n省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：\n\n\nvoid foo(param_list, ...);\nvoid foo(...);\n\n\n\n\n返回类型和return语句\n\n\nreturn语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。\n\n\nreturn语句有两种形式：\n\n\nreturn;\nreturn expression;\n\n\n\n\n无返回值函数\n\n\n没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。\n\n\n有返回值函数\n\n\n只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。\n\n\n值是如何被返回的\n\n\n返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。\n\n\n如果函数返回引用，则该引用仅是它所引对象的一个别名。\n\n\n不要返回局部对象的引用或指针\n\n\n函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。\n\n\n列表初始化返回值\n\n\nC++11新标准规定，函数可以返回花括号包围的值的列表。此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。\n\n\n主函数main的返回值\n\n\n我们允许main函数没有return语句直接结束，这样编译器将隐式地插入一条返回0的return语句，表示执行成功。\n\n\n为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，可以用来表示成功与失败：\n\n\nint main()\n{\n    if (some_failure)\n        return EXIT_FAILURE;\n    else\n        return EXIT_SUCCESS;\n}\n\n\n\n\n递归\n\n\n如果函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为\n递归函数\n（recursive function）。\n\n\n在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。\n\n\n【NOTE】main函数不能调用它自己。\n\n\n返回数组的指针\n\n\n因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。使用\n类型别名\n（p60）可以简化这种返回类型：\n\n\ntypedef int arrT[10];    // arrT是一个类型别名，表示含有10个整数的数组\nusing arrT = int[10];    // arrT的等价声明\narrT* func(int i);       // func返回一个指向含有10个整数的数组的指针\n\n\n\n\n声明一个返回数组指针的函数\n\n\n形式如下：\n\n\nType (*function(param_list))[dimension]\n\n\n\n\n类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。（*表示返回的是一个指针。）\n\n\n举一个例子：\n\n\nint (*func(int i))[10];\n\n\n\n\n可以按照以下的顺序来逐层理解该声明的含义：\n\n\n- \nfunc(int i)\n表示调用func函数时需要一个int类型的实参。\n\n\n- \n(*func(int i))\n意味着我们可以对函数的调用结果执行解引用操作。\n\n\n- \n(*func(int i))[10]\n表示解引用func的调用将得到一个大小是10的数组。\n\n\n- \nint (*func(int i))[10]\n表示数组中的元素是int类型。\n\n\n使用尾置返回类型\n\n\nC++新标准提供了另一种简化上述func声明的方法，就是使用\n尾置返回类型（trailing return type）\n。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。\n\n\n尾置返回类型跟在形参列表后面并以一个-\n符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：\n\n\n// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组\nauto func(int i) -\n int(*)[10];\n\n\n\n\n使用decltype\n\n\n如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型（即获得一个数组类型）。\n\n\n案例：\n\n\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\n\n// 返回一个指针，该指针指向含有5个整数的数组\ndecltype(odd) *arrPtr(int i)\n{\n    return (i % 2) ? \nodd : \neven;\n}\n\n\n\n\n\n\nmy note: decltype并不负责把数组类型转换成对应的指针。", 
            "title": "函数1"
        }, 
        {
            "location": "/ch06 函数_1/#1", 
            "text": "函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。", 
            "title": "函数1"
        }, 
        {
            "location": "/ch06 函数_1/#_1", 
            "text": "一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。  我们通过 调用运算符（call operator） 来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。  函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时， 主调函数 （calling function）的执行暂时被中断， 被调函数 （called function）开始执行。  当遇到一条return语句时函数结束执行过程。函数的返回值用于初始化调用表达式的结果。", 
            "title": "函数基础"
        }, 
        {
            "location": "/ch06 函数_1/#_2", 
            "text": "在C++语言中，名字有作用域，对象有 生命周期（lifetime） ，理解这两个概念非常重要：  - 名字的作用域是程序文本的一部分，名字在其中可见。\n- 对象的生命周期是程序执行过程中该对象存在的一段时间。  形参和函数体内部定义的变量统称为 局部变量（local variable） 。它们仅在函数的作用域内可见。  在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。  自动对象  对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为 自动对象（automatic object） 。  形参是一种自动对象。函数开始时为形参申请存储空间，函数一旦终止，形参就被销毁。  对于局部变量对应的自动对象来说，如果变量定义本身含有初始值，就用这个初始值进行初始化；否则执行默认初始化（内置类型产生未定义的值）。  局部静态对象  局部静态对象（local static object） 在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。  一个例子（其解释见书本p185）：  // 统计函数被调用了多少次\nsize_t count_calls()\n{\n    static size_t ctr = 0; // 调用结束后，这个值仍然有效\n    return ++ctr;\n}  函数返回类型  大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何类型。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。", 
            "title": "局部对象"
        }, 
        {
            "location": "/ch06 函数_1/#_3", 
            "text": "函数的名字必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。  函数的声明和定义唯一的区别是声明无须函数体，用一个分号替代即可。  函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作 函数原型（function prototype） 。  在头文件中进行函数声明  我们建议函数在头文件中声明，在源文件中定义。  这是因为如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明即可。  定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。", 
            "title": "函数声明"
        }, 
        {
            "location": "/ch06 函数_1/#_4", 
            "text": "C++语言支持所谓的 分离式编译（separate compilation） 。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。   my note: 这部分内容我比较熟悉了，详细解释见书本p186。", 
            "title": "分离式编译"
        }, 
        {
            "location": "/ch06 函数_1/#_5", 
            "text": "【NOTE】形参初始化的机理与变量初始化一样。  如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。  当形参是引用类型时，我们说它对应的实参被 引用传递 （passed by reference）或者函数被 传引用调用 （called by reference）。  当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被 值传递 （passed by value）或函数被 传值调用 （called by value）。", 
            "title": "参数传递"
        }, 
        {
            "location": "/ch06 函数_1/#_6", 
            "text": "当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。  指针形参  当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。  【BEST PRACTICES】熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参代替指针。", 
            "title": "传值参数"
        }, 
        {
            "location": "/ch06 函数_1/#_7", 
            "text": "对于引用的操作实际上是作用于引用所引的对象上，引用形参也是如此。通过使用引用形参，允许函数改变一个或多个实参的值。  使用引用避免拷贝  拷贝大的类类型对象或者容器对象比较低效。甚至有的类型根本就不支持拷贝操作。此时应该使用引用形参访问该类型的对象。  如果函数无须改变引用形参的值，最好将其声明为常量引用。  使用引用形参返回额外信息  一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。那就是通过引用形参并修改它（也就是修改了其引用的对象），从而作为结果传出。", 
            "title": "传引用参数"
        }, 
        {
            "location": "/ch06 函数_1/#const", 
            "text": "当形参是const时，必须注意关于顶层const的讨论（p57）。  当用实参初始化形参时会忽略形参的顶层const。即当形参有顶层const时，传递给它常量对象或者非常量对象都是可以的。  忽略形参的顶层const可能产生意想不到的结果：  void fcn(const int i) {}\nvoid fcn(int i) {}    // 错误：重复定义  在C++中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表有明显的区别。因为顶层const被忽略了，所以在上面的代码中传入两个fcn函数的参数可以完全一样（从而编译器不知道该调用哪一个）。  指针或引用形参与const  我们可以使用非常量初始化一个底层const，但是反过来不行（不能用一个常量初始化一个非底层const）；同时一个普通的引用必须用同类型的对象初始化。  尽量使用常量引用  把函数不会改变的形参定义成（普通的）引用是一种常见错误，这么做给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型（比如无法传入一个常量对象了）。  比如下面这个例子将导致编译错误（p192）：  // 不良设计，第一个形参的类型应该是const string \nstring::size_type find_char(string  s, char c, string::size_type  occurs);\n//...\nfind_char( Hello World , 'o', ctr); // 无法编译通过", 
            "title": "const形参和实参"
        }, 
        {
            "location": "/ch06 函数_1/#_8", 
            "text": "当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。  尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：  // 每个函数都有一个const int*类型的形参\nvoid print(const int*);\nvoid print(const int[]);    // 可以看出来，函数的意图是作用于一个数组\nvoid print(const int[10]);  // 这里的维度表示我们期望数组含有多少元素，实际不一定  【WARNING】和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。  因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用技术。  1. 使用标记指定数组长度，如C风格字符串。  2. 使用标准库规范，如传递首元素和尾后元素的指针，来表示一个范围。  3. 显示传递一个表示数组大小的形参。   my note: 以上技术详细解读见书本p194。   数组形参和const  当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。  数组引用形参  C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上。  // 正确，形参是数组的引用，维度是类型的一部分\nvoid print(int ( arr)[10])\n{\n    for (auto elem : arr)\n        cout   elem   endl;\n}  但这一用法也限制了print函数的可用性，我们只能将函数作用于大小为10的数组。  传递多维数组  和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，也就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：  // matrix指向数组的首元素，该数组的元素是由10个整数构成的数组\nvoid print(int (*matrix)[10], int rowSize) { /* ... */ }  也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度：  // 等价定义\nvoid print(int matrix[][10], int rowSize) { /* ... */ }  matrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。", 
            "title": "数组形参"
        }, 
        {
            "location": "/ch06 函数_1/#main", 
            "text": "有时候我们需要给main函数传递实参。一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如：  prog -d -o ofile data0  这些命令行选项通过两个（可选的）形参传递给main函数。  int main(int argc, char *argv[]) { ... }  第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个参数argc表示数组中字符串的数量。  当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。  以上面的为例，argc应该等于5，argv应该包含如下的C风格字符串：  argv[0] =  prog ;    // 或者argv[0]也可以指向一个空字符串\nargv[1] =  -d ;\nargv[2] =  -o ;\nargv[3] =  ofile ;\nargv[4] =  data0 ;\nargv[5] = 0;  【WARNING】当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入。", 
            "title": "main: 处理命令行选项"
        }, 
        {
            "location": "/ch06 函数_1/#_9", 
            "text": "为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：  - 如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；  - 如果实参的类型不同，我们可以编写一种可变参数模板，其细节将在16.4节介绍（p618）。  C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只用于与C函数交互的接口程序。  initializer_list形参  initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中，提供如下操作：   initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。  省略符形参  省略符形参是为了便于C++程序访问某些特殊的C代码而设置的。  【WARNING】省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。  省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：  void foo(param_list, ...);\nvoid foo(...);", 
            "title": "含有可变形参的函数"
        }, 
        {
            "location": "/ch06 函数_1/#return", 
            "text": "return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。  return语句有两种形式：  return;\nreturn expression;", 
            "title": "返回类型和return语句"
        }, 
        {
            "location": "/ch06 函数_1/#_10", 
            "text": "没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。", 
            "title": "无返回值函数"
        }, 
        {
            "location": "/ch06 函数_1/#_11", 
            "text": "只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。  值是如何被返回的  返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。  如果函数返回引用，则该引用仅是它所引对象的一个别名。  不要返回局部对象的引用或指针  函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。  列表初始化返回值  C++11新标准规定，函数可以返回花括号包围的值的列表。此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。  主函数main的返回值  我们允许main函数没有return语句直接结束，这样编译器将隐式地插入一条返回0的return语句，表示执行成功。  为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，可以用来表示成功与失败：  int main()\n{\n    if (some_failure)\n        return EXIT_FAILURE;\n    else\n        return EXIT_SUCCESS;\n}  递归  如果函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为 递归函数 （recursive function）。  在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。  【NOTE】main函数不能调用它自己。", 
            "title": "有返回值函数"
        }, 
        {
            "location": "/ch06 函数_1/#_12", 
            "text": "因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。使用 类型别名 （p60）可以简化这种返回类型：  typedef int arrT[10];    // arrT是一个类型别名，表示含有10个整数的数组\nusing arrT = int[10];    // arrT的等价声明\narrT* func(int i);       // func返回一个指向含有10个整数的数组的指针  声明一个返回数组指针的函数  形式如下：  Type (*function(param_list))[dimension]  类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。（*表示返回的是一个指针。）  举一个例子：  int (*func(int i))[10];  可以按照以下的顺序来逐层理解该声明的含义：  -  func(int i) 表示调用func函数时需要一个int类型的实参。  -  (*func(int i)) 意味着我们可以对函数的调用结果执行解引用操作。  -  (*func(int i))[10] 表示解引用func的调用将得到一个大小是10的数组。  -  int (*func(int i))[10] 表示数组中的元素是int类型。  使用尾置返回类型  C++新标准提供了另一种简化上述func声明的方法，就是使用 尾置返回类型（trailing return type） 。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。  尾置返回类型跟在形参列表后面并以一个- 符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：  // func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组\nauto func(int i) -  int(*)[10];  使用decltype  如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型（即获得一个数组类型）。  案例：  int odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\n\n// 返回一个指针，该指针指向含有5个整数的数组\ndecltype(odd) *arrPtr(int i)\n{\n    return (i % 2) ?  odd :  even;\n}   my note: decltype并不负责把数组类型转换成对应的指针。", 
            "title": "返回数组的指针"
        }, 
        {
            "location": "/ch06 函数_2/", 
            "text": "函数2\n\n\n\n\n函数重载\n\n\n如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为\n重载（overload）函数\n。比如：\n\n\nvoid print(const char *cp);\nvoid print(const int *beg, const int *end);\nvoid print(const int ia[], size_t size);\n\n\n\n\n这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。\n\n\n函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。\n\n\n【NOTE】main函数不能重载。\n\n\n不允许两个函数除了返回类型以外其他所有的要素都相同。比如：\n\n\nRecord lookup(const Account\n);\nbool lookup(const Account\n);    // 错误，与上一个函数相比只有返回类型不同\n\n\n\n\n\n\nmy note: 返回类型不同的函数，也可以是重载的。只要函数名相同而形参有明显的不同。\n\n\n\n\n重载和const形参\n\n\n顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：\n\n\nRecord lookup(Phone);\nRecord lookup(const Phone);    // 重复声明\n\n\n\n\n如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：\n\n\nRecord lookup(Account\n);       // 此函数作用于Account的引用\nRecord lookup(const Account\n); // 新函数，作用于常量引用\n\n\n\n\n这种情况下，当我们传递一个非常量对象时，编译器会优先选用非常量版本的函数（尽管传给常量版本的也可以）。\n\n\nconst_cast和重载\n\n\nconst_cast在重载函数的情境中最有用。比如这两个重载函数：\n\n\n// 比较两个string对象的长度，返回较短的那个引用\nconst string \nshorterString(const string \ns1, const string \ns2)\n{\n    return s1.size() \n= s2.size() ? s1 : s2; \n}\n\n// 重载\nstring \nshorterString(string \ns1, string \ns2)\n{\n    auto \nr = shorterString(const_cast\nconst string\n(s1), const_cast\nconst string\n(s2));\n    return const_cast\nstring\n(r);\n}\n\n\n\n\n下面重载的版本中，首先将它的实参强制转换成了对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在一个非常量实参上。因此，可以再将其转换回普通的const\n，这显然是安全的。\n\n\n\n\nmy note: 传入非常量的实参将调用非常量的版本。\n\n\n\n\n调用重载的函数\n\n\n定义了一组重载函数后，我们需要以合理的实参调用它们。\n函数匹配（function matching）\n是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。\n\n\n当调用重载函数时有三种可能的结果：\n\n\n- 编译器找到一个与实参\n最佳匹配（best match）\n的函数，并生成调用该函数的代码。\n\n\n- 找不到任何一个函数与调用的实参匹配，此时编译器发出\n无匹配（no match）\n的错误信息。\n\n\n- 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为\n二义性调用（ambiguous call）\n。\n\n\n重载与作用域\n\n\n【WARNING】一般来说，将函数声明置于局部作用域内不是一个明智的选择。\n\n\n如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。对于函数而言也是如此。\n\n\n\n\nmy note: 具体例子可见于书本p210。总之，如果在内层作用域声明了一个函数，那么外层的同名的函数都将变得不可见，因此无法找到外层的重载版本。\n\n\n\n\n特殊用途语言特性\n\n\n默认实参\n\n\n这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的\n默认实参\n（default argument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。如：\n\n\ntypedef string::size_type sz;\nstring screen(sz ht = 24, sz wid = 80, char backrnd = ' ');\n\n\n\n\n一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。\n\n\n使用默认实参调用函数\n\n\n如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。如：\n\n\nstring window;\nwindow = screen();    // 等价于screen(24, 80, ' ');\nwindow = stcreen(66); // 等价于screen(66, 80, ' ');\n\n\n\n\n函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。\n\n\n当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。\n\n\n默认实参初始值\n\n\n局部变量不可以作为默认实参。另外只要表达式的类型可以转换成形参类型，该表达式就可以作为默认实参。\n\n\n如：\n\n\nint g_a = 0;\nvoid f(int a = g_a);\n\n\n\n\n内联函数和constexpr函数\n\n\n调用普通函数比直接写其语句要慢，这是因为调用函数包含一些额外的工作。\n\n\n内联函数可以避免函数调用的开销\n\n\n将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。\n\n\n内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。\n\n\n内联机制用于优化规模小，流程直接，频繁调用的函数。\n\n\nconstexpr函数\n\n\n是指能用于\n常量表达式\n的函数。\n\n\n函数的返回类型及所有形参都得是字面值类型，且函数体内必须有且只有一条return语句。\n\n\n如：\n\n\nconstexpr int new_sz() { return 8; }\nconstexpr int foo = new_sz();\n\n\n\n\nconstexpr函数被隐式地指定为内联函数。\n\n\n把内联函数和constexpr函数放在头文件内\n\n\n这是因为内联函数和constexpr函数可以多次定义，且必须完全一致。所以把它们都定义在头文件内。\n\n\n调试帮助\n\n\n程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。\n\n\nassert预处理宏\n\n\nassert是一种\n预处理宏（preprocessor macro）\n。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：\n\n\nassert(expr);\n\n\n\n\n首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。\n\n\nassert宏定义在cassert头文件中。\n\n\nassert宏常用于检查“不能发生”的条件。（即确实不应该发生的事情，发生了就崩溃吧）\n\n\nNDEBUG预处理变量\n\n\nassert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。\n\n\n我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。或者使用编译器提供的命令行选项定义预处理变量：\n\n\n$ CC -D NDEBUG main.c\n\n\n\n\n这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。\n\n\n我们可以把assert当成调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。\n\n\n除了用于assert，也可以使用NDEBUG编写自己的调试代码。\n\n\n比如：\n\n\nvoid print(const int ia[], size_t size)\n{\n#ifndef NDEBUG\n    // __func__是编译器定义的一个局部静态变量，用于存放函数的名字\n    cerr \n __func__ \n \n: array size is: \n \n size \n endl;\n#endif\n\n// ...\n}\n\n\n\n\n编译器为每个函数都定义了\n__func__\n，除此之外，预处理器还定义了4个对于调试程序很有用的名字：\n\n\n- \n__FILE__\n, 存放文件名的字符串字面值。\n\n\n- \n__LINE__\n, 存放当前行号的整型字面值。\n\n\n- \n__TIME__\n, 存放文件编译时间的字符串字面值。\n\n\n- \n__DATA__\n, 存放文件编译日期的字符串字面值。\n\n\n函数匹配\n\n\n本节(p217)讲述编译器如何确定调用哪个重载函数，并以下述这组函数及其调用为例：\n\n\nvoid f();\nvoid f(int);\nvoid f(int, int);\nvoid f(double, double = 3.14);\nf(5.6);    // 调用void f(double, double);\n\n\n\n\n确定候选函数和可行函数\n\n\n函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数成为\n候选函数（candidate function）\n。候选函数具备两个特征：\n\n\n1. 与被调用函数同名。\n\n\n2. 其声明在调用点可见。\n\n\n第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为\n可行函数（viable function）\n。可行函数也有两个特征：\n\n\n1. 其形参数量与本次调用提供的实参数量相等。\n\n\n2. 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。\n\n\n\n\nmy note: 如果没有找到可行函数，编译器将报告无匹配函数的错误。\n\n\n\n\n寻找最佳匹配（如果有的话）\n\n\n第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。\n\n\n如果有且只有一个函数满足下列条件，则匹配成功：\n\n\n- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。\n\n\n- 至少有一个实参的匹配优于其他可行函数提供的匹配。\n\n\n\n\nmy note: 如果编译器检查了每一个可行函数，没有一个能脱颖而出，则会报告二义性调用错误。\n\n\n\n\n实参类型转换\n\n\n为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：\n\n\n1. 精确匹配，包括以下情况：\n\n\n- 实参类型和形参类型相同。\n\n\n- 实参从数组类型或函数类型转换成对应的指针类型。\n\n\n- 向实参添加顶层const或者从实参中删除顶层const。\n\n\n2. 通过const转换实现的匹配（p143）。\n\n\n3. 通过类型提升实现的匹配（p142）。\n\n\n4. 通过算数类型转换或指针转换实现的匹配（p142）。\n\n\n5. 通过类类型转换实现的匹配（参见14.9节，p514）。\n\n\n\n\nmy note: 详细案例解析见书本p220。\n\n\n\n\n函数指针\n\n\n函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：\n\n\nbool lengthCompare(const string\n, const string\n);\n\n\n\n\n该函数的类型是：\nbool (const string\n, const string\n);\n\n\n要想声明一个指向该函数的指针，只需要将函数名替换成指针即可：\n\n\nbool (*pf)(const string\n, const string\n);\n\n\n\n\n使用函数指针\n\n\n当我们把函数名作为一个值使用的时候，该函数名自动转换成指针（指向该函数的）。\n\n\n例如，可以这样给把函数地址赋值给指针：\n\n\npf = lengthCompare; // pf指向名为lengthCompare的函数\n\npf = \nlengthCompare; // 等价的赋值语句，取地址符是可选的\n\n\n\n\n可以直接对指向函数的指针调用该函数，无须解引用指针：\n\n\nbool b1 = pf(\nHello\n, \nHi\n);\nbool b2 = (*pf)(\nHello\n, \nHi\n); // 等价调用\nbool b3 = lengthCompare(\nHello\n, \nHi\n); // 等价调用\n\n\n\n\n可以给函数指针赋一个nullptr或0，表示没有指向任何函数。\n\n\n重载函数的指针\n\n\n当使用了重载函数时，编译器必须确定一个能和指针类型精确匹配的函数，即返回类型和形参列表都要一样。\n\n\n函数指针形参\n\n\n不能定义函数类型的形参，但是形参可以是指向函数的指针。\n\n\n当把函数名作为实参使用，它会自动转换成指针。\n\n\n定义一个函数（以及指针）类型的方法有：\n\n\n- typedef\n\n\ntypedef bool Func(int); // Func是函数类型\ntypedef bool (*FuncP)(int); // FuncP是函数指针类型\n\n\n\n\n- decltype\n\n\n假如已经有了一个函数：\nbool Foo(int);\n\n\ndecltype(Foo) Func;\ndecltype(Foo) *FuncP;\n\n\n\n\n- using\n\n\nusing Func = bool(int);\nusing FuncP = bool(*)(int);\n\n\n\n\n\n\nmy note: 关于使用直接声明的方法，以及使用尾置返回类型的方法来确定一个返回类型为函数指针的函数，见书本p223。因为我觉得使用上述别名定义已经能满足这种需求了。", 
            "title": "函数2"
        }, 
        {
            "location": "/ch06 函数_2/#2", 
            "text": "", 
            "title": "函数2"
        }, 
        {
            "location": "/ch06 函数_2/#_1", 
            "text": "如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为 重载（overload）函数 。比如：  void print(const char *cp);\nvoid print(const int *beg, const int *end);\nvoid print(const int ia[], size_t size);  这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。  函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。  【NOTE】main函数不能重载。  不允许两个函数除了返回类型以外其他所有的要素都相同。比如：  Record lookup(const Account );\nbool lookup(const Account );    // 错误，与上一个函数相比只有返回类型不同   my note: 返回类型不同的函数，也可以是重载的。只要函数名相同而形参有明显的不同。   重载和const形参  顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：  Record lookup(Phone);\nRecord lookup(const Phone);    // 重复声明  如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：  Record lookup(Account );       // 此函数作用于Account的引用\nRecord lookup(const Account ); // 新函数，作用于常量引用  这种情况下，当我们传递一个非常量对象时，编译器会优先选用非常量版本的函数（尽管传给常量版本的也可以）。  const_cast和重载  const_cast在重载函数的情境中最有用。比如这两个重载函数：  // 比较两个string对象的长度，返回较短的那个引用\nconst string  shorterString(const string  s1, const string  s2)\n{\n    return s1.size()  = s2.size() ? s1 : s2; \n}\n\n// 重载\nstring  shorterString(string  s1, string  s2)\n{\n    auto  r = shorterString(const_cast const string (s1), const_cast const string (s2));\n    return const_cast string (r);\n}  下面重载的版本中，首先将它的实参强制转换成了对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在一个非常量实参上。因此，可以再将其转换回普通的const ，这显然是安全的。   my note: 传入非常量的实参将调用非常量的版本。   调用重载的函数  定义了一组重载函数后，我们需要以合理的实参调用它们。 函数匹配（function matching） 是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。  当调用重载函数时有三种可能的结果：  - 编译器找到一个与实参 最佳匹配（best match） 的函数，并生成调用该函数的代码。  - 找不到任何一个函数与调用的实参匹配，此时编译器发出 无匹配（no match） 的错误信息。  - 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为 二义性调用（ambiguous call） 。", 
            "title": "函数重载"
        }, 
        {
            "location": "/ch06 函数_2/#_2", 
            "text": "【WARNING】一般来说，将函数声明置于局部作用域内不是一个明智的选择。  如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。对于函数而言也是如此。   my note: 具体例子可见于书本p210。总之，如果在内层作用域声明了一个函数，那么外层的同名的函数都将变得不可见，因此无法找到外层的重载版本。", 
            "title": "重载与作用域"
        }, 
        {
            "location": "/ch06 函数_2/#_3", 
            "text": "", 
            "title": "特殊用途语言特性"
        }, 
        {
            "location": "/ch06 函数_2/#_4", 
            "text": "这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的 默认实参 （default argument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。如：  typedef string::size_type sz;\nstring screen(sz ht = 24, sz wid = 80, char backrnd = ' ');  一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。  使用默认实参调用函数  如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。如：  string window;\nwindow = screen();    // 等价于screen(24, 80, ' ');\nwindow = stcreen(66); // 等价于screen(66, 80, ' ');  函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。  当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。  默认实参初始值  局部变量不可以作为默认实参。另外只要表达式的类型可以转换成形参类型，该表达式就可以作为默认实参。  如：  int g_a = 0;\nvoid f(int a = g_a);", 
            "title": "默认实参"
        }, 
        {
            "location": "/ch06 函数_2/#constexpr", 
            "text": "调用普通函数比直接写其语句要慢，这是因为调用函数包含一些额外的工作。  内联函数可以避免函数调用的开销  将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。  内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。  内联机制用于优化规模小，流程直接，频繁调用的函数。  constexpr函数  是指能用于 常量表达式 的函数。  函数的返回类型及所有形参都得是字面值类型，且函数体内必须有且只有一条return语句。  如：  constexpr int new_sz() { return 8; }\nconstexpr int foo = new_sz();  constexpr函数被隐式地指定为内联函数。  把内联函数和constexpr函数放在头文件内  这是因为内联函数和constexpr函数可以多次定义，且必须完全一致。所以把它们都定义在头文件内。", 
            "title": "内联函数和constexpr函数"
        }, 
        {
            "location": "/ch06 函数_2/#_5", 
            "text": "程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。  assert预处理宏  assert是一种 预处理宏（preprocessor macro） 。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：  assert(expr);  首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。  assert宏定义在cassert头文件中。  assert宏常用于检查“不能发生”的条件。（即确实不应该发生的事情，发生了就崩溃吧）  NDEBUG预处理变量  assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。  我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。或者使用编译器提供的命令行选项定义预处理变量：  $ CC -D NDEBUG main.c  这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。  我们可以把assert当成调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。  除了用于assert，也可以使用NDEBUG编写自己的调试代码。  比如：  void print(const int ia[], size_t size)\n{\n#ifndef NDEBUG\n    // __func__是编译器定义的一个局部静态变量，用于存放函数的名字\n    cerr   __func__    : array size is:     size   endl;\n#endif\n\n// ...\n}  编译器为每个函数都定义了 __func__ ，除此之外，预处理器还定义了4个对于调试程序很有用的名字：  -  __FILE__ , 存放文件名的字符串字面值。  -  __LINE__ , 存放当前行号的整型字面值。  -  __TIME__ , 存放文件编译时间的字符串字面值。  -  __DATA__ , 存放文件编译日期的字符串字面值。", 
            "title": "调试帮助"
        }, 
        {
            "location": "/ch06 函数_2/#_6", 
            "text": "本节(p217)讲述编译器如何确定调用哪个重载函数，并以下述这组函数及其调用为例：  void f();\nvoid f(int);\nvoid f(int, int);\nvoid f(double, double = 3.14);\nf(5.6);    // 调用void f(double, double);  确定候选函数和可行函数  函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数成为 候选函数（candidate function） 。候选函数具备两个特征：  1. 与被调用函数同名。  2. 其声明在调用点可见。  第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为 可行函数（viable function） 。可行函数也有两个特征：  1. 其形参数量与本次调用提供的实参数量相等。  2. 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。   my note: 如果没有找到可行函数，编译器将报告无匹配函数的错误。   寻找最佳匹配（如果有的话）  第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。  如果有且只有一个函数满足下列条件，则匹配成功：  - 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。  - 至少有一个实参的匹配优于其他可行函数提供的匹配。   my note: 如果编译器检查了每一个可行函数，没有一个能脱颖而出，则会报告二义性调用错误。", 
            "title": "函数匹配"
        }, 
        {
            "location": "/ch06 函数_2/#_7", 
            "text": "为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：  1. 精确匹配，包括以下情况：  - 实参类型和形参类型相同。  - 实参从数组类型或函数类型转换成对应的指针类型。  - 向实参添加顶层const或者从实参中删除顶层const。  2. 通过const转换实现的匹配（p143）。  3. 通过类型提升实现的匹配（p142）。  4. 通过算数类型转换或指针转换实现的匹配（p142）。  5. 通过类类型转换实现的匹配（参见14.9节，p514）。   my note: 详细案例解析见书本p220。", 
            "title": "实参类型转换"
        }, 
        {
            "location": "/ch06 函数_2/#_8", 
            "text": "函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：  bool lengthCompare(const string , const string );  该函数的类型是： bool (const string , const string );  要想声明一个指向该函数的指针，只需要将函数名替换成指针即可：  bool (*pf)(const string , const string );  使用函数指针  当我们把函数名作为一个值使用的时候，该函数名自动转换成指针（指向该函数的）。  例如，可以这样给把函数地址赋值给指针：  pf = lengthCompare; // pf指向名为lengthCompare的函数\n\npf =  lengthCompare; // 等价的赋值语句，取地址符是可选的  可以直接对指向函数的指针调用该函数，无须解引用指针：  bool b1 = pf( Hello ,  Hi );\nbool b2 = (*pf)( Hello ,  Hi ); // 等价调用\nbool b3 = lengthCompare( Hello ,  Hi ); // 等价调用  可以给函数指针赋一个nullptr或0，表示没有指向任何函数。  重载函数的指针  当使用了重载函数时，编译器必须确定一个能和指针类型精确匹配的函数，即返回类型和形参列表都要一样。  函数指针形参  不能定义函数类型的形参，但是形参可以是指向函数的指针。  当把函数名作为实参使用，它会自动转换成指针。  定义一个函数（以及指针）类型的方法有：  - typedef  typedef bool Func(int); // Func是函数类型\ntypedef bool (*FuncP)(int); // FuncP是函数指针类型  - decltype  假如已经有了一个函数： bool Foo(int);  decltype(Foo) Func;\ndecltype(Foo) *FuncP;  - using  using Func = bool(int);\nusing FuncP = bool(*)(int);   my note: 关于使用直接声明的方法，以及使用尾置返回类型的方法来确定一个返回类型为函数指针的函数，见书本p223。因为我觉得使用上述别名定义已经能满足这种需求了。", 
            "title": "函数指针"
        }, 
        {
            "location": "/ch07 类/", 
            "text": "类\n\n\n类的基本思想是\n数据抽象\n(data abstraction)和\n封装\n(encapsulation)。\n\n\n\n\n数据抽象就是\n接口(interface)与实现(implementation)分离\n的技术。\n\n\n接口就是暴露给用户的操作，比如公有的成员函数。\n\n\n实现就是数据成员、接口的实现、私有的成员函数。\n\n\n通过\n抽象数据类型(abstract data type)\n，来实现数据抽象和封装。\n\n\n\n\nmy note: 在第二章自定义的Sales_data类由于没有实现封装，且没有定义自己的操作，因此不是一个抽象数据类型。后续章节的内容将要对其进行改造使其成为一个抽象数据类型。\n\n\n\n\n定义抽象数据类型\n\n\n封装就是隐藏，抽象数据类型隐藏了自己的成员变量，外部只能使用其接口来间接访问其成员。\n\n\n定义成员函数\n\n\n类内的所有成员必须声明在类的内部。\n\n\n类的成员函数可以定义在类的内部，也可以定义在类的外部。\n\n\n【NOTE】定义在类内部的函数是隐式的inline函数。\n\n\n引入this\n\n\n当调用一个成员函数时，实际上是替某个对象调用它。\n\n\n成员函数通过名为\nthis\n的隐式参数来访问此对象。this指向了此对象的地址。\n\n\n在成员函数内部，可以省略this来访问成员。\n\n\nthis是一个常量指针，不能够修改其值。\n\n\n当成员函数中调用另一个成员函数时，将隐式传递this指针。\n\n\n引入const成员函数\n\n\n参数列表之后，添加const关键字，表明传入的this指针是一个指向常量对象的指针。故此成员函数内，不能修改成员变量的内容。\n\n\nconst对象只能调用const版本的成员函数（因此如果函数不修改成员变量，那么为了提高灵活性，应该把函数声明成const版本的）。\n\n\n类作用域和成员函数\n\n\n类本身就是一个作用域。\n\n\n成员函数的定义必须包含其所属的类名（使用作用域运算符）。\n\n\n如果成员函数声明为const版本的，其定义时，也要在参数列表后加const。\n\n\n成员函数体可以随意使用类中的成员，无须在意成员出现的顺序，这是因为编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。\n\n\n定义一个返回this对象的函数\n\n\n可以使用如下语句返回this对象：\n\n\nreturn *this;\n\n\n\n\n返回类型使用引用类型，表明返回的就是this所指的对象。\n\n\n一般来说，当我们定义的函数类似于某个内置运算符时，应该令函数的行为尽量模仿这个运算符。比如说内置的赋值运算符把它的左侧运算对象当成左值返回，这种情况下，函数就可以返回this对象的引用。（见书本p233的详细讨论）\n\n\n定义类相关的非成员函数\n\n\n有些函数也提供了操作类对象的方法，但他们不属于类的成员函数。\n\n\n可以把这些函数放到类的头文件中声明。这些函数也可以看成是类的接口。\n\n\n有可能会把这些函数声明称友元，从而方便它们直接操作成员变量。\n\n\n构造函数\n\n\n类通过一个或几个特殊的成员函数初始化其成员变量，这些函数叫\n构造函数（constructor）\n。\n\n\n每当类对象被创建，构造函数就会被执行。\n\n\n构造函数名和类名一致，无返回类型，可能有多个（参数个数差异），不能是const的。\n\n\n对于const对象，构造函数执行完毕后，它才获得const属性。\n\n\n合成的默认构造函数\n\n\n如果对象没有初始值，它将执行默认初始化。\n\n\n类通过\n默认构造函数(default constructor)\n来执行默认初始化。如果没有显示定义过构造函数，编译器就会自动生成一个，叫做合成的默认构造函数。\n\n\n合成的默认构造函数根据如下规则初始化类成员：\n\n\n- 如果存在类内初始值，使用它来初始化成员\n\n\n- 否则，对成员执行默认初始化\n\n\n某些类不能依赖合成的默认构造函数\n\n\n所谓不能依赖，就是不可以让编译器生成默认构造函数，要自己定义一个。其原因可能是：\n\n\n- 如果定义了自己的构造函数，那么编译器就不会生成默认的构造函数，此类就没有了默认构造函数。\n\n\n- 默认构造函数可能执行的是错误的操作，比如内置类型若没有类内初始值，则进行默认初始化，其值未定义。\n\n\n- 有时候，编译器无法生成默认构造函数，比如类成员中有类，而此类有可能没有默认构造函数。\n\n\n=default\n\n\nC++11中，使用这种语句来让编译器生成一个默认构造函数：\n\n\nSalesData() = default;\n\n\n\n\n【WARNING】这种情况下，应当对内置类型的数据成员提供类内初始值，否则应当使用构造函数初始值列表形式的默认构造函数。\n\n\n构造函数初始值列表\n\n\n参数列表后，函数体前的一部分内容叫构造函数初始值列表（constructor initialize list）。\n\n\n它负责为对象的成员变量赋初值。\n\n\n如果成员不在初始化列表中，它用类内初始值初始化（如果存在），否则执行默认初始化。\n\n\n拷贝、赋值和析构\n\n\n拷贝构造函数，当初始化变量时以值传递或函数返回一个对象时，会发生拷贝。\n\n\n赋值运算，当使用了赋值运算符时，会发生对象的赋值操作。\n\n\n析构函数，当一个变量不在存在时，会执行析构。\n\n\n这些操作如果不显示定义，编译器就会合成一个，合成的拷贝赋值版本只是做了浅拷贝操作。\n\n\n某些类不能依赖合成的版本\n\n\n如果类中有成员绑定了外部的对象（比如动态内存），那么就不可依赖合成的版本。\n\n\n可使用容器管理必要的存储空间，当发生拷贝等操作时，容器也会执行正确的拷贝。\n\n\n访问控制与封装\n\n\n使用\n访问说明符（access specifiers）\n加强类的封装性。\n\n\n- public说明符之后的成员对外可见，外部可访问，public成员定义类的接口。\n\n\n- private说明符之后的成员对内可见，外部无法访问，即隐藏了实现细节。\n\n\nclass和struct\n\n\n其区别仅仅在于默认的访问权限。class默认为private，struct默认是public。\n\n\n\n\nmy note: 作为接口，应当是public的，而实现细节（数据成员或相关函数）应当为private的。\n\n\n\n\n友元\n\n\n类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。\n\n\n即在函数或类前面加friend关键字。\n\n\n友元声明只能出现在类的内部。它并非函数声明，函数声明还要在别的地方声明。\n\n\n【TIP】一般来说，最好在类定义的开始或结束前的位置集中声明友元。\n\n\n【关键概念：封装的益处】\n\n\n封装有两个重要的优点：\n\n\n- 确保用户代码不会无意间破坏封装对象的状态。\n\n\n- 被封装的类的具体实现可以随时改变，而无须调整用户级别的代码。\n\n\n类的其它特性\n\n\n类成员再探\n\n\n定义一个类型成员\n\n\n可以在类的内部定义一个类型（使用typedef或using），这个类型也有访问限制。\n\n\n通常放在类的开头位置。\n\n\n令成员作为内联函数\n\n\n规模较小的成员函数适合声明成内联函数（定义时在前面加inline即可）。\n\n\n如果定义在类内的函数，默认就是inline的。\n\n\ninline成员函数通常定义到类的头文件中，即声明和定义在同一个文件中。\n\n\n重载成员函数\n\n\n和普通函数的重载规则一样。只要参数的数量or类型有区别，就可以重载。\n\n\n如果是const版本的成员函数（传入const this），那么也可以重载。因为本质上，其隐式参数this的类型改变了。\n\n\n类数据成员的初始值\n\n\n可以给类数据成员一个类内初始值。使用等号或者花括号。\n\n\n返回*this的成员函数\n\n\n返回引用的函数是左值的，意味着这些函数（返回*this）返回的是对象本身而非对象的副本。\n\n\n【NOTE】一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。\n\n\n\n\nmy note: 书本使用一个详细的案例Screen来阐述本节的知识点。见p243。\n\n\n\n\n但是如此一来（const成员函数返回const引用），就无法继续让返回的对象调用非常量版本的成员函数。一个解决的办法就是\n重载一个非常量版本的接口\n，定义一个私有的常量版本的函数，负责具体工作，而非常量版本的接口负责调用它，并返回非常量引用。\n\n\n建议：对于公共代码使用私有功能函数。\n\n\n类类型\n\n\n每个类是一个唯一的类型，即使其内容完全一样。\n\n\n类的声明\n\n\n可以暂时声明类而不定义它，这叫前置声明（forward declaration）。\n\n\n这种类型，在没有定义前是一个不完全类型（incomplete type）。这种类型只能在有限的情况下使用：\n\n\n- 定义指向这种类型的指针or引用\n\n\n- 声明以不完全类型为参数or返回值的函数\n\n\n要创建一个类的对象，则必须已经定义好了这个类，这是因为编译器需要知道类的存储空间大小。\n\n\n只有被定义，才能访问其成员。\n\n\n声明一个前置类型的方法：\n\n\nclass A;\n\nstruct B;\n\nnamespace game\n{\n    class C;    // 前置声明一个在命名空间中的类\n}\n\n\n\n\n友元再探\n\n\n类可以把普通函数定义成友元，也可以把类，类的成员函数定义成友元。\n\n\n友元类有权访问本类的非公有成员。\n\n\n类的作用域\n\n\n一个类就是一个作用域。\n\n\n类的作用域之外，普通的成员只能通过对象、引用or指针访问。对于类型成员的访问，需要使用域运算符\n::\n来访问。\n\n\n名字查找与类的作用域\n\n\n编译器处理完类的全部声明后，才会处理成员函数的定义。因此成员函数体中可以使用类中定义的任何位置的名字。\n\n\n成员函数中的名字查找\n\n\n按如下方式解析：\n\n\n- 在块内查找声明\n\n\n- 在类内查找，所有成员都可以被考虑\n\n\n- 在类的外围作用域中查找\n\n\n构造函数再探\n\n\n构造函数初始值列表\n\n\n如果没有在构造函数的初始值列表中显示初始化成员，那么该成员将执行默认初始化。\n\n\n【NOTE】如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。\n\n\n成员初始化的顺序\n\n\n成员的初始化顺序和它们在类内的定义顺序一致。\n\n\n而非其在初始值列表中的顺序，初始值列表只是做了初始化的工作。所以要让初始值列表中的成员顺序与定义顺序一致。\n\n\n有默认实参的构造函数\n\n\n如果构造函数的所有实参都有默认实参，那么它实际上也同时定义了默认构造函数。\n\n\n委托构造函数\n\n\nC++11可以定义委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数。\n\n\n当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。\n\n\n\n\nmy note: 即先执行受委托的构造函数内容，再执行自己的。\n\n\n\n\n默认构造函数的作用\n\n\n当对象被默认初始化或值初始化时，自动执行默认构造函数。\n\n\n默认构造函数在以下情况发生：\n\n\n- 不使用初始值定义一个非静态变量或者数组时\n\n\n- 当类含有类类型的成员且使用合成的默认构造函数时\n\n\n- 当类类型的成员没有在构造函数初始值列表中显式初始化时\n\n\n值初始化在以下情况下发生：\n\n\n- 数组初始化时，若提供的初始值少于数组大小时\n\n\n- 不使用初始值定义一个局部静态变量时\n\n\n- 书写形如T()的表达式显式请求值初始化时\n\n\n隐式的类类型转换\n\n\n如果构造函数只接受一个实参，则它实际上定义了\n转换构造函数（converting constructor）\n。\n\n\n即定义了一个隐式转换机制。如string的接受一个const char*版本的构造函数。\n\n\n使用explicit阻止这种隐式转换机制，explicit只能放到类内声明构造函数里。\n\n\n聚合类\n\n\n聚合类（aggregate class）使得用户可以直接访问其成员。当类满足如下条件时，是聚合的：\n\n\n- 所有成员都是public的\n\n\n- 没有定义任何构造函数\n\n\n- 没有类内初始值\n\n\n- 没有基类，没有virtual函数\n\n\n可以使用花括号括起来的成员初始值列表来初始化聚合类对象。\n\n\n字面值常量类（ Literal Classes）\n\n\n类也可以是字面值类型。\n\n\n这样的类可以含有constexpr函数成员，且符合constexpr函数的所有要求，且是隐式const的。\n\n\n数据成员都是字面值类型的聚合类是字面值常量类。\n\n\n如果不是聚合类，满足如下条件也是一个字面值常量类：\n\n\n- 数据成员都是字面值类型\n\n\n- 至少含有一个constexpr构造函数\n\n\n- 如果数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；类类型成员必须使用自己的constexpr构造函数\n\n\n- 类必须使用析构函数的默认定义\n\n\n类的静态成员\n\n\n有时候类需要一些只与类相关，而与具体对象无关的特殊成员，这就是静态成员。\n\n\n声明静态成员\n\n\n在声明前加static关键字。\n\n\n静态成员可以是public或private。数据成员可以是常量，引用，指针，类类型等。\n\n\n对象不包含与静态数据成员有关的数据。\n\n\n静态函数不包含this指针。\n\n\n使用类的静态成员\n\n\n使用作用域运算符访问静态成员。\n\n\n类的对象、引用或指针可以访问静态成员。\n\n\n类的成员函数可以直接访问静态成员。\n\n\n定义静态成员\n\n\nstatic只能出现在类的内部，不能出现在外部。\n\n\n静态数据成员不属于类的对象，不是有构造函数初始化的。静态数据成员定义在函数体之外，一旦定义，就一直存在于程序的整个生命周期中。\n\n\ndouble T::a = 1; // 定义并初始化一个静态成员\n\n\n\n\n静态成员的类内初始化\n\n\n通常，不应该在类内初始化静态数据成员。\n\n\n不过，可以为静态成员提供const整数类型的类内初始值。", 
            "title": "ch07 类"
        }, 
        {
            "location": "/ch07 类/#_1", 
            "text": "类的基本思想是 数据抽象 (data abstraction)和 封装 (encapsulation)。   数据抽象就是 接口(interface)与实现(implementation)分离 的技术。  接口就是暴露给用户的操作，比如公有的成员函数。  实现就是数据成员、接口的实现、私有的成员函数。  通过 抽象数据类型(abstract data type) ，来实现数据抽象和封装。   my note: 在第二章自定义的Sales_data类由于没有实现封装，且没有定义自己的操作，因此不是一个抽象数据类型。后续章节的内容将要对其进行改造使其成为一个抽象数据类型。", 
            "title": "类"
        }, 
        {
            "location": "/ch07 类/#_2", 
            "text": "封装就是隐藏，抽象数据类型隐藏了自己的成员变量，外部只能使用其接口来间接访问其成员。  定义成员函数  类内的所有成员必须声明在类的内部。  类的成员函数可以定义在类的内部，也可以定义在类的外部。  【NOTE】定义在类内部的函数是隐式的inline函数。  引入this  当调用一个成员函数时，实际上是替某个对象调用它。  成员函数通过名为 this 的隐式参数来访问此对象。this指向了此对象的地址。  在成员函数内部，可以省略this来访问成员。  this是一个常量指针，不能够修改其值。  当成员函数中调用另一个成员函数时，将隐式传递this指针。  引入const成员函数  参数列表之后，添加const关键字，表明传入的this指针是一个指向常量对象的指针。故此成员函数内，不能修改成员变量的内容。  const对象只能调用const版本的成员函数（因此如果函数不修改成员变量，那么为了提高灵活性，应该把函数声明成const版本的）。  类作用域和成员函数  类本身就是一个作用域。  成员函数的定义必须包含其所属的类名（使用作用域运算符）。  如果成员函数声明为const版本的，其定义时，也要在参数列表后加const。  成员函数体可以随意使用类中的成员，无须在意成员出现的顺序，这是因为编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。  定义一个返回this对象的函数  可以使用如下语句返回this对象：  return *this;  返回类型使用引用类型，表明返回的就是this所指的对象。  一般来说，当我们定义的函数类似于某个内置运算符时，应该令函数的行为尽量模仿这个运算符。比如说内置的赋值运算符把它的左侧运算对象当成左值返回，这种情况下，函数就可以返回this对象的引用。（见书本p233的详细讨论）", 
            "title": "定义抽象数据类型"
        }, 
        {
            "location": "/ch07 类/#_3", 
            "text": "有些函数也提供了操作类对象的方法，但他们不属于类的成员函数。  可以把这些函数放到类的头文件中声明。这些函数也可以看成是类的接口。  有可能会把这些函数声明称友元，从而方便它们直接操作成员变量。", 
            "title": "定义类相关的非成员函数"
        }, 
        {
            "location": "/ch07 类/#_4", 
            "text": "类通过一个或几个特殊的成员函数初始化其成员变量，这些函数叫 构造函数（constructor） 。  每当类对象被创建，构造函数就会被执行。  构造函数名和类名一致，无返回类型，可能有多个（参数个数差异），不能是const的。  对于const对象，构造函数执行完毕后，它才获得const属性。  合成的默认构造函数  如果对象没有初始值，它将执行默认初始化。  类通过 默认构造函数(default constructor) 来执行默认初始化。如果没有显示定义过构造函数，编译器就会自动生成一个，叫做合成的默认构造函数。  合成的默认构造函数根据如下规则初始化类成员：  - 如果存在类内初始值，使用它来初始化成员  - 否则，对成员执行默认初始化  某些类不能依赖合成的默认构造函数  所谓不能依赖，就是不可以让编译器生成默认构造函数，要自己定义一个。其原因可能是：  - 如果定义了自己的构造函数，那么编译器就不会生成默认的构造函数，此类就没有了默认构造函数。  - 默认构造函数可能执行的是错误的操作，比如内置类型若没有类内初始值，则进行默认初始化，其值未定义。  - 有时候，编译器无法生成默认构造函数，比如类成员中有类，而此类有可能没有默认构造函数。  =default  C++11中，使用这种语句来让编译器生成一个默认构造函数：  SalesData() = default;  【WARNING】这种情况下，应当对内置类型的数据成员提供类内初始值，否则应当使用构造函数初始值列表形式的默认构造函数。  构造函数初始值列表  参数列表后，函数体前的一部分内容叫构造函数初始值列表（constructor initialize list）。  它负责为对象的成员变量赋初值。  如果成员不在初始化列表中，它用类内初始值初始化（如果存在），否则执行默认初始化。", 
            "title": "构造函数"
        }, 
        {
            "location": "/ch07 类/#_5", 
            "text": "拷贝构造函数，当初始化变量时以值传递或函数返回一个对象时，会发生拷贝。  赋值运算，当使用了赋值运算符时，会发生对象的赋值操作。  析构函数，当一个变量不在存在时，会执行析构。  这些操作如果不显示定义，编译器就会合成一个，合成的拷贝赋值版本只是做了浅拷贝操作。  某些类不能依赖合成的版本  如果类中有成员绑定了外部的对象（比如动态内存），那么就不可依赖合成的版本。  可使用容器管理必要的存储空间，当发生拷贝等操作时，容器也会执行正确的拷贝。", 
            "title": "拷贝、赋值和析构"
        }, 
        {
            "location": "/ch07 类/#_6", 
            "text": "使用 访问说明符（access specifiers） 加强类的封装性。  - public说明符之后的成员对外可见，外部可访问，public成员定义类的接口。  - private说明符之后的成员对内可见，外部无法访问，即隐藏了实现细节。  class和struct  其区别仅仅在于默认的访问权限。class默认为private，struct默认是public。   my note: 作为接口，应当是public的，而实现细节（数据成员或相关函数）应当为private的。", 
            "title": "访问控制与封装"
        }, 
        {
            "location": "/ch07 类/#_7", 
            "text": "类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。  即在函数或类前面加friend关键字。  友元声明只能出现在类的内部。它并非函数声明，函数声明还要在别的地方声明。  【TIP】一般来说，最好在类定义的开始或结束前的位置集中声明友元。  【关键概念：封装的益处】  封装有两个重要的优点：  - 确保用户代码不会无意间破坏封装对象的状态。  - 被封装的类的具体实现可以随时改变，而无须调整用户级别的代码。", 
            "title": "友元"
        }, 
        {
            "location": "/ch07 类/#_8", 
            "text": "", 
            "title": "类的其它特性"
        }, 
        {
            "location": "/ch07 类/#_9", 
            "text": "定义一个类型成员  可以在类的内部定义一个类型（使用typedef或using），这个类型也有访问限制。  通常放在类的开头位置。  令成员作为内联函数  规模较小的成员函数适合声明成内联函数（定义时在前面加inline即可）。  如果定义在类内的函数，默认就是inline的。  inline成员函数通常定义到类的头文件中，即声明和定义在同一个文件中。  重载成员函数  和普通函数的重载规则一样。只要参数的数量or类型有区别，就可以重载。  如果是const版本的成员函数（传入const this），那么也可以重载。因为本质上，其隐式参数this的类型改变了。  类数据成员的初始值  可以给类数据成员一个类内初始值。使用等号或者花括号。", 
            "title": "类成员再探"
        }, 
        {
            "location": "/ch07 类/#42this", 
            "text": "返回引用的函数是左值的，意味着这些函数（返回*this）返回的是对象本身而非对象的副本。  【NOTE】一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。   my note: 书本使用一个详细的案例Screen来阐述本节的知识点。见p243。   但是如此一来（const成员函数返回const引用），就无法继续让返回的对象调用非常量版本的成员函数。一个解决的办法就是 重载一个非常量版本的接口 ，定义一个私有的常量版本的函数，负责具体工作，而非常量版本的接口负责调用它，并返回非常量引用。  建议：对于公共代码使用私有功能函数。", 
            "title": "返回*this的成员函数"
        }, 
        {
            "location": "/ch07 类/#_10", 
            "text": "每个类是一个唯一的类型，即使其内容完全一样。  类的声明  可以暂时声明类而不定义它，这叫前置声明（forward declaration）。  这种类型，在没有定义前是一个不完全类型（incomplete type）。这种类型只能在有限的情况下使用：  - 定义指向这种类型的指针or引用  - 声明以不完全类型为参数or返回值的函数  要创建一个类的对象，则必须已经定义好了这个类，这是因为编译器需要知道类的存储空间大小。  只有被定义，才能访问其成员。  声明一个前置类型的方法：  class A;\n\nstruct B;\n\nnamespace game\n{\n    class C;    // 前置声明一个在命名空间中的类\n}", 
            "title": "类类型"
        }, 
        {
            "location": "/ch07 类/#_11", 
            "text": "类可以把普通函数定义成友元，也可以把类，类的成员函数定义成友元。  友元类有权访问本类的非公有成员。", 
            "title": "友元再探"
        }, 
        {
            "location": "/ch07 类/#_12", 
            "text": "一个类就是一个作用域。  类的作用域之外，普通的成员只能通过对象、引用or指针访问。对于类型成员的访问，需要使用域运算符 :: 来访问。", 
            "title": "类的作用域"
        }, 
        {
            "location": "/ch07 类/#_13", 
            "text": "编译器处理完类的全部声明后，才会处理成员函数的定义。因此成员函数体中可以使用类中定义的任何位置的名字。  成员函数中的名字查找  按如下方式解析：  - 在块内查找声明  - 在类内查找，所有成员都可以被考虑  - 在类的外围作用域中查找", 
            "title": "名字查找与类的作用域"
        }, 
        {
            "location": "/ch07 类/#_14", 
            "text": "", 
            "title": "构造函数再探"
        }, 
        {
            "location": "/ch07 类/#_15", 
            "text": "如果没有在构造函数的初始值列表中显示初始化成员，那么该成员将执行默认初始化。  【NOTE】如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。  成员初始化的顺序  成员的初始化顺序和它们在类内的定义顺序一致。  而非其在初始值列表中的顺序，初始值列表只是做了初始化的工作。所以要让初始值列表中的成员顺序与定义顺序一致。  有默认实参的构造函数  如果构造函数的所有实参都有默认实参，那么它实际上也同时定义了默认构造函数。", 
            "title": "构造函数初始值列表"
        }, 
        {
            "location": "/ch07 类/#_16", 
            "text": "C++11可以定义委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数。  当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。   my note: 即先执行受委托的构造函数内容，再执行自己的。", 
            "title": "委托构造函数"
        }, 
        {
            "location": "/ch07 类/#_17", 
            "text": "当对象被默认初始化或值初始化时，自动执行默认构造函数。  默认构造函数在以下情况发生：  - 不使用初始值定义一个非静态变量或者数组时  - 当类含有类类型的成员且使用合成的默认构造函数时  - 当类类型的成员没有在构造函数初始值列表中显式初始化时  值初始化在以下情况下发生：  - 数组初始化时，若提供的初始值少于数组大小时  - 不使用初始值定义一个局部静态变量时  - 书写形如T()的表达式显式请求值初始化时", 
            "title": "默认构造函数的作用"
        }, 
        {
            "location": "/ch07 类/#_18", 
            "text": "如果构造函数只接受一个实参，则它实际上定义了 转换构造函数（converting constructor） 。  即定义了一个隐式转换机制。如string的接受一个const char*版本的构造函数。  使用explicit阻止这种隐式转换机制，explicit只能放到类内声明构造函数里。", 
            "title": "隐式的类类型转换"
        }, 
        {
            "location": "/ch07 类/#_19", 
            "text": "聚合类（aggregate class）使得用户可以直接访问其成员。当类满足如下条件时，是聚合的：  - 所有成员都是public的  - 没有定义任何构造函数  - 没有类内初始值  - 没有基类，没有virtual函数  可以使用花括号括起来的成员初始值列表来初始化聚合类对象。", 
            "title": "聚合类"
        }, 
        {
            "location": "/ch07 类/#literal-classes", 
            "text": "类也可以是字面值类型。  这样的类可以含有constexpr函数成员，且符合constexpr函数的所有要求，且是隐式const的。  数据成员都是字面值类型的聚合类是字面值常量类。  如果不是聚合类，满足如下条件也是一个字面值常量类：  - 数据成员都是字面值类型  - 至少含有一个constexpr构造函数  - 如果数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；类类型成员必须使用自己的constexpr构造函数  - 类必须使用析构函数的默认定义", 
            "title": "字面值常量类（ Literal Classes）"
        }, 
        {
            "location": "/ch07 类/#_20", 
            "text": "有时候类需要一些只与类相关，而与具体对象无关的特殊成员，这就是静态成员。  声明静态成员  在声明前加static关键字。  静态成员可以是public或private。数据成员可以是常量，引用，指针，类类型等。  对象不包含与静态数据成员有关的数据。  静态函数不包含this指针。  使用类的静态成员  使用作用域运算符访问静态成员。  类的对象、引用或指针可以访问静态成员。  类的成员函数可以直接访问静态成员。  定义静态成员  static只能出现在类的内部，不能出现在外部。  静态数据成员不属于类的对象，不是有构造函数初始化的。静态数据成员定义在函数体之外，一旦定义，就一直存在于程序的整个生命周期中。  double T::a = 1; // 定义并初始化一个静态成员  静态成员的类内初始化  通常，不应该在类内初始化静态数据成员。  不过，可以为静态成员提供const整数类型的类内初始值。", 
            "title": "类的静态成员"
        }, 
        {
            "location": "/ch08 IO库/", 
            "text": "IO库\n\n\n\n\nIO类\n\n\n为了支持不同种类的IO处理操作，标准库定义了这几种类型：\n\n\n- iostream 定义了用于读写流的基本类型\n\n\n- fstream 定义了读写命名文件的类型\n\n\n- sstream 定义了读写内存string对象的类型\n\n\n它们分别定义在同名的头文件中。\n\n\nIO类型间的关系\n\n\n类型ifstream和istringstream都继承自istream。我们可以像使用istream对象一样来使用它们。对于ostream也是如此。\n\n\nIO对象无拷贝或赋值\n\n\n由于不能拷贝IO对象，因此也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递或返回流。\n\n\n读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。\n\n\n条件状态\n\n\nIO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态。见p279。\n\n\n一个IO错误的例子：\n\n\nint ival;\ncin \n ival;\n\n\n\n\n如果试图在标准输入上键入Boo，读操作就会失败，cin进入错误状态。\n\n\n如果输入一个文件结束符标识，cin也会进入错误状态。\n\n\n一个流一旦发生错误，其上后续的IO操作都会失败。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：\n\n\nwhile (cin \n word)\n    // ok\n\n\n\n\n管理输出缓冲\n\n\n每个输出流都管理一个缓冲区，用来保存程序读写的数据。如果执行下面的代码：\n\n\nos \n \nplease enter a value: \n;\n\n\n\n\n文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。这样可以带来很大的性能提升。\n\n\n导致缓冲区刷新的原因有：\n\n\n- 程序正常结束\n\n\n- 缓冲区满时\n\n\n- 使用操纵符，如endl，来显式刷新缓冲区\n\n\n- 读cin或写cerr，都会导致cout的缓冲区被刷新\n\n\n刷新输出缓冲区\n\n\nIO库还提供了两个操纵符用于刷新缓冲区：\n\n\n- flush 刷新缓冲区，但不输出任何额外字符\n\n\n- ends 向缓冲区插入一个空字符，然后刷新缓冲区\n\n\nunitbuf操纵符\n\n\n如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。\n\n\ncout \n unitbuf;    // 所有输出操作后都会立即刷新缓冲区\ncout \n nounitbuf;  // 回到正常的缓冲方式\n\n\n\n\n【警告】如果程序崩溃，输出缓冲区不会刷新\n\n\n文件输入输出\n\n\n除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。见p283。\n\n\n使用文件流对象\n\n\n当想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。\n\n\n每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。\n\n\n创建文件流对象时，如果提供了一个文件名，则open会被自动调用：\n\n\nifstream in(file);    // 构造一个ifstream并打开给定的文件\nofstream out;         // 输出文件流未关联到任何文件\n\n\n\n\n【NOTE】当一个fstream对象被销毁时，close会自动被调用。\n\n\n文件模式\n\n\n每个流都有一个关联的文件模式，用来指出如何使用文件。见p286。\n\n\n每个文件流类型都定义了一个默认的文件模式，当未制定文件模式时，就使用此默认模式。\n\n\n- 与ifstream关联的文件默认以in模式打开；\n\n\n- 与ofstream关联的文件默认以out模式打开；\n\n\n- 与fstream关联的文件默认以in和out模式打开。\n\n\n以out模式打开文件会丢失已有数据\n\n\n默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。\n\n\n阻止丢弃的方法是同时指定app模式：\n\n\nofstream out(\nfile1\n);    // 文件被截断\nofstream app(\nfile2\n, ofstream::app);    // 保留文件内容，写操作在文件末尾进行\n\n\n\n\nstring流\n\n\nsstream头文件定义了三个类型来支持内存IO：\n\n\n- istringstream从string读取数据。\n\n\n- ostringstream向string写入数据。\n\n\n- stringstream既可以从string读数据，也可以向string写数据。\n\n\nsstream增加了一些成员来管理与流相关联的string。见p287。\n\n\n使用istringstream\n\n\n当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。\n\n\n使用ostringstream\n\n\n当我们逐步构造输出，希望最后一期打印时，ostringstream是很有用的。", 
            "title": "ch08 IO库"
        }, 
        {
            "location": "/ch08 IO库/#io", 
            "text": "", 
            "title": "IO库"
        }, 
        {
            "location": "/ch08 IO库/#io_1", 
            "text": "为了支持不同种类的IO处理操作，标准库定义了这几种类型：  - iostream 定义了用于读写流的基本类型  - fstream 定义了读写命名文件的类型  - sstream 定义了读写内存string对象的类型  它们分别定义在同名的头文件中。  IO类型间的关系  类型ifstream和istringstream都继承自istream。我们可以像使用istream对象一样来使用它们。对于ostream也是如此。", 
            "title": "IO类"
        }, 
        {
            "location": "/ch08 IO库/#io_2", 
            "text": "由于不能拷贝IO对象，因此也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递或返回流。  读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。", 
            "title": "IO对象无拷贝或赋值"
        }, 
        {
            "location": "/ch08 IO库/#_1", 
            "text": "IO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态。见p279。  一个IO错误的例子：  int ival;\ncin   ival;  如果试图在标准输入上键入Boo，读操作就会失败，cin进入错误状态。  如果输入一个文件结束符标识，cin也会进入错误状态。  一个流一旦发生错误，其上后续的IO操作都会失败。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：  while (cin   word)\n    // ok", 
            "title": "条件状态"
        }, 
        {
            "location": "/ch08 IO库/#_2", 
            "text": "每个输出流都管理一个缓冲区，用来保存程序读写的数据。如果执行下面的代码：  os    please enter a value:  ;  文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。这样可以带来很大的性能提升。  导致缓冲区刷新的原因有：  - 程序正常结束  - 缓冲区满时  - 使用操纵符，如endl，来显式刷新缓冲区  - 读cin或写cerr，都会导致cout的缓冲区被刷新  刷新输出缓冲区  IO库还提供了两个操纵符用于刷新缓冲区：  - flush 刷新缓冲区，但不输出任何额外字符  - ends 向缓冲区插入一个空字符，然后刷新缓冲区  unitbuf操纵符  如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。  cout   unitbuf;    // 所有输出操作后都会立即刷新缓冲区\ncout   nounitbuf;  // 回到正常的缓冲方式  【警告】如果程序崩溃，输出缓冲区不会刷新", 
            "title": "管理输出缓冲"
        }, 
        {
            "location": "/ch08 IO库/#_3", 
            "text": "除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。见p283。", 
            "title": "文件输入输出"
        }, 
        {
            "location": "/ch08 IO库/#_4", 
            "text": "当想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。  每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。  创建文件流对象时，如果提供了一个文件名，则open会被自动调用：  ifstream in(file);    // 构造一个ifstream并打开给定的文件\nofstream out;         // 输出文件流未关联到任何文件  【NOTE】当一个fstream对象被销毁时，close会自动被调用。", 
            "title": "使用文件流对象"
        }, 
        {
            "location": "/ch08 IO库/#_5", 
            "text": "每个流都有一个关联的文件模式，用来指出如何使用文件。见p286。  每个文件流类型都定义了一个默认的文件模式，当未制定文件模式时，就使用此默认模式。  - 与ifstream关联的文件默认以in模式打开；  - 与ofstream关联的文件默认以out模式打开；  - 与fstream关联的文件默认以in和out模式打开。  以out模式打开文件会丢失已有数据  默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。  阻止丢弃的方法是同时指定app模式：  ofstream out( file1 );    // 文件被截断\nofstream app( file2 , ofstream::app);    // 保留文件内容，写操作在文件末尾进行", 
            "title": "文件模式"
        }, 
        {
            "location": "/ch08 IO库/#string", 
            "text": "sstream头文件定义了三个类型来支持内存IO：  - istringstream从string读取数据。  - ostringstream向string写入数据。  - stringstream既可以从string读数据，也可以向string写数据。  sstream增加了一些成员来管理与流相关联的string。见p287。", 
            "title": "string流"
        }, 
        {
            "location": "/ch08 IO库/#istringstream", 
            "text": "当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。", 
            "title": "使用istringstream"
        }, 
        {
            "location": "/ch08 IO库/#ostringstream", 
            "text": "当我们逐步构造输出，希望最后一期打印时，ostringstream是很有用的。", 
            "title": "使用ostringstream"
        }, 
        {
            "location": "/ch09 顺序容器/", 
            "text": "顺序容器\n\n\n\n\n顺序容器概览\n\n\n顺序容器有：vector, deque, list, forward_list, array, string。见p292表9.1。\n\n\n所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：\n\n\n- 向容器添加或从元素中删除元素的代价\n\n\n- 非顺序访问容器中元素的代价\n\n\nstring和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在其中间添加或删除元素就会非常耗时，因为这需要移动插入或删除位置之后的所有元素。而且，添加元素可能导致分配额外的存储空间，这种情况下，每个元素都会移动到新的存储空间中。\n\n\nlist和forward_list两个容器添加和删除操作都很快速。作为代价，它们不支持元素的随机访问，为了访问一个元素，只能遍历整个容器。与vector、deque和array相比，这两个容器的额外内存开销也很大。\n\n\nqueue支持快速随机访问，在deque的中间位置插入或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的。\n\n\n确定使用哪种容器\n\n\n【TIP】通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。\n\n\n见书本p293的详细讨论。\n\n\n容器库概览\n\n\n容器类型上的操作形成了一种层次：\n\n\n- 某些操作是通用的，见表9.2，295页。\n\n\n- 某些操作仅针对顺序容器（表9.3，299页）、关联容器（表11.7，388页）或无序容器（表11.8，395页）。\n\n\n- 还有一些操作只适用于一小部分容器。\n\n\n迭代器\n\n\n迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。比如解引用操作。\n\n\n表3.6（96页）列出了容器迭代器支持的所有操作。表3.7（99页）列出了迭代器支持的算术运算，这些运算只能应用于string、vector、deque和array。\n\n\n迭代器范围\n\n\n迭代器范围由一对迭代器表示，通常被称为begin和end，它们标记了容器中元素的一个范围。这个范围被称为左闭合区间：[begin, end)\n\n\n使用左闭合区间蕴含的编程假定\n\n\n假定begin和end构成一个合法的迭代器范围，则：\n\n\n- 如果begin与end相等，则范围为空\n\n\n- 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素\n\n\n- 我们可以对begin递增若干次，使得begin == end\n\n\n容器定义和初始化\n\n\n每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个制定类型的空容器，且都可以指定容器大小和元素初始值的参数。\n\n\n见表9.3，p299。\n\n\n将一个容器初始化为另一个容器的拷贝\n\n\n方法有两种：\n\n\n- 直接拷贝整个容器，两个容器的类型和元素的类型都必须匹配。\n\n\n- 拷贝一个迭代器范围，容器类型不一定匹配，且元素类型只要能够转换即可。\n\n\n赋值和拷贝\n\n\n赋值运算符将其左边容器中的全部元素替换为右边容器中的元素的拷贝。具体见p302。\n\n\n使用assign(仅顺序容器)\n\n\n赋值运算要求两边容器类型和元素类型相同。顺序容器（除了array）还定义了一个名为assign的成员，允许从一个相容的序列中赋值。\n\n\n使用swap\n\n\n调用swap操作后，两个容器中的元素将会交换。\n\n\n除了array，交换两个容器的操作保证会很快，因为元素本身并未交换，swap只是交换了两个容器的内部数据结构。\n\n\n容器大小操作\n\n\n每个容器都支持这些大小相关的操作：\n\n\n- 成员函数size，返回容器中元素的数目，forward_list不支持；\n\n\n- empty，当size为0时返回true，否则返回false；\n\n\n- max_size，返回一个大于或等于该容器所能容纳的最大元素数的值，这是一个很大的值。\n\n\n关系运算符\n\n\n每个容器都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符（\n, \n=, \n, \n=）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。\n\n\n比较两个容器实际上是进行元素的逐对比较。\n\n\n【NOTE】只有当元素类型定义了相应的比较运算符时，才可以使用关系运算符比较两个容器。\n\n\n顺序容器操作\n\n\n顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加及删除。\n\n\n向顺序容器添加元素\n\n\n标准库容器提供了灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。表9.5，p305。\n\n\n【WARNING】向一个deque、string或vector插入元素会使所有指向容器的迭代器、引用和指针失效。\n\n\n【WARNING】将元素插入到deque、string或vector中的任何位置都是合法的。然而，这样做可能很耗时。\n\n\n关键概念：容器元素是拷贝\n\n\n当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝。\n\n\n访问元素\n\n\n表9.6（p310）列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。\n\n\n下标操作和安全的随机访问\n\n\n提供快速随机访问的容器（string、vector、deque和array）也都提供下标运算符。保证下标合法是程序员的责任，编译器不检查越界错误。\n\n\n如果想确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，如果下标越界，at会抛出一个out_of_range异常。\n\n\n删除元素\n\n\n见表9.7，p311页。\n\n\n【WARNING】删除deque中除首尾之外的任何元素都会使所有迭代器、引用、指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。\n\n\n【WARNING】删除元素之前，程序员必须确保它们是存在的。\n\n\n改变容器大小\n\n\n可以使用resize来增大或缩小容器。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部。\n\n\nresize接受一个可选的元素指参数，用来初始化新添加的元素。如果未提供，新元素进行值初始化。\n\n\n容器操作可能使迭代器失效\n\n\n使用失效的迭代器、引用、或指针式一种严重的错误。\n\n\n向容器添加元素后：\n\n\n- 如果容器是vector或string，且存储空间被重新分配，那么所有的迭代器都会失效。如果空间未重新分配，指向插入位置之前的元素的迭代器仍有效，但之后的迭代器会失效。\n\n\n- 对于list和forward_list，指向容器的迭代器仍有效。\n\n\n当从容器中删除元素后：\n\n\n- 对于list和forward_list，指向容器其他位置的迭代器仍有效。\n\n\n- 对于string和vector，被删除元素之前的元素的迭代器仍有效。\n\n\n详细见书本p315。", 
            "title": "ch09 顺序容器"
        }, 
        {
            "location": "/ch09 顺序容器/#_1", 
            "text": "", 
            "title": "顺序容器"
        }, 
        {
            "location": "/ch09 顺序容器/#_2", 
            "text": "顺序容器有：vector, deque, list, forward_list, array, string。见p292表9.1。  所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：  - 向容器添加或从元素中删除元素的代价  - 非顺序访问容器中元素的代价  string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在其中间添加或删除元素就会非常耗时，因为这需要移动插入或删除位置之后的所有元素。而且，添加元素可能导致分配额外的存储空间，这种情况下，每个元素都会移动到新的存储空间中。  list和forward_list两个容器添加和删除操作都很快速。作为代价，它们不支持元素的随机访问，为了访问一个元素，只能遍历整个容器。与vector、deque和array相比，这两个容器的额外内存开销也很大。  queue支持快速随机访问，在deque的中间位置插入或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的。  确定使用哪种容器  【TIP】通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。  见书本p293的详细讨论。", 
            "title": "顺序容器概览"
        }, 
        {
            "location": "/ch09 顺序容器/#_3", 
            "text": "容器类型上的操作形成了一种层次：  - 某些操作是通用的，见表9.2，295页。  - 某些操作仅针对顺序容器（表9.3，299页）、关联容器（表11.7，388页）或无序容器（表11.8，395页）。  - 还有一些操作只适用于一小部分容器。", 
            "title": "容器库概览"
        }, 
        {
            "location": "/ch09 顺序容器/#_4", 
            "text": "迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。比如解引用操作。  表3.6（96页）列出了容器迭代器支持的所有操作。表3.7（99页）列出了迭代器支持的算术运算，这些运算只能应用于string、vector、deque和array。  迭代器范围  迭代器范围由一对迭代器表示，通常被称为begin和end，它们标记了容器中元素的一个范围。这个范围被称为左闭合区间：[begin, end)  使用左闭合区间蕴含的编程假定  假定begin和end构成一个合法的迭代器范围，则：  - 如果begin与end相等，则范围为空  - 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素  - 我们可以对begin递增若干次，使得begin == end", 
            "title": "迭代器"
        }, 
        {
            "location": "/ch09 顺序容器/#_5", 
            "text": "每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个制定类型的空容器，且都可以指定容器大小和元素初始值的参数。  见表9.3，p299。  将一个容器初始化为另一个容器的拷贝  方法有两种：  - 直接拷贝整个容器，两个容器的类型和元素的类型都必须匹配。  - 拷贝一个迭代器范围，容器类型不一定匹配，且元素类型只要能够转换即可。", 
            "title": "容器定义和初始化"
        }, 
        {
            "location": "/ch09 顺序容器/#_6", 
            "text": "赋值运算符将其左边容器中的全部元素替换为右边容器中的元素的拷贝。具体见p302。  使用assign(仅顺序容器)  赋值运算要求两边容器类型和元素类型相同。顺序容器（除了array）还定义了一个名为assign的成员，允许从一个相容的序列中赋值。  使用swap  调用swap操作后，两个容器中的元素将会交换。  除了array，交换两个容器的操作保证会很快，因为元素本身并未交换，swap只是交换了两个容器的内部数据结构。", 
            "title": "赋值和拷贝"
        }, 
        {
            "location": "/ch09 顺序容器/#_7", 
            "text": "每个容器都支持这些大小相关的操作：  - 成员函数size，返回容器中元素的数目，forward_list不支持；  - empty，当size为0时返回true，否则返回false；  - max_size，返回一个大于或等于该容器所能容纳的最大元素数的值，这是一个很大的值。", 
            "title": "容器大小操作"
        }, 
        {
            "location": "/ch09 顺序容器/#_8", 
            "text": "每个容器都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符（ ,  =,  ,  =）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。  比较两个容器实际上是进行元素的逐对比较。  【NOTE】只有当元素类型定义了相应的比较运算符时，才可以使用关系运算符比较两个容器。", 
            "title": "关系运算符"
        }, 
        {
            "location": "/ch09 顺序容器/#_9", 
            "text": "顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加及删除。", 
            "title": "顺序容器操作"
        }, 
        {
            "location": "/ch09 顺序容器/#_10", 
            "text": "标准库容器提供了灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。表9.5，p305。  【WARNING】向一个deque、string或vector插入元素会使所有指向容器的迭代器、引用和指针失效。  【WARNING】将元素插入到deque、string或vector中的任何位置都是合法的。然而，这样做可能很耗时。  关键概念：容器元素是拷贝  当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝。", 
            "title": "向顺序容器添加元素"
        }, 
        {
            "location": "/ch09 顺序容器/#_11", 
            "text": "表9.6（p310）列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。  下标操作和安全的随机访问  提供快速随机访问的容器（string、vector、deque和array）也都提供下标运算符。保证下标合法是程序员的责任，编译器不检查越界错误。  如果想确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，如果下标越界，at会抛出一个out_of_range异常。", 
            "title": "访问元素"
        }, 
        {
            "location": "/ch09 顺序容器/#_12", 
            "text": "见表9.7，p311页。  【WARNING】删除deque中除首尾之外的任何元素都会使所有迭代器、引用、指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。  【WARNING】删除元素之前，程序员必须确保它们是存在的。", 
            "title": "删除元素"
        }, 
        {
            "location": "/ch09 顺序容器/#_13", 
            "text": "可以使用resize来增大或缩小容器。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部。  resize接受一个可选的元素指参数，用来初始化新添加的元素。如果未提供，新元素进行值初始化。", 
            "title": "改变容器大小"
        }, 
        {
            "location": "/ch09 顺序容器/#_14", 
            "text": "使用失效的迭代器、引用、或指针式一种严重的错误。  向容器添加元素后：  - 如果容器是vector或string，且存储空间被重新分配，那么所有的迭代器都会失效。如果空间未重新分配，指向插入位置之前的元素的迭代器仍有效，但之后的迭代器会失效。  - 对于list和forward_list，指向容器的迭代器仍有效。  当从容器中删除元素后：  - 对于list和forward_list，指向容器其他位置的迭代器仍有效。  - 对于string和vector，被删除元素之前的元素的迭代器仍有效。  详细见书本p315。", 
            "title": "容器操作可能使迭代器失效"
        }, 
        {
            "location": "/ch10 泛型算法/", 
            "text": "泛型算法\n\n\n标准库并未给每个容器都定义成员函数来实现一些特殊的操作，如查找元素、替换或删除元素、重排元素等。而是定义了一组泛型算法。它们实现了一些经典算法的公共接口，可以用于不同类型的元素和多种容器类型，包括内置的数组类型。\n\n\n\n\n概述\n\n\n大多数算法定义在头文件algorithm中，头文件numeric中定义了一组数值泛型算法。\n\n\n通常，算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。\n\n\n算法不依赖于容器，但依赖于元素类型的操作。比如，find用元素类型的==运算符完成序列中的元素与给定值的比较。大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符（即使用谓词）。\n\n\n初识泛型算法\n\n\n附录A按照操作方式列出了所有的算法。\n\n\n除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。\n\n\n理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。\n\n\n只读算法\n\n\n一些算法只会读取其输入范围内的元素，而从不改变元素。比如find。\n\n\n操作两个序列的算法\n\n\n举一个列子：equal算法，它比较两个序列中的元素。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素：\n\n\n// roster2中的元素数目应该至少与roster1一样多\nequal(roster1.cbegin(), roster1.cend(), roster2.cbegin());\n\n\n\n\n这样的算法基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。\n\n\n写容器元素的算法\n\n\n一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入元素数目（note：如容器大小足够）。\n\n\n这样的算法比如fill。\n\n\n介绍back_inserter\n\n\n一种保证算法有足够元素空间来容纳输出数据的方法是使用\n插入迭代器\n（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。\n\n\n重排元素的算法\n\n\n某些算法会重排容器中元素的顺序，比如sort，它利用元素类型的\n运算符来实现排序。\n\n\n定义操作\n\n\n很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的\n或==运算符完成比较。标准库为这些算法定义了额外的版本，允许我们提供自己定义的操作来替代默认运算符。\n\n\n向算法传递函数\n\n\nsort接受第三个参数，此参数是一个谓词（predicate）。\n\n\n谓词\n\n\n谓词是一个可调用的表达式，其调用结果是一个能用作条件的值。标准库算法使用的谓词分为两类：\n\n\n- 一元谓词，意味着它们只接受单一参数\n\n\n- 二元谓词，意味着它们有两个参数\n\n\n接受谓词的算法对输入序列中的元素调用谓词。\n\n\nlambda表达式\n\n\n我们传递给算法的谓词必须严格接受一个或两个参数，但是有时我们希望进行的操作需要更多的参数，超出了算法对谓词的限制。\n\n\n介绍lambda\n\n\n我们可以向一个算法传递任何类别的可调用对象，对于一个对象或一个表达式，如果可以对其使用可调用运算符，则称它为可调用的。\n\n\n一个lambda表达式表示一个可调用的代码单元。可以将其理解为一个未命名的内联函数。一个lambda表达式具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可以定义在函数内部。\n\n\n一个lambda表达式具有如下形式：\n\n\n[capture list](parameter list) -\n return type { function body }\n\n\n\n\n其中，capture list是一个lambda所在函数中定义的局部变量的列表。\n\n\n可以忽略返回类型，这时会自动推断返回类型。\n\n\nauto func = [](){ return 42; };\n\n\n\n\nlambda捕获和返回\n\n\n当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象。类似地，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。\n\n\n默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。\n\n\n变量捕获的方式可以是值或引用。值捕获是变量的拷贝，引用捕获是变量的引用。\n\n\n【WARNING】当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。\n\n\n建议：\n尽量保持lambda的变量捕获简单化。如果可能的话，应该避免捕获指针或引用。见p351。\n\n\n隐式捕获\n\n\n可以让编译器根据lambda体中的代码来推断要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个\n或=。\n告诉编译器采用捕获引用方式，=则表示采用值捕获方式。\n\n\n如：\n\n\n// sz为隐式捕获，值捕获方式\nwc = find_if(words.begin(), words.end(),\n             [=](const string \ns) { return s.size() \n= sz; } );\n\n\n\n\n详见lambda捕获列表，p352。\n\n\n可变lambda\n\n\n默认情况下，对于一个值拷贝的变量，lambda不会改变其值。如果希望改变，必须在参数列表后加上关键字mutable。\n\n\nvoid fcn3()\n{\n    size_t v1 = 42;\n    // f可以改变它捕获的变量的值\n    auto f = [v1]() mutable { return ++v1; };\n    v1 = 0;\n    auto j = f(); // j为43\n}\n\n\n\n\n参数绑定\n\n\n对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果需要在很多地方使用相同的操作，或者一个操作需要很多语句完成，通常应该定义一个函数。\n\n\n如果lambda的捕获列表为空，通常可以用函数来代替它。但如果捕获列表不为空就不能直接代替了。\n\n\n标准库bind函数\n\n\n为了解决这个问题，可以使用一个新的名为bind的标准库函数，它定义在头文件functional中。它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。\n\n\nauto newCallable = bind(callable, arg_list);\n\n\n\n\nnewCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。\n\n\narg_list中的参数可能包含形如\n_n\n的名字，这些参数是“占位符”，表示newCallable的参数。比如：\n_1\n为newCallable的第一个参数，\n_2\n为第二个参数。\n\n\n使用placeholders名字\n\n\n名字\n_n\n都定义在一个名为placeholders的命名空间中，这个命名空间本身定义在std命名空间中。\n\n\n一种简单的using语句是：\n\n\nusing namespace namespace_name;\n\n\n\n\n这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。如：\n\n\nusing namespace std::placeholders;\n\n\n\n\n这使得placeholders定义的所有名字都可用。\n\n\n再探迭代器\n\n\n除了每个容器的迭代器，标准库在头文件iterator中还定义了额外几种迭代器。\n\n\n- 插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素。\n\n\n- 流迭代器：这些迭代器被绑定到输入或输出流上，可以来遍历所关联的IO流。\n\n\n- 反向迭代器：这些迭代器向后而不是向前移动。\n\n\n- 移动迭代器：不拷贝其中的元素，而是移动它们。将在13.6.2节（p480页）介绍。\n\n\n插入迭代器\n\n\n插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。\n\n\nit = t; // 在it指定的当前位置插入值t。\n\n\n\n\n插入迭代器有三种类型，差异在于元素插入的位置：\n\n\n- back_inserter，创建一个使用push_back的迭代器。\n\n\n- front_inserter，创建一个使用push_front的迭代器。\n\n\n- inserter，创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。\n\n\niostream迭代器\n\n\nistream_iterator读取输入流，ostream_iterator向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。\n\n\n通过使用流迭代器，我们可以使用泛型算法从流对象读取数据以及向其写入数据。\n\n\n详细操作见p359。\n\n\n反向迭代器\n\n\n反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。\n\n\n可以通过rbegin, rend, crbegin, crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。\n\n\n泛型算法结构\n\n\n任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别。\n\n\n\n\n\n\n\n\n迭代器\n\n\n要求\n\n\n\n\n\n\n\n\n\n\n输入迭代器\n\n\n只读，不写；单遍扫描，只能递增\n\n\n\n\n\n\n输出迭代器\n\n\n只写，不读；单遍扫描，只能递增\n\n\n\n\n\n\n前向迭代器\n\n\n可读写；多遍扫描，只能递增\n\n\n\n\n\n\n双向迭代器\n\n\n可读写；多遍扫描，可递增递减\n\n\n\n\n\n\n随机访问迭代器\n\n\n可读写，多遍扫描，支持全部迭代器运算\n\n\n\n\n\n\n\n\n5类迭代器\n\n\n类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另一些只有特定类别的迭代器才支持。\n\n\n如ostream_iterator只支持递增、解引用和赋值。vector、string、deque的迭代器除了这些操作，还支持递减、关系和算术运算。\n\n\n除了输出迭代器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。\n\n\n算法的形参模式\n\n\n大多数算法具有如下4种形式之一：\n\n\nalg(beg, end, other args);\nalg(beg, end, dest, other args);\nalg(beg, end, beg2, other args);\nalg(beg, end, beg2, end2, other args);\n\n\n\n\n其中，alg是算法名字，beg和end表述输入范围。几乎所有算法都有一个输入范围。\n\n\n接受单个目标迭代器的算法\n\n\ndest参数是一个表示算法可以写入目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。\n\n\n一般dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因为保证空间是足够的。\n\n\n接受第二个输入序列的算法\n\n\n接受beg2或beg2和end2的算法用这些迭代器表示第二个输入范围。\n\n\n接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。\n\n\n算法命名规范\n\n\n除了参数规范，算法还遵循一套命名和重载规范。\n\n\n一些算法使用重载形式传递一个谓词\n\n\n函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外的谓词参数，来代替\n或==：\n\n\nunique(beg, end);\nunique(beg, end, comp);\n\n\n\n\n_if版本的算法\n\n\n接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的_if前缀：\n\n\nfind(beg, end, val);\nfind_if(beg, end, pred);\n\n\n\n\n区分拷贝元素的版本和不拷贝的版本\n\n\n默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。\n\n\nreverse(beg, end);\nreverse_copy(beg, end, dest);\n\n\n\n\n特定容器的算法\n\n\n链表类型list定义了几个成员函数形式的算法。通用版本的sort要求随机访问迭代器，因此不能用于list。\n\n\n链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。\n\n\n这些算法见p369。", 
            "title": "ch10 泛型算法"
        }, 
        {
            "location": "/ch10 泛型算法/#_1", 
            "text": "标准库并未给每个容器都定义成员函数来实现一些特殊的操作，如查找元素、替换或删除元素、重排元素等。而是定义了一组泛型算法。它们实现了一些经典算法的公共接口，可以用于不同类型的元素和多种容器类型，包括内置的数组类型。", 
            "title": "泛型算法"
        }, 
        {
            "location": "/ch10 泛型算法/#_2", 
            "text": "大多数算法定义在头文件algorithm中，头文件numeric中定义了一组数值泛型算法。  通常，算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。  算法不依赖于容器，但依赖于元素类型的操作。比如，find用元素类型的==运算符完成序列中的元素与给定值的比较。大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符（即使用谓词）。", 
            "title": "概述"
        }, 
        {
            "location": "/ch10 泛型算法/#_3", 
            "text": "附录A按照操作方式列出了所有的算法。  除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。  理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。", 
            "title": "初识泛型算法"
        }, 
        {
            "location": "/ch10 泛型算法/#_4", 
            "text": "一些算法只会读取其输入范围内的元素，而从不改变元素。比如find。  操作两个序列的算法  举一个列子：equal算法，它比较两个序列中的元素。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素：  // roster2中的元素数目应该至少与roster1一样多\nequal(roster1.cbegin(), roster1.cend(), roster2.cbegin());  这样的算法基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。", 
            "title": "只读算法"
        }, 
        {
            "location": "/ch10 泛型算法/#_5", 
            "text": "一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入元素数目（note：如容器大小足够）。  这样的算法比如fill。  介绍back_inserter  一种保证算法有足够元素空间来容纳输出数据的方法是使用 插入迭代器 （insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。", 
            "title": "写容器元素的算法"
        }, 
        {
            "location": "/ch10 泛型算法/#_6", 
            "text": "某些算法会重排容器中元素的顺序，比如sort，它利用元素类型的 运算符来实现排序。", 
            "title": "重排元素的算法"
        }, 
        {
            "location": "/ch10 泛型算法/#_7", 
            "text": "很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的 或==运算符完成比较。标准库为这些算法定义了额外的版本，允许我们提供自己定义的操作来替代默认运算符。", 
            "title": "定义操作"
        }, 
        {
            "location": "/ch10 泛型算法/#_8", 
            "text": "sort接受第三个参数，此参数是一个谓词（predicate）。  谓词  谓词是一个可调用的表达式，其调用结果是一个能用作条件的值。标准库算法使用的谓词分为两类：  - 一元谓词，意味着它们只接受单一参数  - 二元谓词，意味着它们有两个参数  接受谓词的算法对输入序列中的元素调用谓词。", 
            "title": "向算法传递函数"
        }, 
        {
            "location": "/ch10 泛型算法/#lambda", 
            "text": "我们传递给算法的谓词必须严格接受一个或两个参数，但是有时我们希望进行的操作需要更多的参数，超出了算法对谓词的限制。  介绍lambda  我们可以向一个算法传递任何类别的可调用对象，对于一个对象或一个表达式，如果可以对其使用可调用运算符，则称它为可调用的。  一个lambda表达式表示一个可调用的代码单元。可以将其理解为一个未命名的内联函数。一个lambda表达式具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可以定义在函数内部。  一个lambda表达式具有如下形式：  [capture list](parameter list) -  return type { function body }  其中，capture list是一个lambda所在函数中定义的局部变量的列表。  可以忽略返回类型，这时会自动推断返回类型。  auto func = [](){ return 42; };", 
            "title": "lambda表达式"
        }, 
        {
            "location": "/ch10 泛型算法/#lambda_1", 
            "text": "当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象。类似地，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。  默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。  变量捕获的方式可以是值或引用。值捕获是变量的拷贝，引用捕获是变量的引用。  【WARNING】当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。  建议： 尽量保持lambda的变量捕获简单化。如果可能的话，应该避免捕获指针或引用。见p351。  隐式捕获  可以让编译器根据lambda体中的代码来推断要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个 或=。 告诉编译器采用捕获引用方式，=则表示采用值捕获方式。  如：  // sz为隐式捕获，值捕获方式\nwc = find_if(words.begin(), words.end(),\n             [=](const string  s) { return s.size()  = sz; } );  详见lambda捕获列表，p352。  可变lambda  默认情况下，对于一个值拷贝的变量，lambda不会改变其值。如果希望改变，必须在参数列表后加上关键字mutable。  void fcn3()\n{\n    size_t v1 = 42;\n    // f可以改变它捕获的变量的值\n    auto f = [v1]() mutable { return ++v1; };\n    v1 = 0;\n    auto j = f(); // j为43\n}", 
            "title": "lambda捕获和返回"
        }, 
        {
            "location": "/ch10 泛型算法/#_9", 
            "text": "对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果需要在很多地方使用相同的操作，或者一个操作需要很多语句完成，通常应该定义一个函数。  如果lambda的捕获列表为空，通常可以用函数来代替它。但如果捕获列表不为空就不能直接代替了。  标准库bind函数  为了解决这个问题，可以使用一个新的名为bind的标准库函数，它定义在头文件functional中。它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。  auto newCallable = bind(callable, arg_list);  newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。  arg_list中的参数可能包含形如 _n 的名字，这些参数是“占位符”，表示newCallable的参数。比如： _1 为newCallable的第一个参数， _2 为第二个参数。  使用placeholders名字  名字 _n 都定义在一个名为placeholders的命名空间中，这个命名空间本身定义在std命名空间中。  一种简单的using语句是：  using namespace namespace_name;  这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。如：  using namespace std::placeholders;  这使得placeholders定义的所有名字都可用。", 
            "title": "参数绑定"
        }, 
        {
            "location": "/ch10 泛型算法/#_10", 
            "text": "除了每个容器的迭代器，标准库在头文件iterator中还定义了额外几种迭代器。  - 插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素。  - 流迭代器：这些迭代器被绑定到输入或输出流上，可以来遍历所关联的IO流。  - 反向迭代器：这些迭代器向后而不是向前移动。  - 移动迭代器：不拷贝其中的元素，而是移动它们。将在13.6.2节（p480页）介绍。", 
            "title": "再探迭代器"
        }, 
        {
            "location": "/ch10 泛型算法/#_11", 
            "text": "插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。  it = t; // 在it指定的当前位置插入值t。  插入迭代器有三种类型，差异在于元素插入的位置：  - back_inserter，创建一个使用push_back的迭代器。  - front_inserter，创建一个使用push_front的迭代器。  - inserter，创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。", 
            "title": "插入迭代器"
        }, 
        {
            "location": "/ch10 泛型算法/#iostream", 
            "text": "istream_iterator读取输入流，ostream_iterator向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。  通过使用流迭代器，我们可以使用泛型算法从流对象读取数据以及向其写入数据。  详细操作见p359。", 
            "title": "iostream迭代器"
        }, 
        {
            "location": "/ch10 泛型算法/#_12", 
            "text": "反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。  可以通过rbegin, rend, crbegin, crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。", 
            "title": "反向迭代器"
        }, 
        {
            "location": "/ch10 泛型算法/#_13", 
            "text": "任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别。     迭代器  要求      输入迭代器  只读，不写；单遍扫描，只能递增    输出迭代器  只写，不读；单遍扫描，只能递增    前向迭代器  可读写；多遍扫描，只能递增    双向迭代器  可读写；多遍扫描，可递增递减    随机访问迭代器  可读写，多遍扫描，支持全部迭代器运算", 
            "title": "泛型算法结构"
        }, 
        {
            "location": "/ch10 泛型算法/#5", 
            "text": "类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另一些只有特定类别的迭代器才支持。  如ostream_iterator只支持递增、解引用和赋值。vector、string、deque的迭代器除了这些操作，还支持递减、关系和算术运算。  除了输出迭代器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。", 
            "title": "5类迭代器"
        }, 
        {
            "location": "/ch10 泛型算法/#_14", 
            "text": "大多数算法具有如下4种形式之一：  alg(beg, end, other args);\nalg(beg, end, dest, other args);\nalg(beg, end, beg2, other args);\nalg(beg, end, beg2, end2, other args);  其中，alg是算法名字，beg和end表述输入范围。几乎所有算法都有一个输入范围。  接受单个目标迭代器的算法  dest参数是一个表示算法可以写入目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。  一般dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因为保证空间是足够的。  接受第二个输入序列的算法  接受beg2或beg2和end2的算法用这些迭代器表示第二个输入范围。  接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。", 
            "title": "算法的形参模式"
        }, 
        {
            "location": "/ch10 泛型算法/#_15", 
            "text": "除了参数规范，算法还遵循一套命名和重载规范。  一些算法使用重载形式传递一个谓词  函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外的谓词参数，来代替 或==：  unique(beg, end);\nunique(beg, end, comp);  _if版本的算法  接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的_if前缀：  find(beg, end, val);\nfind_if(beg, end, pred);  区分拷贝元素的版本和不拷贝的版本  默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。  reverse(beg, end);\nreverse_copy(beg, end, dest);", 
            "title": "算法命名规范"
        }, 
        {
            "location": "/ch10 泛型算法/#_16", 
            "text": "链表类型list定义了几个成员函数形式的算法。通用版本的sort要求随机访问迭代器，因此不能用于list。  链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。  这些算法见p369。", 
            "title": "特定容器的算法"
        }, 
        {
            "location": "/ch11 关联容器/", 
            "text": "关联容器\n\n\n\n\n关联容器与顺序容器有着根本的不同：\n\n\n- 关联容器中的元素是按关键字来保存和访问的。\n\n\n- 顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。\n\n\n关联容器支持高效的关键字查找和访问，有两个主要的关联容器：\n\n\n- map，其元素是一些关键字-值对，关键字起到索引作用，值则表示与之相关的数据。\n\n\n- set，每个元素只包含一个关键字。\n\n\n使用关联容器\n\n\nmap是关键字-值对的集合，通常被称为关联数组。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。\n\n\nset就是关键字的简单集合。\n\n\n具体使用案例见书本p375。\n\n\n关联容器概述\n\n\n关联容器（有序的和无序的）都支持9.2节（第294页）中介绍的普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如push_front。\n\n\n除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作（见p388）和类型别名（见p381）。\n\n\n关联容器的迭代器都是双向的。\n\n\n定义关联容器\n\n\nmap\nstring, size_t\n word_count; // 空容器\nset\nstring\n exclude = {\nthe\n, \nbut\n, \nand\n}; // 列表初始化\n\n// 三个元素；authors将姓映射为名\nmap\nstring, string\n authors = {\n    {\nJoyce\n, \nJames\n},\n    {\nAusten\n, \nJane\n},\n    {\nDickens\n, \nCharles\n}\n};\n\n\n\n\n初始化multimap或multiset\n\n\n一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。\n\n\nmultimap和multiset没有此限制，它们都允许多个元素具有相同的关键字（这些元素会相邻存储）。\n\n\n关键字类型的要求\n\n\n对于有序容器，关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的\n运算符来比较两个关键字。\n\n\n使用关键字类型的比较函数\n\n\n用来阻止一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型（比如一个函数指针类型）。\n\n\nbool compareIsbn(const Sales_data \nlhs, const Sales_data \nrhs)\n{\n    return lhs.isbn() \n rhs.isbn();\n}\n\nmultiset\nSales_data, decltype(compareIsbn*\n bookstore(compareIsbn);\n\n\n\n\npair类型\n\n\npair类型定义在头文件utility中。\n\n\n一个pair保存两个数据成员，pair是一个用来生成特定类型的模板。\n\n\npair\nstring, string\n anon; // 保存两个string\npair\nstring, vector\nint\n line; // 保存string和vector\nint\n\n\n\n\n\npair的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器：\n\n\npair\nstring, string\n author{\nJames\n, \nJoyce\n};\n\n\n\n\npair的数据成员是public的，两个成员分别是first，second。\n\n\n创建pair对象的函数\n\n\npair\nstring, int\n\nprocess(vector\nstring\n \nv)\n{\n    // 处理v\n    if (!v.empty())\n        return {v.back(), v.back().size()}; // 列表初始化\n    else\n        return pair\nstring, int\n(); // 隐式构造返回值\n}\n\n\n\n\n关联容器操作\n\n\n除了表9.2(第295页)中列出的类型，关联容器还定义了这些类型：\n\n\n- key_type, 此容器类型的关键字类型\n\n\n- mapped_type, 每个关键字关联的类型，只适用于map\n\n\n- value_type, 对于set，与key_type相同，对于map, 为\npair\nconst key_type, mapped_type\n\n\n关联容器迭代器\n\n\n当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型。\n\n\n【NOTE】必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值。\n\n\nset的迭代器是const的\n\n\n与不能改名map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改。\n\n\n遍历关联容器\n\n\nmap和set类型都支持begin和end操作，我们可以利用这些函数获取迭代器，然后用迭代器来遍历容器。\n\n\nauto map_it = word_count.cbegin();\nwhile (map_it != word_count.cend()) {\n    // ...\n    ++map_it; // 递增迭代器，移动到下一个元素\n}\n\n\n\n\n【NOTE】当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。\n\n\n关联容器和算法\n\n\n我们通常不对关联容器使用泛型算法。更多讨论见书本p383。\n\n\n添加元素\n\n\n关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。\n\n\n向map添加元素\n\n\n对一个map进行insert操作时，必须记住元素类型是pair。\n\n\nword_count.insert({word, 1});\nword_count.insert(make_pair(word, 1));\nword_count.insert(pair\nstring, size_t\n(word, 1));\nword_count.insert(map\nstring, size_t\n::value_type(word, 1));\n\n\n\n\n向multiset或multimap添加元素\n\n\n由于一个multi容器中的关键字不必唯一，在这些类型上调用insert总会插入一个元素：\n\n\nmultimap\nstring, string\n authors;\n// 插入第一个元素\nauthors.insert({\nBarth, John\n, \nSot-Weed Factor\n});\n// 正确，添加第二个元素\nauthors.insert({\nBarth, John\n}, \nLost in the Funhouse\n);\n\n\n\n\n对允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器。\n\n\n删除元素\n\n\n关联容器定义了三个版本的erase：\n\n\n- 与顺序容器一样，传递给erase一个迭代器或一个迭代器范围来删除一个元素或一个元素范围。\n\n\n- 接受一个key_type参数，删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。\n\n\n对于保存不重复关键字的容器，erase的返回值总是0或1。\n\n\nmap的下标操作\n\n\nmap和unordered_map容器提供了下标运算符和一个对应的at函数。\n\n\nset类型不支持下标操作，不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。\n\n\nmap下标运算符接受一个索引获取与此关键字相关联的值，如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。\n\n\n使用下标操作的返回值\n\n\n当对一个map进行下标操作时，会获得一个mapped_type对象。\n\n\n当解引用一个map迭代器时，会得到一个value_type对象。\n\n\n【NOTE】与vector与string不同，map的下标运算符返回的类型与解引用map迭代器得到的类型不同。\n\n\n访问元素\n\n\n如果我们关心的只不过是一个特定元素是否已在容器中，使用find比较好。\n\n\n对于不允许重复关键字的容器，可能使用find还是count没什么区别。\n\n\n对于允许重复关键字的容器，count会统计有多少个元素有相同的关键字。\n\n\n无序容器\n\n\n无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。\n\n\n在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。", 
            "title": "ch11 关联容器"
        }, 
        {
            "location": "/ch11 关联容器/#_1", 
            "text": "关联容器与顺序容器有着根本的不同：  - 关联容器中的元素是按关键字来保存和访问的。  - 顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。  关联容器支持高效的关键字查找和访问，有两个主要的关联容器：  - map，其元素是一些关键字-值对，关键字起到索引作用，值则表示与之相关的数据。  - set，每个元素只包含一个关键字。", 
            "title": "关联容器"
        }, 
        {
            "location": "/ch11 关联容器/#_2", 
            "text": "map是关键字-值对的集合，通常被称为关联数组。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。  set就是关键字的简单集合。  具体使用案例见书本p375。", 
            "title": "使用关联容器"
        }, 
        {
            "location": "/ch11 关联容器/#_3", 
            "text": "关联容器（有序的和无序的）都支持9.2节（第294页）中介绍的普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如push_front。  除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作（见p388）和类型别名（见p381）。  关联容器的迭代器都是双向的。", 
            "title": "关联容器概述"
        }, 
        {
            "location": "/ch11 关联容器/#_4", 
            "text": "map string, size_t  word_count; // 空容器\nset string  exclude = { the ,  but ,  and }; // 列表初始化\n\n// 三个元素；authors将姓映射为名\nmap string, string  authors = {\n    { Joyce ,  James },\n    { Austen ,  Jane },\n    { Dickens ,  Charles }\n};  初始化multimap或multiset  一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。  multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字（这些元素会相邻存储）。", 
            "title": "定义关联容器"
        }, 
        {
            "location": "/ch11 关联容器/#_5", 
            "text": "对于有序容器，关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的 运算符来比较两个关键字。  使用关键字类型的比较函数  用来阻止一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型（比如一个函数指针类型）。  bool compareIsbn(const Sales_data  lhs, const Sales_data  rhs)\n{\n    return lhs.isbn()   rhs.isbn();\n}\n\nmultiset Sales_data, decltype(compareIsbn*  bookstore(compareIsbn);", 
            "title": "关键字类型的要求"
        }, 
        {
            "location": "/ch11 关联容器/#pair", 
            "text": "pair类型定义在头文件utility中。  一个pair保存两个数据成员，pair是一个用来生成特定类型的模板。  pair string, string  anon; // 保存两个string\npair string, vector int  line; // 保存string和vector int   pair的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器：  pair string, string  author{ James ,  Joyce };  pair的数据成员是public的，两个成员分别是first，second。  创建pair对象的函数  pair string, int \nprocess(vector string   v)\n{\n    // 处理v\n    if (!v.empty())\n        return {v.back(), v.back().size()}; // 列表初始化\n    else\n        return pair string, int (); // 隐式构造返回值\n}", 
            "title": "pair类型"
        }, 
        {
            "location": "/ch11 关联容器/#_6", 
            "text": "除了表9.2(第295页)中列出的类型，关联容器还定义了这些类型：  - key_type, 此容器类型的关键字类型  - mapped_type, 每个关键字关联的类型，只适用于map  - value_type, 对于set，与key_type相同，对于map, 为 pair const key_type, mapped_type", 
            "title": "关联容器操作"
        }, 
        {
            "location": "/ch11 关联容器/#_7", 
            "text": "当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型。  【NOTE】必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值。  set的迭代器是const的  与不能改名map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改。  遍历关联容器  map和set类型都支持begin和end操作，我们可以利用这些函数获取迭代器，然后用迭代器来遍历容器。  auto map_it = word_count.cbegin();\nwhile (map_it != word_count.cend()) {\n    // ...\n    ++map_it; // 递增迭代器，移动到下一个元素\n}  【NOTE】当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。  关联容器和算法  我们通常不对关联容器使用泛型算法。更多讨论见书本p383。", 
            "title": "关联容器迭代器"
        }, 
        {
            "location": "/ch11 关联容器/#_8", 
            "text": "关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。  向map添加元素  对一个map进行insert操作时，必须记住元素类型是pair。  word_count.insert({word, 1});\nword_count.insert(make_pair(word, 1));\nword_count.insert(pair string, size_t (word, 1));\nword_count.insert(map string, size_t ::value_type(word, 1));  向multiset或multimap添加元素  由于一个multi容器中的关键字不必唯一，在这些类型上调用insert总会插入一个元素：  multimap string, string  authors;\n// 插入第一个元素\nauthors.insert({ Barth, John ,  Sot-Weed Factor });\n// 正确，添加第二个元素\nauthors.insert({ Barth, John },  Lost in the Funhouse );  对允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器。", 
            "title": "添加元素"
        }, 
        {
            "location": "/ch11 关联容器/#_9", 
            "text": "关联容器定义了三个版本的erase：  - 与顺序容器一样，传递给erase一个迭代器或一个迭代器范围来删除一个元素或一个元素范围。  - 接受一个key_type参数，删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。  对于保存不重复关键字的容器，erase的返回值总是0或1。", 
            "title": "删除元素"
        }, 
        {
            "location": "/ch11 关联容器/#map", 
            "text": "map和unordered_map容器提供了下标运算符和一个对应的at函数。  set类型不支持下标操作，不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。  map下标运算符接受一个索引获取与此关键字相关联的值，如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。  使用下标操作的返回值  当对一个map进行下标操作时，会获得一个mapped_type对象。  当解引用一个map迭代器时，会得到一个value_type对象。  【NOTE】与vector与string不同，map的下标运算符返回的类型与解引用map迭代器得到的类型不同。", 
            "title": "map的下标操作"
        }, 
        {
            "location": "/ch11 关联容器/#_10", 
            "text": "如果我们关心的只不过是一个特定元素是否已在容器中，使用find比较好。  对于不允许重复关键字的容器，可能使用find还是count没什么区别。  对于允许重复关键字的容器，count会统计有多少个元素有相同的关键字。", 
            "title": "访问元素"
        }, 
        {
            "location": "/ch11 关联容器/#_11", 
            "text": "无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。  在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。", 
            "title": "无序容器"
        }, 
        {
            "location": "/ch12 动态内存/", 
            "text": "动态内存\n\n\n\n\n我们的程序到目前为止只使用过静态内存或栈内存。\n\n\n- 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。\n\n\n- 栈内存用来保存定义在函数内的非static对象。\n\n\n分配在静态或栈内存中的对象由编译器自动创建和销毁。\n\n\n- 对于栈对象，仅在其定义的程序块运行时才存在。\n\n\n- static对象在使用之前分配，在程序结束时销毁。\n\n\n除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称作自由空间或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象。\n\n\n动态对象的生存周期由程序来控制，当动态对象不再使用时，我们的代码必须显示地销毁它们。\n\n\n动态内存与智能指针\n\n\nC++中，动态内存的管理是通过一对运算符来完成的：\n\n\n- new，在动态内存中为对象分配空间并返回一个指向该对象的指针。\n\n\n- delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。\n\n\n为了更容易（同时也更安全）地使用动态内存，新的标准提供了两种智能指针（smart pointer）类型来管理动态对象。\n\n\n智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。两种智能指针的区别在于管理底层指针的方式：\n\n\n- shared_ptr允许多个指针指向同一个对象；\n\n\n- unique_ptr则“独占”所指向的对象。\n\n\n- 标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。\n\n\n这些类型定义在memory头文件中。\n\n\nshared_ptr类\n\n\n智能指针也是模板，当创建一个智能指针时，必须提供指向的类型：\n\n\nshared_ptr\nstring\n p1; // shared_ptr, 可以指向string\n\n\n\n\n默认初始化的智能指针中保存着一个空指针。\n\n\n解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：\n\n\nif (p1) *p1 = \nhi\n;\n\n\n\n\n更多的操作见p401。\n\n\nmake_shared函数\n\n\n最安全的分配和使用动态内存的方法是调用标准库函数make_shared。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。\n\n\n// 指向一个值为42的int的shared_ptr\nshared_ptr\nint\n p3 = make_shared\nint\n(42);\n\n// p6指向一个动态分配的空vector\nstring\n\nauto p6 = make_shared\nvector\nstring\n();\n\n\n\n\n类似顺序容器的emplace成员，make_shared用其参数来构造给定类型的对象。如果我们不传递任何参数，对象就会进行值初始化。\n\n\nshared_ptr的拷贝和赋值\n\n\n每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：\n\n\nauto p = make_shared\nint\n(42); // p指向的对象只有一个p一个引用者\nauto q(p); // p和q指向相同的对象，此对象有两个引用者\n\n\n\n\n可以认为每个shared_ptr都有一个关联的计数器，通常称其为\n引用计数\n(reference count)。无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器就会递减。\n\n\n一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。\n\n\n【NOTE】到底是由一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。\n\n\n使用了动态生存期的资源的类\n\n\n程序使用动态内存出于以下三种原因之一：\n\n\n1. 程序不知道自己需要多少对象\n\n\n2. 程序不知道所需对象的准确类型\n\n\n3. 程序需要在多个对象间共享数据\n\n\n容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因的例子。本章介绍出于第三种原因的例子。\n\n\n直接管理内存\n\n\nC++提供了new运算符分配内存，delete运算符释放new分配的内存。\n\n\n相对于智能指针，使用这两个运算符管理内存非常容易出错。\n\n\n使用new动态分配和初始化对象\n\n\n在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针：\n\n\nint *pi = new int; // pi指向一个动态分配的、未初始化的无名对象\n\n\n\n\n默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型将使用默认构造函数进行初始化。\n\n\n可以使用直接初始化方式来初始化一个动态分配的对象：\n\n\nint *pi = new int(1024);\n\nvector\nint\n *pv = new vector\nint\n{1, 2, 3};\n\n\n\n\n动态分配的const对象\n\n\n用new分配const对象是合法的：\n\n\nconst int *pci = new const int(1024);\n\n\n\n\n类似其他任何const对象，一个动态分配的const对象必须进行初始化。\n\n\n内存耗尽\n\n\n一旦一个程序用光了它所有可用的内存，new表达式就会失败（并返回一个空指针）。默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。\n\n\n我们可以改变使用new的方式来阻止它抛出异常：\n\n\n// 如果分配失败，new返回一个空指针\nint *p1 = new int; // 如果分配失败，new抛出std::bad_alloc\nint *p2 = new (nothrow) int; // 如果分配失败，new返回一个空指针\n\n\n\n\n释放动态内存\n\n\n为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式（delete expression）来将动态内存归还给系统。\n\n\ndelete p; // p必须指向一个动态分配的对象或是一个空指针\n\n\n\n\n释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的。\n\n\n更多有关使用原生指针管理动态内存的危险的讨论见书本p409。\n\n\nshared_ptr和new结合使用\n\n\n如果不初始化一个智能指针，它就会被初始化为一个空指针。还可以用new返回的指针来初始化智能指针：\n\n\nshared_ptr\nint\n p2(new int(42)); // p2指向一个值为42的int\n\n\n\n\n接受指针参数的智能指针构造函数是explicit的，因此必须使用直接初始化形式来初始化一个智能指针：\n\n\nshared_ptr\nint\n p1 = new int(1024); // 错误：必须使用直接初始化形式\nshared_ptr\nint\n p2(new int(1024));  // 正确：使用了直接初始化形式\n\n\n\n\n默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象（可以提供自己的操作来替代delete）。\n\n\n更多关于智能指针使用的讨论见p412。\n\n\n智能指针和异常\n\n\n程序需要确保在异常发生后资源能被正确地释放。一个简单的确保资源被释放的方法是使用智能指针：\n\n\nvoid f()\n{\n    shared_ptr\nint\n sp(new int(42)); // 分配一个对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n} // 函数结束时shared_ptr自动释放内存\n\n\n\n\n无论是否发生了异常，局部对象都会被销毁，sp是指向这块内存的唯一指针，因此内存会被释放掉。\n\n\n如果使用了内置指针管理内存，且在new之后在对应的delete之前发生了异常，则内存不会被释放：\n\n\nvoid f()\n{\n    int *ip = new int(42); // 动态分配一个新对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n    delete ip; // 在退出以前释放内存\n}\n\n\n\n\n如果在new和delete之间发生了异常，且异常未在f中被捕获，则内存就永远不会被释放了。\n\n\nunique_ptr\n\n\n与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。\n\n\n与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。\n\n\nunique_ptr\ndouble\n p1; // 可以指向一个double的unique_ptr\nunique_ptr\nint\n p2(new int(42)); // p2指向一个值为42的int\n\n\n\n\n由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。\n\n\n更多有关unique_ptr操作的讨论见p418。\n\n\nweak_ptr\n\n\nweak_ptr是一种不控制所指对象生存期的智能指针，它指向一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象还是会被释放。\n\n\n当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：\n\n\nauto p = make_shared\nint\n(42);\nweak_ptr\nint\n wp(p); // wp若共享p；p的引用计数未改变\n\n\n\n\n由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。如果存在，lock返回一个指向共享对象的shared_ptr。否则返回一个空shared_ptr。\n\n\nif (shared_ptr\nint\n np = wp.lock()) { // 如果np不为空则条件成立\n    // 在if中，np与p共享对象\n}\n\n\n\n\n动态数组\n\n\nC++语言和标准库提供了两种一次分配一个对象数组的方法：\n\n\n- 一种new表达式语法，可以分配并初始化一个对象数组。\n\n\n- 标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。\n\n\n【BEST PRACITICES】大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。\n\n\nnew和数组\n\n\n为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目：\n\n\n// 调用get_size确定分配多少个int\nint *pia = new int[get_size()]; // pia指向第一个int\n\n\n\n\n方括号中的大小必须是整型，但不必是常量。\n\n\n分配一个数组会得到一个元素类型的指针\n\n\n当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。\n\n\n【WARNING】要记住我们所说的动态数组并不是数组类型，这是很重要的。\n\n\n初始化动态分配对象的数组\n\n\n默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号：\n\n\nint *pia = new int[10]; // 10个未初始化的int\nint *pia2 = new int[10](); // 10个值初始化为0的int\n\n\n\n\n新标准中，我们还可以提供一个元素初始化器的花括号列表：\n\n\n// 10个int分别用列表中对应的初始化器初始化\nint *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};\n\n\n\n\n释放动态数组\n\n\n为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对：\n\n\ndelete p; // p必须指向一个动态分配的对象或为空\ndelete [] pa; // pa必须指向一个动态分配的数组或为空\n\n\n\n\n数组的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。\n\n\n智能指针和动态数组\n\n\n标准库提供了一个可以管理new分配的数组的unique_ptr版本：\n\n\n// up指向一个包含10个未初始化int的数组\nunique_ptr\nint[]\n up(new int[10]);\nup.release(); // 自动用delete[]销毁其指针\n\n\n\n\n【MY NOTE】这里似乎有错误，release方法据p418介绍，是放弃对指针的控制权，返回指针。并不销毁原来指向的对象。另一个事例见：http://zh.cppreference.com/w/cpp/memory/unique_ptr/release\n\n\n当unique_ptr销毁时，会自动销毁其指向的对象。\n\n\nallocator类\n\n\nnew和delete有一些灵活性上的局限：\n\n\n- new将内存分配和对象构造组合在了一起。\n\n\n- delete将对象析构和内存释放组合在了一起。\n\n\n当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。\n\n\nallocator类\n\n\n标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它分配的内存是原始的、未构造的。\n\n\nallocator也是模板，为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定对象类型来确定恰当的内存大小和对齐位置：\n\n\nallocator\nstring\n alloc; // 可以分配string的allocator对象\nauto const p = alloc.allocate(n); // 分配n个未初始化的string\n\n\n\n\nallocator分配未构造的内存\n\n\nallocator分配的内存是未构造的（unconstructed）。我们按需要在此内存中构造对象。\n\n\nauto q = p; // q指向最后构造元素之后的位置\nalloc.construct(q++); // *q为空字符串\nalloc.construct(q++, \nhi\n); // *q为hi!\n\n\n\n\n还未构造对象的情况下就使用原始内存是错误的。\n\n\n当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。\n\n\nwhile (q != p)\n    alloc.destroy(--q); // 释放我们真正构造的string\n\n\n\n\n一旦元素被销毁后，就可以重新用这部分内存来保存其他string，也可以将其归还给系统。释放内存通过调用deallocate来完成：\n\n\nalloc.deallocate(p, n);\n\n\n\n\n我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。\n\n\n拷贝和填充未初始化内存的算法\n\n\n标准库为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。见p429。", 
            "title": "ch12 动态内存"
        }, 
        {
            "location": "/ch12 动态内存/#_1", 
            "text": "我们的程序到目前为止只使用过静态内存或栈内存。  - 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。  - 栈内存用来保存定义在函数内的非static对象。  分配在静态或栈内存中的对象由编译器自动创建和销毁。  - 对于栈对象，仅在其定义的程序块运行时才存在。  - static对象在使用之前分配，在程序结束时销毁。  除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称作自由空间或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象。  动态对象的生存周期由程序来控制，当动态对象不再使用时，我们的代码必须显示地销毁它们。", 
            "title": "动态内存"
        }, 
        {
            "location": "/ch12 动态内存/#_2", 
            "text": "C++中，动态内存的管理是通过一对运算符来完成的：  - new，在动态内存中为对象分配空间并返回一个指向该对象的指针。  - delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。  为了更容易（同时也更安全）地使用动态内存，新的标准提供了两种智能指针（smart pointer）类型来管理动态对象。  智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。两种智能指针的区别在于管理底层指针的方式：  - shared_ptr允许多个指针指向同一个对象；  - unique_ptr则“独占”所指向的对象。  - 标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。  这些类型定义在memory头文件中。", 
            "title": "动态内存与智能指针"
        }, 
        {
            "location": "/ch12 动态内存/#shared_ptr", 
            "text": "智能指针也是模板，当创建一个智能指针时，必须提供指向的类型：  shared_ptr string  p1; // shared_ptr, 可以指向string  默认初始化的智能指针中保存着一个空指针。  解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：  if (p1) *p1 =  hi ;  更多的操作见p401。  make_shared函数  最安全的分配和使用动态内存的方法是调用标准库函数make_shared。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。  // 指向一个值为42的int的shared_ptr\nshared_ptr int  p3 = make_shared int (42);\n\n// p6指向一个动态分配的空vector string \nauto p6 = make_shared vector string ();  类似顺序容器的emplace成员，make_shared用其参数来构造给定类型的对象。如果我们不传递任何参数，对象就会进行值初始化。  shared_ptr的拷贝和赋值  每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：  auto p = make_shared int (42); // p指向的对象只有一个p一个引用者\nauto q(p); // p和q指向相同的对象，此对象有两个引用者  可以认为每个shared_ptr都有一个关联的计数器，通常称其为 引用计数 (reference count)。无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器就会递减。  一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。  【NOTE】到底是由一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。  使用了动态生存期的资源的类  程序使用动态内存出于以下三种原因之一：  1. 程序不知道自己需要多少对象  2. 程序不知道所需对象的准确类型  3. 程序需要在多个对象间共享数据  容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因的例子。本章介绍出于第三种原因的例子。", 
            "title": "shared_ptr类"
        }, 
        {
            "location": "/ch12 动态内存/#_3", 
            "text": "C++提供了new运算符分配内存，delete运算符释放new分配的内存。  相对于智能指针，使用这两个运算符管理内存非常容易出错。  使用new动态分配和初始化对象  在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针：  int *pi = new int; // pi指向一个动态分配的、未初始化的无名对象  默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型将使用默认构造函数进行初始化。  可以使用直接初始化方式来初始化一个动态分配的对象：  int *pi = new int(1024);\n\nvector int  *pv = new vector int {1, 2, 3};  动态分配的const对象  用new分配const对象是合法的：  const int *pci = new const int(1024);  类似其他任何const对象，一个动态分配的const对象必须进行初始化。  内存耗尽  一旦一个程序用光了它所有可用的内存，new表达式就会失败（并返回一个空指针）。默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。  我们可以改变使用new的方式来阻止它抛出异常：  // 如果分配失败，new返回一个空指针\nint *p1 = new int; // 如果分配失败，new抛出std::bad_alloc\nint *p2 = new (nothrow) int; // 如果分配失败，new返回一个空指针  释放动态内存  为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式（delete expression）来将动态内存归还给系统。  delete p; // p必须指向一个动态分配的对象或是一个空指针  释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的。  更多有关使用原生指针管理动态内存的危险的讨论见书本p409。", 
            "title": "直接管理内存"
        }, 
        {
            "location": "/ch12 动态内存/#shared_ptrnew", 
            "text": "如果不初始化一个智能指针，它就会被初始化为一个空指针。还可以用new返回的指针来初始化智能指针：  shared_ptr int  p2(new int(42)); // p2指向一个值为42的int  接受指针参数的智能指针构造函数是explicit的，因此必须使用直接初始化形式来初始化一个智能指针：  shared_ptr int  p1 = new int(1024); // 错误：必须使用直接初始化形式\nshared_ptr int  p2(new int(1024));  // 正确：使用了直接初始化形式  默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象（可以提供自己的操作来替代delete）。  更多关于智能指针使用的讨论见p412。", 
            "title": "shared_ptr和new结合使用"
        }, 
        {
            "location": "/ch12 动态内存/#_4", 
            "text": "程序需要确保在异常发生后资源能被正确地释放。一个简单的确保资源被释放的方法是使用智能指针：  void f()\n{\n    shared_ptr int  sp(new int(42)); // 分配一个对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n} // 函数结束时shared_ptr自动释放内存  无论是否发生了异常，局部对象都会被销毁，sp是指向这块内存的唯一指针，因此内存会被释放掉。  如果使用了内置指针管理内存，且在new之后在对应的delete之前发生了异常，则内存不会被释放：  void f()\n{\n    int *ip = new int(42); // 动态分配一个新对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n    delete ip; // 在退出以前释放内存\n}  如果在new和delete之间发生了异常，且异常未在f中被捕获，则内存就永远不会被释放了。", 
            "title": "智能指针和异常"
        }, 
        {
            "location": "/ch12 动态内存/#unique_ptr", 
            "text": "与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。  与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。  unique_ptr double  p1; // 可以指向一个double的unique_ptr\nunique_ptr int  p2(new int(42)); // p2指向一个值为42的int  由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。  更多有关unique_ptr操作的讨论见p418。", 
            "title": "unique_ptr"
        }, 
        {
            "location": "/ch12 动态内存/#weak_ptr", 
            "text": "weak_ptr是一种不控制所指对象生存期的智能指针，它指向一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象还是会被释放。  当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：  auto p = make_shared int (42);\nweak_ptr int  wp(p); // wp若共享p；p的引用计数未改变  由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。如果存在，lock返回一个指向共享对象的shared_ptr。否则返回一个空shared_ptr。  if (shared_ptr int  np = wp.lock()) { // 如果np不为空则条件成立\n    // 在if中，np与p共享对象\n}", 
            "title": "weak_ptr"
        }, 
        {
            "location": "/ch12 动态内存/#_5", 
            "text": "C++语言和标准库提供了两种一次分配一个对象数组的方法：  - 一种new表达式语法，可以分配并初始化一个对象数组。  - 标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。  【BEST PRACITICES】大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。", 
            "title": "动态数组"
        }, 
        {
            "location": "/ch12 动态内存/#new", 
            "text": "为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目：  // 调用get_size确定分配多少个int\nint *pia = new int[get_size()]; // pia指向第一个int  方括号中的大小必须是整型，但不必是常量。  分配一个数组会得到一个元素类型的指针  当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。  【WARNING】要记住我们所说的动态数组并不是数组类型，这是很重要的。  初始化动态分配对象的数组  默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号：  int *pia = new int[10]; // 10个未初始化的int\nint *pia2 = new int[10](); // 10个值初始化为0的int  新标准中，我们还可以提供一个元素初始化器的花括号列表：  // 10个int分别用列表中对应的初始化器初始化\nint *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};  释放动态数组  为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对：  delete p; // p必须指向一个动态分配的对象或为空\ndelete [] pa; // pa必须指向一个动态分配的数组或为空  数组的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。  智能指针和动态数组  标准库提供了一个可以管理new分配的数组的unique_ptr版本：  // up指向一个包含10个未初始化int的数组\nunique_ptr int[]  up(new int[10]);\nup.release(); // 自动用delete[]销毁其指针  【MY NOTE】这里似乎有错误，release方法据p418介绍，是放弃对指针的控制权，返回指针。并不销毁原来指向的对象。另一个事例见：http://zh.cppreference.com/w/cpp/memory/unique_ptr/release  当unique_ptr销毁时，会自动销毁其指向的对象。", 
            "title": "new和数组"
        }, 
        {
            "location": "/ch12 动态内存/#allocator", 
            "text": "new和delete有一些灵活性上的局限：  - new将内存分配和对象构造组合在了一起。  - delete将对象析构和内存释放组合在了一起。  当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。  allocator类  标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它分配的内存是原始的、未构造的。  allocator也是模板，为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定对象类型来确定恰当的内存大小和对齐位置：  allocator string  alloc; // 可以分配string的allocator对象\nauto const p = alloc.allocate(n); // 分配n个未初始化的string  allocator分配未构造的内存  allocator分配的内存是未构造的（unconstructed）。我们按需要在此内存中构造对象。  auto q = p; // q指向最后构造元素之后的位置\nalloc.construct(q++); // *q为空字符串\nalloc.construct(q++,  hi ); // *q为hi!  还未构造对象的情况下就使用原始内存是错误的。  当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。  while (q != p)\n    alloc.destroy(--q); // 释放我们真正构造的string  一旦元素被销毁后，就可以重新用这部分内存来保存其他string，也可以将其归还给系统。释放内存通过调用deallocate来完成：  alloc.deallocate(p, n);  我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。  拷贝和填充未初始化内存的算法  标准库为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。见p429。", 
            "title": "allocator类"
        }, 
        {
            "location": "/ch13 拷贝控制_1/", 
            "text": "拷贝控制1\n\n\n\n\n当定义一个类时，我们显示或隐式地指定在此类型的对象拷贝、移动、赋值、销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。\n\n\n这些操作称为\n拷贝控制操作（copy control）\n。\n\n\n如果一类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。\n\n\n拷贝、赋值与销毁\n\n\n拷贝构造函数\n\n\n如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。\n\n\nclass Foo {\npublic:\n    Foo();               // 默认构造函数\n    Foo(const Foo\n);     // 拷贝构造函数\n};\n\n\n\n\n合成拷贝构造函数\n\n\n如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。合成拷贝构造函数（synthesized copy constructor）会将其参数的成员逐个拷贝到正在创建的对象中。\n\n\n每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝；如果数组元素是类类型，则使用元素的拷贝构造函数来逐个进行拷贝。\n\n\n拷贝初始化\n\n\n拷贝初始化通常使用拷贝构造函数来完成。拷贝初始化不仅在用=定义变量时会发生，在下列情况下也会发生：\n\n\n- 将一个对象作为实参传递给一个非引用类型的形参\n\n\n- 从一个返回类型为非引用类型的函数返回一个对象\n\n\n- 从花括号列表初始化一个数组中的元素或一个聚合类中的成员\n\n\n某些类类型还会对它们所分配的对象使用拷贝初始化，如调用标准库容器的insert或push成员时。\n\n\n拷贝赋值运算符\n\n\n类可以控制其对象如何赋值：\n\n\nSales_data trans, accum;\ntrans = accum;    // 使用Sales_data的拷贝赋值运算符\n\n\n\n\n重载赋值运算符\n\n\n重载运算符（overloaded operator）本质上是函数，其名字是由operator关键字后接运算符符号组成。因此，赋值运算符就是一个名为operator=的函数。\n\n\n重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。对于二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。\n\n\n拷贝赋值运算符接受一个与其所在类相同类型的参数：\n\n\nclass Foo {\npublic:\n    Foo\n operator=(const Foo\n);    // 赋值运算符\n};\n\n\n\n\n合成拷贝赋值运算符\n\n\n如果一个类未定义自己的拷贝赋值运算符，编译器会为它合成一个。合成的版本会将右侧运算对象的每个非static成员赋予左侧运算符对象的对应成员。对于数组类型的成员，逐个赋值数组元素。\n\n\n析构函数\n\n\n析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。\n\n\n析构函数是一个类的成员函数，名字由一个波浪号接类名构成。它没有返回值，也不接受参数：\n\n\nclass Foo {\npublic:\n    ~Foo();    // 析构函数\n};\n\n\n\n\n由于析构函数不接受参数，因此它不能被重载。一个类只能有一个析构函数。\n\n\n析构函数完成什么工作\n\n\n在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。\n\n\n在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序逆序销毁。\n\n\n通常，析构函数释放对象在生存期分配的所有资源。\n\n\n析构的部分是隐式的，不存在像构造函数中初始化列表的东西控制成员如何销毁。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。\n\n\nNote：隐式销毁一个内置类型指针的成员不会delete它所指向的对象。\n\n\n什么时候会调用析构函数\n\n\n无论何时一个对象被销毁，就会自动调用其析构函数：\n\n\n- 变量在离开其作用域时被销毁\n\n\n- 当一个对象被销毁时，其成员被销毁\n\n\n- 容器或数组被销毁时，其元素被销毁\n\n\n- 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁\n\n\n- 对于临时对象，当创建它的完整表达式结束时被销毁\n\n\n三/五法则\n\n\nC++语言不要求为一个类定义所有的拷贝控制操作，但是这些操作通常应该看成一个整体。\n\n\n需要析构函数的类也需要拷贝和赋值操作\n\n\n当要决定一个类是否要定义自己的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。如果需要，那么几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。\n\n\n原因分析如下：假如有一个类的构造函数中需要动态分配内存，在析构函数中释放动态内存。如果采用合成的拷贝和赋值操作，那么指向动态内存的指针就会被拷贝，当类的对象释放时，此指针指向的内存可能被释放两次，其结果是未定义的。\n\n\n需要拷贝操作的类也需要赋值操作，反之亦然\n\n\n如果一个类为一个对象分配一个独有的、唯一的序号。这个类就需要一个拷贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要定义拷贝赋值运算符来避免将序号赋予目的对象。\n\n\n此例子引入了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。\n\n\n使用=default\n\n\n可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。\n\n\n阻止拷贝\n\n\n当使用某些拷贝控制操作没有合理意义的情况下，定义类时必须采用某种机制加以阻止。比如iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。\n\n\n定义删除的函数\n\n\n在新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为\n删除的函数（deleted function）\n来阻止拷贝。\n\n\n删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。\n\n\n在函数的参数列表后接=delete来通知编译器，将它定义为删除的：\n\n\nstruct NoCopy {\n    NoCopy(const NoCopy\n) = delete;    // 阻止拷贝\n    NoCopy\n operator=(const NoCopy\n) = delete;    // 阻止赋值\n};\n\n\n\n\n还可以对任何函数指定=delete。\n\n\n析构函数不能是删除的成员\n\n\n如果析构函数被删除，就无法销毁此类对象。对于一个删除了析构函数的类型（或者其某个成员删除了析构函数），编译器将不允许定义该类型的变量或创建该类型的临时对象。\n\n\n合成的拷贝控制成员可能是删除的\n\n\n对于某些类来说，编译器会把一些合成的成员定义为删除的函数。其规则是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。\n\n\n细节见书本。\n\n\nprivate拷贝控制\n\n\n在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。为了阻止友元和成员函数访问私有成员，就不定义这些成员。", 
            "title": "拷贝控制1"
        }, 
        {
            "location": "/ch13 拷贝控制_1/#1", 
            "text": "当定义一个类时，我们显示或隐式地指定在此类型的对象拷贝、移动、赋值、销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。  这些操作称为 拷贝控制操作（copy control） 。  如果一类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。", 
            "title": "拷贝控制1"
        }, 
        {
            "location": "/ch13 拷贝控制_1/#_1", 
            "text": "", 
            "title": "拷贝、赋值与销毁"
        }, 
        {
            "location": "/ch13 拷贝控制_1/#_2", 
            "text": "如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。  class Foo {\npublic:\n    Foo();               // 默认构造函数\n    Foo(const Foo );     // 拷贝构造函数\n};  合成拷贝构造函数  如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。合成拷贝构造函数（synthesized copy constructor）会将其参数的成员逐个拷贝到正在创建的对象中。  每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝；如果数组元素是类类型，则使用元素的拷贝构造函数来逐个进行拷贝。  拷贝初始化  拷贝初始化通常使用拷贝构造函数来完成。拷贝初始化不仅在用=定义变量时会发生，在下列情况下也会发生：  - 将一个对象作为实参传递给一个非引用类型的形参  - 从一个返回类型为非引用类型的函数返回一个对象  - 从花括号列表初始化一个数组中的元素或一个聚合类中的成员  某些类类型还会对它们所分配的对象使用拷贝初始化，如调用标准库容器的insert或push成员时。", 
            "title": "拷贝构造函数"
        }, 
        {
            "location": "/ch13 拷贝控制_1/#_3", 
            "text": "类可以控制其对象如何赋值：  Sales_data trans, accum;\ntrans = accum;    // 使用Sales_data的拷贝赋值运算符  重载赋值运算符  重载运算符（overloaded operator）本质上是函数，其名字是由operator关键字后接运算符符号组成。因此，赋值运算符就是一个名为operator=的函数。  重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。对于二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。  拷贝赋值运算符接受一个与其所在类相同类型的参数：  class Foo {\npublic:\n    Foo  operator=(const Foo );    // 赋值运算符\n};  合成拷贝赋值运算符  如果一个类未定义自己的拷贝赋值运算符，编译器会为它合成一个。合成的版本会将右侧运算对象的每个非static成员赋予左侧运算符对象的对应成员。对于数组类型的成员，逐个赋值数组元素。", 
            "title": "拷贝赋值运算符"
        }, 
        {
            "location": "/ch13 拷贝控制_1/#_4", 
            "text": "析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。  析构函数是一个类的成员函数，名字由一个波浪号接类名构成。它没有返回值，也不接受参数：  class Foo {\npublic:\n    ~Foo();    // 析构函数\n};  由于析构函数不接受参数，因此它不能被重载。一个类只能有一个析构函数。  析构函数完成什么工作  在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。  在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序逆序销毁。  通常，析构函数释放对象在生存期分配的所有资源。  析构的部分是隐式的，不存在像构造函数中初始化列表的东西控制成员如何销毁。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。  Note：隐式销毁一个内置类型指针的成员不会delete它所指向的对象。  什么时候会调用析构函数  无论何时一个对象被销毁，就会自动调用其析构函数：  - 变量在离开其作用域时被销毁  - 当一个对象被销毁时，其成员被销毁  - 容器或数组被销毁时，其元素被销毁  - 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁  - 对于临时对象，当创建它的完整表达式结束时被销毁", 
            "title": "析构函数"
        }, 
        {
            "location": "/ch13 拷贝控制_1/#_5", 
            "text": "C++语言不要求为一个类定义所有的拷贝控制操作，但是这些操作通常应该看成一个整体。  需要析构函数的类也需要拷贝和赋值操作  当要决定一个类是否要定义自己的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。如果需要，那么几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。  原因分析如下：假如有一个类的构造函数中需要动态分配内存，在析构函数中释放动态内存。如果采用合成的拷贝和赋值操作，那么指向动态内存的指针就会被拷贝，当类的对象释放时，此指针指向的内存可能被释放两次，其结果是未定义的。  需要拷贝操作的类也需要赋值操作，反之亦然  如果一个类为一个对象分配一个独有的、唯一的序号。这个类就需要一个拷贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要定义拷贝赋值运算符来避免将序号赋予目的对象。  此例子引入了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。", 
            "title": "三/五法则"
        }, 
        {
            "location": "/ch13 拷贝控制_1/#default", 
            "text": "可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。", 
            "title": "使用=default"
        }, 
        {
            "location": "/ch13 拷贝控制_1/#_6", 
            "text": "当使用某些拷贝控制操作没有合理意义的情况下，定义类时必须采用某种机制加以阻止。比如iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。  定义删除的函数  在新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为 删除的函数（deleted function） 来阻止拷贝。  删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。  在函数的参数列表后接=delete来通知编译器，将它定义为删除的：  struct NoCopy {\n    NoCopy(const NoCopy ) = delete;    // 阻止拷贝\n    NoCopy  operator=(const NoCopy ) = delete;    // 阻止赋值\n};  还可以对任何函数指定=delete。  析构函数不能是删除的成员  如果析构函数被删除，就无法销毁此类对象。对于一个删除了析构函数的类型（或者其某个成员删除了析构函数），编译器将不允许定义该类型的变量或创建该类型的临时对象。  合成的拷贝控制成员可能是删除的  对于某些类来说，编译器会把一些合成的成员定义为删除的函数。其规则是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。  细节见书本。  private拷贝控制  在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。为了阻止友元和成员函数访问私有成员，就不定义这些成员。", 
            "title": "阻止拷贝"
        }, 
        {
            "location": "/ch13 拷贝控制_2/", 
            "text": "拷贝控制2\n\n\n\n\n拷贝控制和资源管理\n\n\n通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。\n\n\n为了定义这些成员，必须先确定类对象的拷贝语义。一般有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。\n\n\n类的行为像一个值，意味着它应该有自己的状态。当拷贝一个对象时，副本和原对象是完全独立的。改变副本不会影响原对象，反之亦然。\n\n\n类的行为像一个指针，意味着拷贝一个对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。\n\n\n详细讨论见书本和代码案例。\n\n\n使用这样的例子解释：\n\n\nclass HasPtr {\npublic:\n     // 准备定义构造函数、拷贝构造函数、拷贝赋值运算符、析构函数\nprivate:\n    std::string *ps;    // 管理的类外资源\n    int i;\n};\n\n\n\n\n行为像值的类\n\n\n对于类管理的资源，每个对象都应该拥有一份自己的拷贝。\n\n\n为了实现类值的行为，HasPtr需要：\n\n\n- 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针\n\n\n- 定义一个析构函数来释放string\n\n\n- 定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string\n\n\n类值拷贝赋值运算符\n\n\n一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧对象的现有成员就是安全的了。接着再将数据从临时对象拷贝到左侧运算对象的成员中。\n\n\n这样就可以正确进行自赋值操作。\n\n\n定义行为像指针的类\n\n\n这种情况下，HasPtr仍然需要通过析构函数来释放string。但只有当最后一个指向string的HasPtr对象销毁时，它才可以释放string。\n\n\n令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。shared_ptr类自己会记录有多少用户共享它所指向的对象，当没有用户使用对象时，shared_ptr类负责释放资源。\n\n\n但是有时候我们希望直接管理资源，这种情况下，可以使用\n引用计数（reference count）\n。\n\n\n引用计数\n\n\n引用计数的工作方式如下：\n\n\n- 除了初始化对象外，每个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少个对象与正在创建的对象共享状态。计数器初始化为1。\n\n\n- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。\n\n\n- 析构函数递减计数器，如果变为0，则析构函数释放状态。\n\n\n- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，则销毁状态。\n\n\n引用计数应该保存在动态内存中，这样才能保证共享引用计数。\n\n\n交换操作\n\n\n管理资源的类通常还定义一个名为swap的函数。一些算法会在需要交换两个元素时调用swap。\n\n\n如果一个类定义了自己的swap，那么算法将使用类自定义的版本。否则算法将使用标准库定义的swap。标准库定义的版本可能像这样：\n\n\nHasPtr temp = v1;\nv1 = v2;\nv2 = temp;\n\n\n\n\n但对于HasPtr这样管理外部资源的类，可以直接交换指针，而不是分配多一个副本。\n\n\nstring *temp = v1.ps;\nv1.ps = v2.ps;\nv2.ps = temp;\n\n\n\n\nswap函数的存在是为了优化代码。详细定义方法见书本。\n\n\n在赋值运算符中使用swap\n\n\n定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为\n拷贝并交换（copy and swap）\n的技术。\n\n\nHasPtr \nHasPtr::operator=(HasPtr rhs)\n{\n    swap(*this, rhs);\n    return *this;\n}\n\n\n\n\nrhs是右侧运算对象的一个副本，它会在赋值运算符结束时被自动销毁。\n\n\n这种技术自动处理了自赋值的情况且天然就是异常安全的。\n\n\n对象移动\n\n\n新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在很多情况下，对象拷贝后就立即销毁了，这种情况下，使用移动而非拷贝会大幅提升性能。\n\n\n使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（指针或IO缓冲）。因此，这些类的对象不能拷贝但可以移动。\n\n\n右值引用\n\n\n为了支持移动操作，新标准引入了一种新的类型——\n右值引用（rvalue reference）\n。右值引用必须绑定到右值——一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源移动到另一个对象中。\n\n\nint i = 42;\nint \nr = i;    // 正确：r引用i\nint \nrr = i;  // 错误：不能将一个右值引用绑定到一个左值上\nint \nr2 = i * 42; // 正确：将rr2绑定到乘法结果上\n\n\n\n\n左值持久，右值短暂\n\n\n左值与右值的区别：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。\n\n\n标准库move函数\n\n\n虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。方法是通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用。\n\n\nint \nrr3 = std::move(i); // OK\n\n\n\n\nmove调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。调用move就意味着承诺：除了对i赋值或销毁它外，我们将不再使用它。\n\n\n移动构造函数和移动赋值运算符\n\n\n移动的版本从给定对象“窃取”资源而不是拷贝资源。\n\n\n移动构造函数的第一个参数是该类型的一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。\n\n\n除了完成资源的移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。\n\n\nStrVec::StrVec(StrVec \ns) noexcpet // 移动构造函数不应抛出异常\n // 成员初始化器接管s中的资源\n : elements(s.elements), first_free(s.first_free), cap(s.cap)\n{\n    // 令s进入这样的状态——对其运行析构函数是安全的\n    s.elements = s.first_free = s.cap = nullptr;\n}\n\n\n\n\n移动操作、标准库容器和异常\n\n\n移动操作通常不分配资源，因此通常不会抛出异常，我们应当将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。\n\n\n通知的方法是在构造函数中指明noexcept。\n\n\n详细的解释见书本p474。\n\n\n移动赋值运算符\n\n\n移动赋值运算符执行与析构函数和移动构造函数相同的工作。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：\n\n\nStrVec\n StrVec::operator=(StrVec \nrhs) noexcept\n{\n    // 直接检测自赋值\n    if (this != \nrhs) {\n        free();    // 释放已有资源\n        elements = rhs.elements; // 接管资源\n        first_free = rhs.first_free;\n        cap = rhs.cap;\n        // 将rhs置于可析构状态\n        rhs.elements = rhs.first_free = rhs.cap = nullptr;\n    }\n    return *this;\n}\n\n\n\n\n移后源对象必须可析构\n\n\n从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。\n\n\n除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的，即可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。但是移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。\n\n\n【WARNING】 在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。\n\n\n合成的移动操作\n\n\n如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。\n\n\n如果类定义了一个移动构造函数或一个移动赋值运算符，则该类的拷贝版本会被定义为删除的。\n\n\n移动右值，拷贝左值\n\n\n如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。\n\n\nStrVec v1, v2;\nv1 = v2;                    // v2是左值，使用拷贝赋值\nStrVec getVec(istream\n);    // getVec返回一个右值\nv2 = getVec(cin);           // getVec(cin)是一个右值；使用移动赋值\n\n\n\n\n更新三/五法则\n\n\n所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。\n\n\n右值引用和成员函数\n\n\n除了构造函数和赋值运算符之外，成员函数也可以提供拷贝和移动的版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。\n\n\nvoid push_back(const X\n);   // 拷贝：绑定到任意类型的X\nvoid push_back(X\n);        // 移动：只能绑定到类型X的可修改的右值\n\n\n\n\n右值和左值引用成员函数\n\n\n我们可以强制左侧运算对象是一个左值。\n\n\n我们指出this的左值/右值属性的方式与定义const成员函数相同，即，在参数列表后放置一个\n引用限定符（reference qualifier）\n。\n\n\nclass Foo {\npublic:\n    Foo \noperator=(const Foo\n) \n;   // 只能向可修改的左值赋值\n};\n\n\n\n\n引用限定符可以是\n或\n，分别指出this可以指向一个左值或右值。如果存在const限定符，引用限定符必须跟随在const限定符之后。", 
            "title": "拷贝控制2"
        }, 
        {
            "location": "/ch13 拷贝控制_2/#2", 
            "text": "", 
            "title": "拷贝控制2"
        }, 
        {
            "location": "/ch13 拷贝控制_2/#_1", 
            "text": "通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。  为了定义这些成员，必须先确定类对象的拷贝语义。一般有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。  类的行为像一个值，意味着它应该有自己的状态。当拷贝一个对象时，副本和原对象是完全独立的。改变副本不会影响原对象，反之亦然。  类的行为像一个指针，意味着拷贝一个对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。  详细讨论见书本和代码案例。  使用这样的例子解释：  class HasPtr {\npublic:\n     // 准备定义构造函数、拷贝构造函数、拷贝赋值运算符、析构函数\nprivate:\n    std::string *ps;    // 管理的类外资源\n    int i;\n};", 
            "title": "拷贝控制和资源管理"
        }, 
        {
            "location": "/ch13 拷贝控制_2/#_2", 
            "text": "对于类管理的资源，每个对象都应该拥有一份自己的拷贝。  为了实现类值的行为，HasPtr需要：  - 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针  - 定义一个析构函数来释放string  - 定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string  类值拷贝赋值运算符  一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧对象的现有成员就是安全的了。接着再将数据从临时对象拷贝到左侧运算对象的成员中。  这样就可以正确进行自赋值操作。", 
            "title": "行为像值的类"
        }, 
        {
            "location": "/ch13 拷贝控制_2/#_3", 
            "text": "这种情况下，HasPtr仍然需要通过析构函数来释放string。但只有当最后一个指向string的HasPtr对象销毁时，它才可以释放string。  令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。shared_ptr类自己会记录有多少用户共享它所指向的对象，当没有用户使用对象时，shared_ptr类负责释放资源。  但是有时候我们希望直接管理资源，这种情况下，可以使用 引用计数（reference count） 。  引用计数  引用计数的工作方式如下：  - 除了初始化对象外，每个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少个对象与正在创建的对象共享状态。计数器初始化为1。  - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。  - 析构函数递减计数器，如果变为0，则析构函数释放状态。  - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，则销毁状态。  引用计数应该保存在动态内存中，这样才能保证共享引用计数。", 
            "title": "定义行为像指针的类"
        }, 
        {
            "location": "/ch13 拷贝控制_2/#_4", 
            "text": "管理资源的类通常还定义一个名为swap的函数。一些算法会在需要交换两个元素时调用swap。  如果一个类定义了自己的swap，那么算法将使用类自定义的版本。否则算法将使用标准库定义的swap。标准库定义的版本可能像这样：  HasPtr temp = v1;\nv1 = v2;\nv2 = temp;  但对于HasPtr这样管理外部资源的类，可以直接交换指针，而不是分配多一个副本。  string *temp = v1.ps;\nv1.ps = v2.ps;\nv2.ps = temp;  swap函数的存在是为了优化代码。详细定义方法见书本。  在赋值运算符中使用swap  定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为 拷贝并交换（copy and swap） 的技术。  HasPtr  HasPtr::operator=(HasPtr rhs)\n{\n    swap(*this, rhs);\n    return *this;\n}  rhs是右侧运算对象的一个副本，它会在赋值运算符结束时被自动销毁。  这种技术自动处理了自赋值的情况且天然就是异常安全的。", 
            "title": "交换操作"
        }, 
        {
            "location": "/ch13 拷贝控制_2/#_5", 
            "text": "新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在很多情况下，对象拷贝后就立即销毁了，这种情况下，使用移动而非拷贝会大幅提升性能。  使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（指针或IO缓冲）。因此，这些类的对象不能拷贝但可以移动。", 
            "title": "对象移动"
        }, 
        {
            "location": "/ch13 拷贝控制_2/#_6", 
            "text": "为了支持移动操作，新标准引入了一种新的类型—— 右值引用（rvalue reference） 。右值引用必须绑定到右值——一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源移动到另一个对象中。  int i = 42;\nint  r = i;    // 正确：r引用i\nint  rr = i;  // 错误：不能将一个右值引用绑定到一个左值上\nint  r2 = i * 42; // 正确：将rr2绑定到乘法结果上  左值持久，右值短暂  左值与右值的区别：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。  标准库move函数  虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。方法是通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用。  int  rr3 = std::move(i); // OK  move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。调用move就意味着承诺：除了对i赋值或销毁它外，我们将不再使用它。", 
            "title": "右值引用"
        }, 
        {
            "location": "/ch13 拷贝控制_2/#_7", 
            "text": "移动的版本从给定对象“窃取”资源而不是拷贝资源。  移动构造函数的第一个参数是该类型的一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。  除了完成资源的移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。  StrVec::StrVec(StrVec  s) noexcpet // 移动构造函数不应抛出异常\n // 成员初始化器接管s中的资源\n : elements(s.elements), first_free(s.first_free), cap(s.cap)\n{\n    // 令s进入这样的状态——对其运行析构函数是安全的\n    s.elements = s.first_free = s.cap = nullptr;\n}  移动操作、标准库容器和异常  移动操作通常不分配资源，因此通常不会抛出异常，我们应当将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。  通知的方法是在构造函数中指明noexcept。  详细的解释见书本p474。  移动赋值运算符  移动赋值运算符执行与析构函数和移动构造函数相同的工作。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：  StrVec  StrVec::operator=(StrVec  rhs) noexcept\n{\n    // 直接检测自赋值\n    if (this !=  rhs) {\n        free();    // 释放已有资源\n        elements = rhs.elements; // 接管资源\n        first_free = rhs.first_free;\n        cap = rhs.cap;\n        // 将rhs置于可析构状态\n        rhs.elements = rhs.first_free = rhs.cap = nullptr;\n    }\n    return *this;\n}  移后源对象必须可析构  从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。  除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的，即可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。但是移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。  【WARNING】 在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。  合成的移动操作  如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。  如果类定义了一个移动构造函数或一个移动赋值运算符，则该类的拷贝版本会被定义为删除的。  移动右值，拷贝左值  如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。  StrVec v1, v2;\nv1 = v2;                    // v2是左值，使用拷贝赋值\nStrVec getVec(istream );    // getVec返回一个右值\nv2 = getVec(cin);           // getVec(cin)是一个右值；使用移动赋值  更新三/五法则  所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。", 
            "title": "移动构造函数和移动赋值运算符"
        }, 
        {
            "location": "/ch13 拷贝控制_2/#_8", 
            "text": "除了构造函数和赋值运算符之外，成员函数也可以提供拷贝和移动的版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。  void push_back(const X );   // 拷贝：绑定到任意类型的X\nvoid push_back(X );        // 移动：只能绑定到类型X的可修改的右值  右值和左值引用成员函数  我们可以强制左侧运算对象是一个左值。  我们指出this的左值/右值属性的方式与定义const成员函数相同，即，在参数列表后放置一个 引用限定符（reference qualifier） 。  class Foo {\npublic:\n    Foo  operator=(const Foo )  ;   // 只能向可修改的左值赋值\n};  引用限定符可以是 或 ，分别指出this可以指向一个左值或右值。如果存在const限定符，引用限定符必须跟随在const限定符之后。", 
            "title": "右值引用和成员函数"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/", 
            "text": "操作重载与类型转换\n\n\n\n\n基本概念\n\n\n重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。\n\n\n重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。\n\n\n如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的参数数量比运算符的运算对象总数少一个。\n\n\np491列出了可以重载的运算符。\n\n\n直接调用一个重载的运算符函数\n\n\n我们能像调用普通函数一样直接调用运算符函数：\n\n\ndata1 + data2;              // 普通的表达式\noperator+(data1, data2);    // 等价的函数调用\n\ndata1 += data2;             // 基于“调用”的表达式\ndata1.operator+(data2);     // 对成员运算符函数的等价调用\n\n\n\n\n某些运算符不应该被重载\n\n\n\n\n\n\n逻辑与、逻辑或运算符，这些运算符指定了运算对象的求值顺序，又因为使用重载的函数运算符本质上是一次函数调用，那么求值顺序的规则无法得到应用。\n\n\n\n\n\n\n取地址运算符，逗号运算符，C++语言已定义了其特殊含义，不应该被重载，否则其行为将异于常态。\n\n\n\n\n\n\np492讨论了如何选择重载运算符。\n\n\n选择作为成员或者非成员\n\n\n下面的准则有助于选择将运算符定义为成员函数还是普通的非成员函数：\n\n\n\n\n\n\n赋值（=）、下标（[]）、调用（()）、成员访问箭头（-\n），必须是成员。\n\n\n\n\n\n\n复合赋值运算符一般来说应该是成员，但并非必须。\n\n\n\n\n\n\n改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。\n\n\n\n\n\n\n具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算等，通常应该是普通的非成员函数。\n\n\n\n\n\n\n输入和输出运算符\n\n\nIO标准库分别使用\n和\n执行输入和输出操作，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。\n\n\n重载输出运算符\n\n\n通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。是非常量是因为向流写入内容会改变其状态；是引用是因为无法复制一个ostream对象。\n\n\n第二个形参一般来说是一个常量的引用，它是我们想打印的类类型。是引用是因为我们希望避免复制实参；是常量是因为打印对象不会改变对象的内容。\n\n\n为了与其他输出运算符保持一致，operator\n一般要返回它的ostream形参。\n\n\nostream \noperator\n(ostream \nos, const Sales_data \nitem)\n{\n    os \n item.isbn() \n \n \n \n item.units_sold \n \n \n\n       \n item.revenue \n \n \n \n item.avg_price();\n\n    return os;\n}\n\n\n\n\n【NOTE】通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。\n\n\n重载输入运算符\n\n\n通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用，返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将输入读入到这个对象中。\n\n\nistream\n operator\n(istream \nis, Sales_data \nitem)\n{\n    double price; // 不需要初始化，因为我们将先读入数据到price，之后才使用它\n    is \n item.bookNo \n item.units_sold \n price;\n    if (is)\n        item.revenue = item.units_sold * price;\n    else\n        item = Sales_data(); // 输入失败：对象被赋予默认状态\n\n    return is;\n}\n\n\n\n\n【NOTE】输入运算符必须处理输入可能失败的情况，而输出运算符不需要。\n\n\n算术和关系运算符\n\n\n通常情况下，我们把算术运算符和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。\n\n\n如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符：\n\n\nSales_data\noperator+(const Sales_data \nlhs, const Sales_data \nrhs)\n{\n    Sales_data sum = lhs;       // 把lhs的数据成员拷贝给sum\n    sum += rhs;                 // 把rhs加到sum中\n    return sum;\n}\n\n\n\n\n相等运算符\n\n\nbool operator==(const Sales_data \nlhs, const Sales_data \nrhs)\n{\n    return lhs.isbn() == rhs.isbn() \n\n           lhs.units_sold == rhs.units_sold \n\n           lhs.revenue == rhs.revenue;\n}\n\nbool operator!=(const Sales_data \nlhs, const Sales_data \nrhs)\n{\n    return !(lhs == rhs);\n}\n\n\n\n\n赋值运算符\n\n\n之前介绍了拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。\n\n\n比如：\n\n\nvector\nstring\n v;\nv = {\na\n, \nb\n, \nc\n};\n\n\n\n\nclass StrVec {\npublic:\n    StrVec\n operator=(std::initializer_list\nstd::string\n)\n    {\n        // ...\n    }\n};\n\n\n\n\n复合赋值运算符\n\n\n// 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针\nSales_data\n Sales_data::operator+=(const Sales_data \nrhs)\n{\n    units_sold += rhs.units_sold;\n    revenue += rhs.revenue;\n    return *this;\n}\n\n\n\n\n下标运算符\n\n\n表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。\n\n\n为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。最好同时定义下标运算符的常量版本和非常量版本，当用作于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。\n\n\nclass StrVec {\npublic:\n    std::string\n operator[](std::size_t n) { return elements[n]; }\n\n    const std::string\n operator[](std::size_t n) const { return elements[n]; }\n\nprivate:\n    std::string *elements;  // 指向数组首元素的指针\n};\n\n\n\n\n递增和递减运算符\n\n\n在迭代器类中通常会实现递增运算符++和递减运算符--，这两种运算符使得类可以在元素的序列中前后移动。\n\n\n对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。\n\n\nclass StrBlobPtr {\npublic:\n    StrBlobPtr\n operator++();       // 前置运算符\n    StrBlobPtr\n operator--();\n};\n\n\n\n\n区分前置和后置运算符\n\n\n后置版本接受一个额外的（不被使用的）int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。\n\n\nclass StrBlobPtr {\npublic:\n    StrBlobPtr operator++(int);     // 后置运算符\n    StrBlobPtr operator--(int);\n};\n\n\n\n\n【NOTE】为了与内置版本保持一致，后置运算符应该返回对象的原值，返回的形式是一个值而非引用。\n\n\n成员访问运算符\n\n\n在迭代器类及智能指针类中常常用到解引用运算符和箭头运算符。\n\n\nclass StrBlobPtr {\npublic:\n    std::string\n operator*() const;\n    std::string* operator-\n() const\n    {\n        // 将实际工作委托给解引用运算符\n        return \n this-\noperator*();\n    }\n};\n\n\n\n\n函数调用运算符", 
            "title": "ch14 操作重载与类型转换"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_1", 
            "text": "", 
            "title": "操作重载与类型转换"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_2", 
            "text": "重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。  重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。  如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的参数数量比运算符的运算对象总数少一个。  p491列出了可以重载的运算符。  直接调用一个重载的运算符函数  我们能像调用普通函数一样直接调用运算符函数：  data1 + data2;              // 普通的表达式\noperator+(data1, data2);    // 等价的函数调用\n\ndata1 += data2;             // 基于“调用”的表达式\ndata1.operator+(data2);     // 对成员运算符函数的等价调用  某些运算符不应该被重载    逻辑与、逻辑或运算符，这些运算符指定了运算对象的求值顺序，又因为使用重载的函数运算符本质上是一次函数调用，那么求值顺序的规则无法得到应用。    取地址运算符，逗号运算符，C++语言已定义了其特殊含义，不应该被重载，否则其行为将异于常态。    p492讨论了如何选择重载运算符。  选择作为成员或者非成员  下面的准则有助于选择将运算符定义为成员函数还是普通的非成员函数：    赋值（=）、下标（[]）、调用（()）、成员访问箭头（- ），必须是成员。    复合赋值运算符一般来说应该是成员，但并非必须。    改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。    具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算等，通常应该是普通的非成员函数。", 
            "title": "基本概念"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_3", 
            "text": "IO标准库分别使用 和 执行输入和输出操作，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。", 
            "title": "输入和输出运算符"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_4", 
            "text": "通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。是非常量是因为向流写入内容会改变其状态；是引用是因为无法复制一个ostream对象。  第二个形参一般来说是一个常量的引用，它是我们想打印的类类型。是引用是因为我们希望避免复制实参；是常量是因为打印对象不会改变对象的内容。  为了与其他输出运算符保持一致，operator 一般要返回它的ostream形参。  ostream  operator (ostream  os, const Sales_data  item)\n{\n    os   item.isbn()         item.units_sold      \n         item.revenue         item.avg_price();\n\n    return os;\n}  【NOTE】通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。", 
            "title": "重载输出运算符&lt;&lt;"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_5", 
            "text": "通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用，返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将输入读入到这个对象中。  istream  operator (istream  is, Sales_data  item)\n{\n    double price; // 不需要初始化，因为我们将先读入数据到price，之后才使用它\n    is   item.bookNo   item.units_sold   price;\n    if (is)\n        item.revenue = item.units_sold * price;\n    else\n        item = Sales_data(); // 输入失败：对象被赋予默认状态\n\n    return is;\n}  【NOTE】输入运算符必须处理输入可能失败的情况，而输出运算符不需要。", 
            "title": "重载输入运算符&gt;&gt;"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_6", 
            "text": "通常情况下，我们把算术运算符和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。  如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符：  Sales_data\noperator+(const Sales_data  lhs, const Sales_data  rhs)\n{\n    Sales_data sum = lhs;       // 把lhs的数据成员拷贝给sum\n    sum += rhs;                 // 把rhs加到sum中\n    return sum;\n}", 
            "title": "算术和关系运算符"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_7", 
            "text": "bool operator==(const Sales_data  lhs, const Sales_data  rhs)\n{\n    return lhs.isbn() == rhs.isbn()  \n           lhs.units_sold == rhs.units_sold  \n           lhs.revenue == rhs.revenue;\n}\n\nbool operator!=(const Sales_data  lhs, const Sales_data  rhs)\n{\n    return !(lhs == rhs);\n}", 
            "title": "相等运算符"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_8", 
            "text": "之前介绍了拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。  比如：  vector string  v;\nv = { a ,  b ,  c };  class StrVec {\npublic:\n    StrVec  operator=(std::initializer_list std::string )\n    {\n        // ...\n    }\n};  复合赋值运算符  // 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针\nSales_data  Sales_data::operator+=(const Sales_data  rhs)\n{\n    units_sold += rhs.units_sold;\n    revenue += rhs.revenue;\n    return *this;\n}", 
            "title": "赋值运算符"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_9", 
            "text": "表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。  为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。最好同时定义下标运算符的常量版本和非常量版本，当用作于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。  class StrVec {\npublic:\n    std::string  operator[](std::size_t n) { return elements[n]; }\n\n    const std::string  operator[](std::size_t n) const { return elements[n]; }\n\nprivate:\n    std::string *elements;  // 指向数组首元素的指针\n};", 
            "title": "下标运算符"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_10", 
            "text": "在迭代器类中通常会实现递增运算符++和递减运算符--，这两种运算符使得类可以在元素的序列中前后移动。  对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。  class StrBlobPtr {\npublic:\n    StrBlobPtr  operator++();       // 前置运算符\n    StrBlobPtr  operator--();\n};  区分前置和后置运算符  后置版本接受一个额外的（不被使用的）int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。  class StrBlobPtr {\npublic:\n    StrBlobPtr operator++(int);     // 后置运算符\n    StrBlobPtr operator--(int);\n};  【NOTE】为了与内置版本保持一致，后置运算符应该返回对象的原值，返回的形式是一个值而非引用。", 
            "title": "递增和递减运算符"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_11", 
            "text": "在迭代器类及智能指针类中常常用到解引用运算符和箭头运算符。  class StrBlobPtr {\npublic:\n    std::string  operator*() const;\n    std::string* operator- () const\n    {\n        // 将实际工作委托给解引用运算符\n        return   this- operator*();\n    }\n};", 
            "title": "成员访问运算符"
        }, 
        {
            "location": "/ch14 操作重载与类型转换/#_12", 
            "text": "", 
            "title": "函数调用运算符"
        }
    ]
}