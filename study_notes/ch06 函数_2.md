# <center>函数2</center>

---

## 函数重载

如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为**重载（overload）函数**。比如：

```
void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);
```

这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。

函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。

【NOTE】main函数不能重载。

不允许两个函数除了返回类型以外其他所有的要素都相同。比如：

```
Record lookup(const Account&);
bool lookup(const Account&);    // 错误，与上一个函数相比只有返回类型不同
```

> my note: 返回类型不同的函数，也可以是重载的。只要函数名相同而形参有明显的不同。

**重载和const形参**

顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：

```
Record lookup(Phone);
Record lookup(const Phone);    // 重复声明
```

如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：

```
Record lookup(Account&);       // 此函数作用于Account的引用
Record lookup(const Account&); // 新函数，作用于常量引用
```

这种情况下，当我们传递一个非常量对象时，编译器会优先选用非常量版本的函数（尽管传给常量版本的也可以）。

**const_cast和重载**

const_cast在重载函数的情境中最有用。比如这两个重载函数：

```
// 比较两个string对象的长度，返回较短的那个引用
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2; 
}

// 重载
string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```

下面重载的版本中，首先将它的实参强制转换成了对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在一个非常量实参上。因此，可以再将其转换回普通的const&，这显然是安全的。

> my note: 传入非常量的实参将调用非常量的版本。

**调用重载的函数**

定义了一组重载函数后，我们需要以合理的实参调用它们。**函数匹配（function matching）**是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。

当调用重载函数时有三种可能的结果：

- 编译器找到一个与实参**最佳匹配（best match）**的函数，并生成调用该函数的代码。

- 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配（no match）**的错误信息。

- 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为**二义性调用（ambiguous call）**。

### 重载与作用域

【WARNING】一般来说，将函数声明置于局部作用域内不是一个明智的选择。

如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。对于函数而言也是如此。

> my note: 具体例子可见于书本p210。总之，如果在内层作用域声明了一个函数，那么外层的同名的函数都将变得不可见，因此无法找到外层的重载版本。

## 特殊用途语言特性

### 默认实参

这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的**默认实参**（default argument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。如：

```
typedef string::size_type sz;
string screen(sz ht = 24, sz wid = 80, char backrnd = ' ');
```

一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

**使用默认实参调用函数**

如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。如：

```
string window;
window = screen();    // 等价于screen(24, 80, ' ');
window = stcreen(66); // 等价于screen(66, 80, ' ');
```

函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。

当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。

**默认实参初始值**

局部变量不可以作为默认实参。另外只要表达式的类型可以转换成形参类型，该表达式就可以作为默认实参。

如：

```
int g_a = 0;
void f(int a = g_a);
```

### 内联函数和constexpr函数

调用普通函数比直接写其语句要慢，这是因为调用函数包含一些额外的工作。

**内联函数可以避免函数调用的开销**

将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。

内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。

内联机制用于优化规模小，流程直接，频繁调用的函数。

**constexpr函数**

是指能用于**常量表达式**的函数。

函数的返回类型及所有形参都得是字面值类型，且函数体内必须有且只有一条return语句。

如：

```
constexpr int new_sz() { return 8; }
constexpr int foo = new_sz();
```

constexpr函数被隐式地指定为内联函数。

**把内联函数和constexpr函数放在头文件内**

这是因为内联函数和constexpr函数可以多次定义，且必须完全一致。所以把它们都定义在头文件内。

### 调试帮助

程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。

**assert预处理宏**

assert是一种**预处理宏（preprocessor macro）**。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：

```
assert(expr);
```

首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。

assert宏定义在cassert头文件中。

assert宏常用于检查“不能发生”的条件。（即确实不应该发生的事情，发生了就崩溃吧）

**NDEBUG预处理变量**

assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。

我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。或者使用编译器提供的命令行选项定义预处理变量：

```
$ CC -D NDEBUG main.c
```

这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。

我们可以把assert当成调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。

除了用于assert，也可以使用NDEBUG编写自己的调试代码。

比如：

```
void print(const int ia[], size_t size)
{
#ifndef NDEBUG
    // __func__是编译器定义的一个局部静态变量，用于存放函数的名字
    cerr << __func__ << "": array size is: " << size << endl;
#endif

// ...
}
```

编译器为每个函数都定义了`__func__`，除此之外，预处理器还定义了4个对于调试程序很有用的名字：

- `__FILE__`, 存放文件名的字符串字面值。

- `__LINE__`, 存放当前行号的整型字面值。

- `__TIME__`, 存放文件编译时间的字符串字面值。

- `__DATA__`, 存放文件编译日期的字符串字面值。

## 函数匹配

本节(p217)讲述编译器如何确定调用哪个重载函数，并以下述这组函数及其调用为例：

```c++
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
f(5.6);    // 调用void f(double, double);
```

**确定候选函数和可行函数**

函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数成为**候选函数（candidate function）**。候选函数具备两个特征：

1. 与被调用函数同名。

2. 其声明在调用点可见。

第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为**可行函数（viable function）**。可行函数也有两个特征：

1. 其形参数量与本次调用提供的实参数量相等。

2. 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。

> my note: 如果没有找到可行函数，编译器将报告无匹配函数的错误。

**寻找最佳匹配（如果有的话）**

第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。

如果有且只有一个函数满足下列条件，则匹配成功：

- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。

- 至少有一个实参的匹配优于其他可行函数提供的匹配。

> my note: 如果编译器检查了每一个可行函数，没有一个能脱颖而出，则会报告二义性调用错误。

### 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：

1. 精确匹配，包括以下情况：

 - 实参类型和形参类型相同。

 - 实参从数组类型或函数类型转换成对应的指针类型。

 - 向实参添加顶层const或者从实参中删除顶层const。

2. 通过const转换实现的匹配（p143）。

3. 通过类型提升实现的匹配（p142）。

4. 通过算数类型转换或指针转换实现的匹配（p142）。

5. 通过类类型转换实现的匹配（参见14.9节，p514）。

> my note: 详细案例解析见书本p220。

## 函数指针

函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：

```c++
bool lengthCompare(const string&, const string&);
```

该函数的类型是：`bool (const string&, const string&);`

要想声明一个指向该函数的指针，只需要将函数名替换成指针即可：

```c++
bool (*pf)(const string&, const string&);
```

**使用函数指针**

当我们把函数名作为一个值使用的时候，该函数名自动转换成指针（指向该函数的）。

例如，可以这样给把函数地址赋值给指针：

```c++
pf = lengthCompare; // pf指向名为lengthCompare的函数

pf = &lengthCompare; // 等价的赋值语句，取地址符是可选的
```

可以直接对指向函数的指针调用该函数，无须解引用指针：

```
bool b1 = pf("Hello", "Hi");
bool b2 = (*pf)("Hello", "Hi"); // 等价调用
bool b3 = lengthCompare("Hello", "Hi"); // 等价调用
```

可以给函数指针赋一个nullptr或0，表示没有指向任何函数。

**重载函数的指针**

当使用了重载函数时，编译器必须确定一个能和指针类型精确匹配的函数，即返回类型和形参列表都要一样。

**函数指针形参**

不能定义函数类型的形参，但是形参可以是指向函数的指针。

当把函数名作为实参使用，它会自动转换成指针。

定义一个函数（以及指针）类型的方法有：

- typedef

```c++
typedef bool Func(int); // Func是函数类型
typedef bool (*FuncP)(int); // FuncP是函数指针类型
```

- decltype

假如已经有了一个函数：`bool Foo(int);`

```
decltype(Foo) Func;
decltype(Foo) *FuncP;
```

- using

```
using Func = bool(int);
using FuncP = bool(*)(int);
```

> my note: 关于使用直接声明的方法，以及使用尾置返回类型的方法来确定一个返回类型为函数指针的函数，见书本p223。因为我觉得使用上述别名定义已经能满足这种需求了。