# 第18章 用于大型程序的工具

与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更高。大规模应用程序的特殊要求包括：

- 在独立开发的子系统之间协同处理错误的能力。

- 使用各种库（可能包含独立开发的库）进行协同开发的能力。

- 对比较复杂的应用概念建模的能力。

这三种C++语言特性正好能满足上述要求：异常处理、命名空间和多重继承。

---

## 异常处理

异常处理（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。

### 抛出异常

在C++语言中，我们通过抛出（throwing）一条表达式来引发（raised）一个异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。

当执行一个throw时，后面的语句将不再被执行。程序的控制权从throw转移到与之匹配的catch模块。该catch可能是同一个函数中的局部catch，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权的转移有两个重要的含义：

1. 沿着调用链的函数可能会提早退出。

2. 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。

!!!note
	1. 一个异常如果没有被捕获，则它将终止当前的程序。
	2. 析构函数不应该抛出异常。

**异常对象**

异常对象（exception object）是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。如果表达式是类类型，则它必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之对应的指针类型。

当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。如果一条throw表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出。

### 捕获异常

catch子句（catch clause）中的异常声明（exception declaration）看起来像是只包含一个形参的函数形参列表。

声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，但不能是右值引用。

当进入一个catch语句后，通过异常对象初始化异常声明中的参数。如果catch的参数类型是非引用类型，则该参数是异常对象的一个副本；如果是引用类型，则他是异常对象的一个别名。

要注意的一点是：异常声明的静态类型将决定catch语句所能执行的操作。如果catch的参数是基类类型，则catch无法使用派生类特有的任何成员。

**查找匹配的处理代码**

在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的catch语句。

!!!note
	如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最底端的类（most derived type）放在前面，而将继承链最顶端的类（least derived type）放在后面。

**重新抛出**

有时，一个单独的catch语句不能完整地处理某个异常。在执行了某些校正操作之后，当前的catch可能会决定由调用链更上一层的函数接着处理异常。一条catch语句通过重新抛出（rethrowing）的操作将异常传递给另外一个catch语句：

```
throw;
```

空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate。

一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。

```c++
catch (my_error &eObj) {
	eObj.status = errCodes::serverErr;	// 修改了异常对象
	throw;								// 异常对象的status成员是severErr
}
catch (other_error eObj) {
	eObj.status = errCodes::badErr;		// 只修改了异常对象的局部副本
	throw;								// 异常对象的status成员没有改变
}
```

**捕获所有异常的处理代码**

为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常（catch-all）的处理代码，形如catch(...)。它可以与任意类型的异常匹配。

catch(...)通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工作，随后重新抛出异常：

```c++
void manip() {
	try {
		// 这里的操作将引发并抛出一个异常
	}
	catch (...) {
		// 处理异常的某些特殊操作
		throw;
	}
}
```

!!!note
	如果catch(...)与其他几个catch语句一起出现，则catch(...)必须在最后的位置。出现在捕获所有异常语句后面的catch语句将永远不会被匹配。

### noexception异常说明

对于用户及编译器来说，预先知道某个函数不会抛出异常大有裨益。编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作。

在C++11新标准中，我们可以通过提供noexcept说明（noexcept specification）指定某个函数不会抛出异常，其形式是关键字noexcept紧跟在函数的参数列表后面：

```c++
void recoup(int) noexcept;				// 不会抛出异常
void alloc(int);						// 可能抛出异常
```

对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。

**违反异常说明**

编译器并不会在编译时检查noexcept说明。如果noexcept函数抛出了异常，程序就会调用terminate以确保遵守不在运行时抛出异常的承诺。

更多关于noexcept的讨论见p691。

## 命名空间

TODO